<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>程序人生</title>
    <link>https://congyx.com/</link>
    
    <atom:link href="https://congyx.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>欲买桂花同载酒，终不似，少年游。</description>
    <pubDate>Thu, 11 Aug 2022 04:43:43 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>知识图谱</title>
      <link>https://congyx.com/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/</link>
      <guid>https://congyx.com/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/</guid>
      <pubDate>Thu, 11 Aug 2022 04:12:11 GMT</pubDate>
      
      <description>&lt;h3 id=&quot;知识图谱&quot;&gt;&lt;a href=&quot;#知识图谱&quot; class=&quot;headerlink&quot; title=&quot;知识图谱&quot;&gt;&lt;/a&gt;知识图谱&lt;/h3&gt;&lt;h4 id=&quot;知识图谱和人工智能&quot;&gt;&lt;a href=&quot;#知识图谱和人工智能&quot; class=&quot;headerlink&quot; title=&quot;知识图谱和人工智能&quot;&gt;&lt;/a&gt;知识图谱和人工智能&lt;/h4&gt;&lt;p&gt;​        谈到知识图谱大部人可能很陌生，但说到人工智能，大家早已耳熟能详。目前，很多行业应用人工智能，让机器代替人进行简单重复性的工作。我们可以把人工智能分为两个层次，一个是感知层次，也就是听觉、视觉、嗅觉、味觉等等，目前人工智能在听觉和视觉方面做的比较好，语音识别，图像识别等，研究的学者越来越多，技术逐渐落地。人工智能的第二个层次，也就是认知层次，能够认识这个客观世界。而认知世界是通过大量的知识积累实现的，我们见到狗和猫，见过几次就能分辨出狗和猫，但如何让机器来分辨？&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="知识图谱"><a href="#知识图谱" class="headerlink" title="知识图谱"></a>知识图谱</h3><h4 id="知识图谱和人工智能"><a href="#知识图谱和人工智能" class="headerlink" title="知识图谱和人工智能"></a>知识图谱和人工智能</h4><p>​        谈到知识图谱大部人可能很陌生，但说到人工智能，大家早已耳熟能详。目前，很多行业应用人工智能，让机器代替人进行简单重复性的工作。我们可以把人工智能分为两个层次，一个是感知层次，也就是听觉、视觉、嗅觉、味觉等等，目前人工智能在听觉和视觉方面做的比较好，语音识别，图像识别等，研究的学者越来越多，技术逐渐落地。人工智能的第二个层次，也就是认知层次，能够认识这个客观世界。而认知世界是通过大量的知识积累实现的，我们见到狗和猫，见过几次就能分辨出狗和猫，但如何让机器来分辨？<span id="more"></span>这种认知能力是知识的运用，当我们见到狗，就会在潜意识中总结狗的特征，长耳朵，瘦脸，汪汪叫。猫的特征，短耳朵，圆脸，喵喵叫。这些知识会存储在人类的大脑中，作为经验知识，再次碰到类似的动物，人们马上就从记忆中想起该动物的特征，对号入座，马上判断出动物的类型。机器要想具有认知能力，也需要建立一个知识库，然后运用知识库来做一些事，这个知识库就是我们要说的知识图谱。从这个角度说，知识图谱是人工职能的一个重要分支，也是机器具有认知能力的基石，在人工智能领域具有非常重要的地位。</p><img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/Users\Congyingxu\AppData\Roaming\Typora\typora-user-images\image-20220811121725316.png" alt="image-20220811121725316" style="zoom:67%;"><h4 id="知识图谱的由来"><a href="#知识图谱的由来" class="headerlink" title="知识图谱的由来"></a>知识图谱的由来</h4><p>​        知识图谱（Knowledge Graph）是 Google 在2012年对其搜索引擎中使用的知识库的称谓。</p><p><img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/Users\Congyingxu\AppData\Roaming\Typora\typora-user-images\image-20220811123027705.png" alt="image-20220811123027705" style="zoom:67%;">众所周知，Google是做搜索引擎的，知识图谱出现之前，我们使用google、百度进行搜索的时候，搜索的结果是一堆网页，我们会根据搜索结果的网页题目再点击链接，才能看到具体内容，2012年google提出Google Knowldge Graph之后，利用知识图谱技术改善了搜索引擎核心，表现出来的效果就是我们现在使用搜索引擎进行搜索的时候，搜索结果会以一定的组织结构呈现，比如我们搜索比尔盖茨，结果如图所示</p><img src="https://img2018.cnblogs.com/blog/935893/201812/935893-20181229144559553-575365779.png" alt="img" style="zoom:67%;"><p>这样的搜索结果，与知识图谱出现之前的结果有什么区别呢，辛格尔博士对知识图谱的介绍很简短，things，not string，抓住了知识图谱的核心，也点出了知识图谱加入之后搜索发生的变化，以前的搜索，都是将要搜索的内容看作字符串，结果是和字符串进行匹配，将匹配程度高的排在前面，后面按照匹配度依次显示。利用知识图谱之后，将搜索的内容不再看作字符串，而是看作客观世界的事物，也就是一个个的个体。搜索比尔盖茨的时候，搜索引擎不是搜索“比尔盖茨”这个字符串，而是搜索比尔盖茨这个人，围绕比尔盖茨这个人，展示与他相关的人和事，左侧百科会把比尔盖茨的主要情况列举出来，右侧显示比尔盖茨的微软产品和与他类似的人，主要是一些IT行业的创始人。一个搜索结果页面就把和比尔盖茨的基本情况和他的主要关系都列出来了，搜索的人很容易找到自己感兴趣的结果。</p><h4 id="知识图谱是什么"><a href="#知识图谱是什么" class="headerlink" title="知识图谱是什么"></a>知识图谱是什么</h4><p>​        知识图谱本质上是一种语义网络，用图的形式描述客观事物，这里的图指的是数据结构中的图，也就是由节点和边组成的，这也是知识图谱（Knowledge Graph）的真实含义。</p><p><img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/Blog\source\resources\image-20220811122912945.png" alt="image-20220811122912945"></p><p>​        知识图谱中的节点表示概念和实体，概念是抽象出来的事物，实体是具体的事物；边表示事物的关系和属性，事物的内部特征用属性来表示，外部联系用关系来表示。</p><img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/Users\Congyingxu\AppData\Roaming\Typora\typora-user-images\image-20220811122645526.png" alt="image-20220811122645526" style="zoom:67%;"><h4 id="知识图谱如何组织数据"><a href="#知识图谱如何组织数据" class="headerlink" title="知识图谱如何组织数据"></a>知识图谱如何组织数据</h4><p>知识图谱是由实体和实体的关系组成，通过图的形式表现出来，那么实体和实体关系的这些数据在知识图谱中怎么组织呢，这就涉及到三元组的概念，在知识图谱中，节点-边-节点可以看作一条记录，第一个节点看作主语，边看作谓语，第二个节点看作宾语，主谓宾构成一条记录。知识图谱由这样的一条条三元组构成，围绕着一个主语，可以有很多的关系呈现，随着知识的不断积累，最终会形成一个庞大的知识图谱，知识图谱建设完成后，会包含海量的数据，内涵丰富的知识。</p><img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/Users\Congyingxu\AppData\Roaming\Typora\typora-user-images\image-20220811123405135.png" alt="image-20220811123405135" style="zoom:67%;"><h4 id="知识图谱的应用场景"><a href="#知识图谱的应用场景" class="headerlink" title="知识图谱的应用场景"></a>知识图谱的应用场景</h4><ol><li><p>辅助搜索</p><img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/Users\Congyingxu\AppData\Roaming\Typora\typora-user-images\image-20220811123649860.png" alt="image-20220811123649860" style="zoom:67%;"></li><li><p>辅助问答</p><img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/Users\Congyingxu\AppData\Roaming\Typora\typora-user-images\image-20220811123933101.png" alt="image-20220811123933101" style="zoom:67%;"><img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/Users\Congyingxu\AppData\Roaming\Typora\typora-user-images\image-20220811124015557.png" alt="image-20220811124015557" style="zoom:67%;"></li><li><p>辅助数据集成</p><img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/Users\Congyingxu\AppData\Roaming\Typora\typora-user-images\image-20220811124037375.png" alt="image-20220811124037375" style="zoom:67%;"></li><li><p>辅助决策</p></li></ol><p>​        知识图谱是一个具有本体特征的语义网络，可以看成是按照本体模式组织数据的知识库，以知识图谱为基础进行搜索，可以根据查询的内容进行语义搜索，查找需要找的本体或者本体的信息，这种语义搜索功能在google、百度、阿里巴巴等数据量大的公司里得到应用。智能问答，和语义搜索类似，对于提问内容，计算机首先要分析提问问题的语义，然后再将语义转换为查询语句，到知识图谱中查找，将最贴近的答案提供给提问者。推荐系统首先要采集用户的需求，分析用户的以往数据，提取共同特征，然后根据一定的规则，对用户提供推荐的产品。比如淘宝中记录用户经常购买的商品，经常浏览的商品，提取这些商品的共同特征，然后给这个用户打上标签，然后就给用户推荐具有类似特征的商品。</p>]]></content:encoded>
      
      
      <category domain="https://congyx.com/categories/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/">知识图谱</category>
      
      
      <category domain="https://congyx.com/tags/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/">知识图谱</category>
      
      
      <comments>https://congyx.com/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>字符串的一些问题</title>
      <link>https://congyx.com/2022/06/23/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</link>
      <guid>https://congyx.com/2022/06/23/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</guid>
      <pubDate>Thu, 23 Jun 2022 10:05:28 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;最近刷题发现字符串的一类题是自己的弱项，这里记录巩固复习&lt;/p&gt;
</description>
        
      
      
      
      <content:encoded><![CDATA[<p>最近刷题发现字符串的一类题是自己的弱项，这里记录巩固复习</p>]]></content:encoded>
      
      
      <category domain="https://congyx.com/categories/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <category domain="https://congyx.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      
      <comments>https://congyx.com/2022/06/23/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>异或运算</title>
      <link>https://congyx.com/2022/06/15/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/</link>
      <guid>https://congyx.com/2022/06/15/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/</guid>
      <pubDate>Wed, 15 Jun 2022 06:42:38 GMT</pubDate>
      
      <description>&lt;p&gt;今天遇到这样一个题目，&lt;a href=&quot;https://leetcode.cn/problems/single-number/&quot;&gt;136. 只出现一次的数字 - 力扣（LeetCode）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;起初看题目想到用哈希表实现，使用哈希表存储每个数字和该数字出现的次数。遍历数组即可得到每个数字出现的次数，并更新哈希表，最后遍历哈希表，得到只出现一次的数字。但是时间复杂度以及空间复杂度都是 O(n)，貌似不符合题目的要求。查看答案，标准的解法是异或运算(压根没想到)。。。。。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>今天遇到这样一个题目，<a href="https://leetcode.cn/problems/single-number/">136. 只出现一次的数字 - 力扣（LeetCode）</a></p><p>起初看题目想到用哈希表实现，使用哈希表存储每个数字和该数字出现的次数。遍历数组即可得到每个数字出现的次数，并更新哈希表，最后遍历哈希表，得到只出现一次的数字。但是时间复杂度以及空间复杂度都是 O(n)，貌似不符合题目的要求。查看答案，标准的解法是异或运算(压根没想到)。。。。。<span id="more"></span></p><p>首先，我们要了解什么是<strong>异或运算</strong>。</p><p>按位操作符的字面意思很好理解，即对值的二进制格式进行处理的操作符。而异或的作用为：假设有值甲、乙，当甲乙值相等时，异或操作后结果为不等（False，0），反之，为相等（True，1）。所以按位异或操作符的释义便显而易见了：对某值的每个位上的值（0或1）进行异或操作。</p><img src="/2022/06/15/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/Users\Congyingxu\AppData\Roaming\Typora\typora-user-images\image-20220615145352777.png" alt="image-20220615145352777" style="zoom:67%;"><p><strong>异或运算有以下三个性质。</strong></p><ol><li>任何数和 00 做异或运算，结果仍然是原来的数。<em>a</em>⊕0&#x3D;<em>a</em>。</li><li>任何数和其自身做异或运算，结果是 0。<em>a</em>⊕<em>a</em>&#x3D;0。</li><li>异或运算满足交换律和结合律。<em>a</em>⊕<em>b</em>⊕<em>a</em>&#x3D;<em>b</em>⊕<em>a</em>⊕<em>a</em>&#x3D;<em>b</em>⊕(<em>a</em>⊕<em>a</em>)&#x3D;<em>b</em>⊕0&#x3D;<em>b</em>。</li></ol><p>最后附上官方解题代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">single</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            single ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://congyx.com/categories/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <category domain="https://congyx.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      
      <comments>https://congyx.com/2022/06/15/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>String、StringBuffer、StringBuilder之间的联系</title>
      <link>https://congyx.com/2022/06/05/String%E3%80%81StringBuffer%E3%80%81StringBuilder%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB/</link>
      <guid>https://congyx.com/2022/06/05/String%E3%80%81StringBuffer%E3%80%81StringBuilder%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB/</guid>
      <pubDate>Sun, 05 Jun 2022 04:21:10 GMT</pubDate>
      
      <description>&lt;p&gt;今天做题遇见 &lt;strong&gt;反转字符串中的单词&lt;/strong&gt; 这道题，给定一个字符串需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。题目链接：&lt;a href=&quot;https://leetcode.cn/problems/reverse-words-in-a-string-iii/&quot;&gt;557. 反转字符串中的单词 III - 力扣（LeetCode）&lt;/a&gt;。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>今天做题遇见 <strong>反转字符串中的单词</strong> 这道题，给定一个字符串需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。题目链接：<a href="https://leetcode.cn/problems/reverse-words-in-a-string-iii/">557. 反转字符串中的单词 III - 力扣（LeetCode）</a>。<span id="more"></span></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;Let&#x27;s take LeetCode contest&quot;</span><br><span class="line">输出：&quot;s&#x27;teL ekat edoCteeL tsetnoc&quot;</span><br><span class="line"></span><br><span class="line">输入： s = &quot;God Ding&quot;</span><br><span class="line">输出：&quot;doG gniD&quot;</span><br></pre></td></tr></table></figure><p>做题过程中，发现自己忘记了字符串的一些知识，所谓温故而知新。在此记录复习。</p><p>在 java 中字符串属于对象，Java 提供了 String 类来创建和操作字符串。String 类是不可变类，即一旦一个 String 对象被创建以后，包含在这个对象中的字符序列是不可改变的，直至这个对象被销毁。</p><p>Java 提供了两个可变字符串类 <strong>StringBuffer</strong> 和 <strong>StringBuilder</strong>，中文翻译为“字符串缓冲区”。</p><p>StringBuilder 类是 JDK 1.5 新增的类，它也代表可变字符串对象。实际上，StringBuilder 和 StringBuffer 功能基本相似，方法也差不多。不同的是，StringBuffer 是线程安全的，而 StringBuilder 则没有实现线程安全功能，所以性能略高。因此在通常情况下，如果需要创建一个内容可变的字符串对象，则应该优先考虑使用 StringBuilder 类。</p><p>StringBuffer、StringBuilder、String 中都实现了 CharSequence 接口。CharSequence 是一个定义字符串操作的接口，它只包括 length()、charAt(int index)、subSequence(int start, int end) 这几个 API。</p><p>StringBuffer、StringBuilder、String 对 CharSequence 接口的实现过程不一样，</p><img src="/2022/06/05/String%E3%80%81StringBuffer%E3%80%81StringBuilder%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB/image-20220605122937245.png" alt="image-20220605122937245" style="zoom:80%;"><p><strong>String、StringBuffer、StringBuilder 之间的区别：</strong></p><img src="/2022/06/05/String%E3%80%81StringBuffer%E3%80%81StringBuilder%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB/image-20220605122516694.png" alt="image-20220605122516694" style="zoom:80%;"><p><strong>String:</strong></p><p>对于String来说，是把数据存放在了常量池中，因为所有的String，默认都是以常量形式保存，且由final修饰，因此在线程池中它是线程安全的。因为每一个String当被创建好了以后，他就不再发生任何变化，但是它的执行速度是最差的。</p><p>我们要创建String的时候，他在常量池中对这些信息进行处理，如果在程序中出现了大量字符串拼接的工作，效率是非常底下的。<br>因此使用场景是在少量字符串操作的时候才建议直接使用String来操作。</p><p><strong>StringBuffer:</strong></p><p>StringBuffer相对于StringBuilder效率要相对低一点，但也远比String要高的多。效率低的原因：对于StringBuffer来说更多的考虑到了多线程的情况，在进行字符串操作的时候，它使用了synchronize关键字，对方法进行了同步处理。因此StringBuffer适用于多线程环境下的大量操作。</p><p><strong>StringBuilder:</strong></p><p>线程安全与线程不安全：<br>在进行多线程处理的时候，如果多个线程对于这一个对象同时产生操作，会产生预期之外的结果。对于StringBuilder来说，执行效率虽然高，但是因为线程不安全，所以不建议在多线程的环境下对同一个StringBuilder对象进行操作。因此StringBuilder适用于单线程环境下的大量字符串操作。</p><p><strong>参考：</strong><a href="http://c.biancheng.net/view/5822.html">String、StringBuffer和StringBuilder类的区别 (biancheng.net)</a></p>]]></content:encoded>
      
      
      <category domain="https://congyx.com/categories/java/">java</category>
      
      
      <category domain="https://congyx.com/tags/java/">java</category>
      
      
      <comments>https://congyx.com/2022/06/05/String%E3%80%81StringBuffer%E3%80%81StringBuilder%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>二叉树的问题（二）</title>
      <link>https://congyx.com/2022/06/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89/</link>
      <guid>https://congyx.com/2022/06/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89/</guid>
      <pubDate>Wed, 01 Jun 2022 00:36:05 GMT</pubDate>
      
      <description>&lt;p&gt;整理完二叉树的前序、中序、后序、层次遍历之后，进一步学习，记录一下其他有关二叉树的知识。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>整理完二叉树的前序、中序、后序、层次遍历之后，进一步学习，记录一下其他有关二叉树的知识。<span id="more"></span></p><h3 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h3><p><strong>递归：</strong></p><p>二叉树的深度是指树的根节点到任一叶子节点路径上节点的数量，因此从根节点每次向下一层深度都会加1。所以二叉树的深度等于根节点这个1层加上左子树和右子树深度的最大值。同时，我们可以将每一个子树都看成一个根节点，继续用上述方法求深度，将问题划分为子问题，利用递归解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span> <span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left),maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)，其中n为二叉树的节点数，遍历整棵二叉树。</p><p>空间复杂度：O(n)，最坏情况下，二叉树化为链表，递归栈深度最大为n。</p><p><strong>层次遍历（队列）</strong></p><p>根据层次遍历来统计二叉树最大深度，有的层可能会有很多节点，有的层只有一个节点，无论有多少个节点，它们都是一层。所以采取层次遍历，只需统计层数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span> <span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> q.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> q.poll()</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)</span><br><span class="line">                    q.offer(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)</span><br><span class="line">                    q.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">             res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h3><p><strong>递归前序遍历：</strong></p><p>如果想将两棵二叉树合并起来，那么一定要遍历两颗二叉树，那我们可以考虑同步遍历两棵二叉树，这样就可以将每次遍历的值相加在一起。</p><ul><li>首先判断t1与t2是否为空，若为则用另一个代替，若都为空，返回的值也是空。</li><li>然后依据前序遍历的特点，优先访问根节点，将两个根点的值相加创建到新树中。</li><li>s两棵树再依次同步进入左子树和右子树。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span> <span class="params">(TreeNode t1, TreeNode t2)</span> &#123;</span><br><span class="line">        <span class="comment">//若只有一个节点返回另一个，两个都为null自然返回null</span></span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">null</span>) </span><br><span class="line">            <span class="keyword">return</span> t2;</span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> t1;</span><br><span class="line">        <span class="comment">//根左右的方式递归</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(t1.val + t2.val);</span><br><span class="line">        head.left = mergeTrees(t1.left, t2.left);</span><br><span class="line">        head.right = mergeTrees(t1.right, t2.right);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(min(n,m))，m和n分别为两棵树的节点树，当一个树访问完时，自然就连接上另一个树的节点，故只访问了小树的节点数。</li><li>空间复杂度：O(min(n,m))，递归栈深度也同时间，只访问了小树的节点数。</li></ul><p><strong>队列：</strong></p><p>使用队列辅助两个二叉树分别同时层次遍历。</p><ul><li>首先判断t1与t2是否为空，若为则用另一个代替，若都为空，返回的值也是空。</li><li>使用三个辅助队列，第一个队列q用于暂存合并后的二叉树的层次遍历节点，第二个队列q1用于暂存t1的层次遍历节点，第三个队列q2用于暂存t2的层次遍历节点。</li><li>两棵树同步层次遍历，先将根节点加入队列中，同时根节点优先合并。</li><li>每次从队列分别弹出一个元素，判断分别二者的左右子节点是否存在，若是都存在，则相加合并，若是只存在一个则连接该存在的节点，若是都不存在则连接null。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span> <span class="params">(TreeNode t1, TreeNode t2)</span> &#123;</span><br><span class="line">        <span class="comment">//若只有一个节点返回另一个，两个都为null自然返回null</span></span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> t2;</span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> t1;</span><br><span class="line">        <span class="comment">//合并根节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(t1.val + t2.val); </span><br><span class="line">        <span class="comment">//连接后的树的层次遍历节点</span></span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;(); </span><br><span class="line">        <span class="comment">//分别存两棵树的层次遍历节点</span></span><br><span class="line">        Queue&lt;TreeNode&gt; q1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;(); </span><br><span class="line">        Queue&lt;TreeNode&gt; q2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        q.offer(head);</span><br><span class="line">        q1.offer(t1);  </span><br><span class="line">        q2.offer(t2);</span><br><span class="line">        <span class="keyword">while</span> (!q1.isEmpty() &amp;&amp; !q2.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node1</span> <span class="operator">=</span> q1.poll(); </span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node2</span> <span class="operator">=</span> q2.poll();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">left1</span> <span class="operator">=</span> node1.left;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">left2</span> <span class="operator">=</span> node2.left;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">right1</span> <span class="operator">=</span> node1.right;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">right2</span> <span class="operator">=</span> node2.right;</span><br><span class="line">            <span class="keyword">if</span>(left1 != <span class="literal">null</span> || left2 != <span class="literal">null</span>)&#123; </span><br><span class="line">                <span class="comment">//两个左节点都存在</span></span><br><span class="line">                <span class="keyword">if</span>(left1 != <span class="literal">null</span> &amp;&amp; left2 != <span class="literal">null</span>)&#123; </span><br><span class="line">                    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(left1.val + left2.val);</span><br><span class="line">                    node.left = left; </span><br><span class="line">                    <span class="comment">//新节点入队列</span></span><br><span class="line">                    q.offer(left);  </span><br><span class="line">                    q1.offer(left1);</span><br><span class="line">                    q2.offer(left2);</span><br><span class="line">                <span class="comment">//只连接一个节点</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left1 != <span class="literal">null</span>) </span><br><span class="line">                    node.left = left1;</span><br><span class="line">                 <span class="keyword">else</span></span><br><span class="line">                    node.left = left2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(right1 != <span class="literal">null</span> || right2 != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//两个右节点都存在</span></span><br><span class="line">                <span class="keyword">if</span>(right1 != <span class="literal">null</span> &amp;&amp; right2 != <span class="literal">null</span>) &#123; </span><br><span class="line">                    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(right1.val + right2.val);</span><br><span class="line">                    node.right = right;</span><br><span class="line">                    <span class="comment">//新节点入队列</span></span><br><span class="line">                    q.offer(right); </span><br><span class="line">                    q1.offer(right1);</span><br><span class="line">                    q2.offer(right2);</span><br><span class="line">                <span class="comment">//只连接一个节点</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(right1 != <span class="literal">null</span>)  </span><br><span class="line">                    node.right = right1;</span><br><span class="line">                 <span class="keyword">else</span> </span><br><span class="line">                    node.right = right2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h3><p><strong>递归：</strong></p><p>检查从根节点到叶子节点有没有一条等于目标值的路径，肯定需要从根节点遍历到叶子，可以在根节点每次往下一层的时候，用sum减去节点值，最后检查是否完整等于0。遍历的方法可以选取二叉树常用的递归前序遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span> <span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="comment">//空节点找不到路径</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//叶子节点，且路径和为sum</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; sum - root.val == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//递归进入子节点</span></span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>栈、dfs</strong></p><p>遍历过程除了使用递归也可以使用栈辅助，进行dfs（深度优先搜索）遍历，检查往下的路径中是否有等于sum的路径和。</p><p>注意，这里仅是dfs，而不是前序遍历，左右节点的顺序没有关系，因为每次往下都是单独添加某个节点的值相加然后继续往下，因此左右节点谁先遍历不管用。</p><ul><li>首先检查空节点，空树没有路径。</li><li>使用两个栈同步遍历，一个栈记录节点，辅助深度优先搜索，另一个栈跟随记录到该节点为止的路径和。根节点及根节点值先进栈。</li><li>遍历的时候每次弹出两个栈中的内容，判断是否是叶子节点且路径和是否等于目标值。</li><li>没有到叶子节点就将左右子节点（如果有）加入栈中，并跟随加入路径和。</li><li>如果遍历结束也没有找到路径和，则该二叉树中没有。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span> <span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="comment">//空节点找不到路径</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//栈辅助深度优先遍历</span></span><br><span class="line">        Stack&lt;TreeNode&gt; s1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;TreeNode&gt;(); </span><br><span class="line">        <span class="comment">//跟随s1记录到相应节点为止的路径和</span></span><br><span class="line">        Stack&lt;Integer&gt; s2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;(); </span><br><span class="line">        s1.push(root);</span><br><span class="line">        s2.push(root.val);</span><br><span class="line">        <span class="keyword">while</span>(!s1.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//弹出相应节点</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> s1.pop(); </span><br><span class="line">            <span class="comment">//弹出到该点为止的当前路径和</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">cur_sum</span> <span class="operator">=</span> s2.pop(); </span><br><span class="line">            <span class="comment">//叶子节点且当前路径和等于sum</span></span><br><span class="line">            <span class="keyword">if</span>(temp.left == <span class="literal">null</span> &amp;&amp; temp.right == <span class="literal">null</span> &amp;&amp; cur_sum == sum)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//左节点及路径和入栈</span></span><br><span class="line">            <span class="keyword">if</span>(temp.left != <span class="literal">null</span>)&#123; </span><br><span class="line">                s1.push(temp.left);</span><br><span class="line">                s2.push(cur_sum + temp.left.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//右节点及路径和入栈</span></span><br><span class="line">            <span class="keyword">if</span>(temp.right != <span class="literal">null</span>)&#123; </span><br><span class="line">                s1.push(temp.right);</span><br><span class="line">                s2.push(cur_sum + temp.right.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)，其中n为二叉树所有节点，遍历二叉树所有节点。</li><li>空间复杂度：O(n)，最坏情况二叉树化为链表，递归栈空间最大为n。</li></ul><h3 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h3><p><strong>递归：</strong></p><p>将二叉树镜像，意味着每个左右子树都会交换位置，如果我们从上到下对遍历到的节点交换位置，但是它们后面的节点无法跟着他们一起被交换，因此我们可以考虑自底向上对每两个相对位置的节点交换位置，这样往上各个子树也会被交换位置。</p><p>自底向上的遍历方式，我们可以采用<strong>后序递归</strong>的方法。</p><ul><li>时间复杂度：O(n)，其中n为二叉树的节点数，访问二叉树所有节点各一次。</li><li>空间复杂度：O(n)，最坏情况下，二叉树退化为链表，递归栈最大值为n。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">Mirror</span> <span class="params">(TreeNode pRoot)</span> &#123;</span><br><span class="line">        <span class="comment">//空树返回</span></span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//先递归子树</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> Mirror(pRoot.left);  </span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> Mirror(pRoot.right);</span><br><span class="line">        <span class="comment">//交换</span></span><br><span class="line">        pRoot.left = right; </span><br><span class="line">        pRoot.right = left;</span><br><span class="line">        <span class="keyword">return</span> pRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>栈：</strong></p><p>栈的访问是一种自顶向下的访问，因此我们需要在左右子节点入栈后直接交换，然后再访问后续栈中内容。</p><ul><li>优先检查空树的情况。</li><li>使用栈辅助遍历二叉树，根节点先进栈。</li><li>遍历过程中每次弹出栈中一个元素，然后该节点左右节点分别入栈。</li><li>同时我们交换入栈两个子节点的值，因为子节点已经入栈了再交换，就不怕后续没有交换。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">Mirror</span> <span class="params">(TreeNode pRoot)</span> &#123;</span><br><span class="line">        <span class="comment">//空树</span></span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">null</span>)  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//辅助栈</span></span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;TreeNode&gt;(); </span><br><span class="line">        <span class="comment">//根节点先进栈</span></span><br><span class="line">        s.push(pRoot); </span><br><span class="line">        <span class="keyword">while</span> (!s.isEmpty())&#123; </span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> s.pop();</span><br><span class="line">            <span class="comment">//左右节点入栈</span></span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>) </span><br><span class="line">                s.push(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>) </span><br><span class="line">                s.push(node.right);</span><br><span class="line">            <span class="comment">//交换左右</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> node.left; </span><br><span class="line">            node.left = node.right;</span><br><span class="line">            node.right = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h3>]]></content:encoded>
      
      
      <category domain="https://congyx.com/categories/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <category domain="https://congyx.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      
      <comments>https://congyx.com/2022/06/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>二叉树的一些问题</title>
      <link>https://congyx.com/2022/05/27/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</link>
      <guid>https://congyx.com/2022/05/27/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</guid>
      <pubDate>Fri, 27 May 2022 14:44:57 GMT</pubDate>
      
      <description>&lt;p&gt;最近在刷二叉树的相关题目，通过这篇博客记录相关知识点，梳理一些做题的思路。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>最近在刷二叉树的相关题目，通过这篇博客记录相关知识点，梳理一些做题的思路。</p><span id="more"></span><h3 id="二叉树的前序遍历"><a href="#二叉树的前序遍历" class="headerlink" title="二叉树的前序遍历"></a>二叉树的前序遍历</h3><p>二叉树的前序遍历说白了就是 按照“<strong>根左右”</strong>的访问顺序来访问二叉树。首先访问二叉树的根节点，如果有左子树就访问它的左子树，依此类推，等所有左子树访问完毕再访问其右子树。</p><p><strong>递归</strong></p><p>二叉树的递归就是将每个节点的左子树、右子树看成一棵完整的树，那么对于子树的访问或者操作就是对于原树的访问或者操作的子问题。</p><p>时间复杂度：O(n)，其中n为二叉树的节点数，遍历二叉树所有节点。</p><p>空间复杂度：O(n)，最坏情况二叉树化为链表，递归栈深度为n。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> *   public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(List&lt;Integer&gt; list, TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(list,root.val);</span><br><span class="line">        preorder(list,root.left);</span><br><span class="line">        preorder(list,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] preorderTraversal(TreeNode root)&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        preorder(list,root);</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; list.size();i++)</span><br><span class="line">        res[i] = list.get(i);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>栈</strong></p><p>根据 <strong>“根左右”</strong> 的顺序，首先遍历根节点，其次遍历左子树，再遍历右子树。在栈中，如何实现这种操作呢？首先，定义新的数组用来存放节点的值，再将根节点入栈。我们要考虑如何优先访问左子节点，根据栈的先进后出原则可以先将右子节点入栈，然后下一轮访问左子节点，这样每次从栈中弹出一个元素进行访问，实现二叉树的前序遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> *   public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] preorderTraversal (TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">       List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;TreeNode&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        s.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!s.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> s.pop();</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>)</span><br><span class="line">                s.push(node.right);</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>)</span><br><span class="line">                s.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; list.size();i++)</span><br><span class="line">            res[i] = list.get(i);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的后序遍历"><a href="#二叉树的后序遍历" class="headerlink" title="二叉树的后序遍历"></a>二叉树的后序遍历</h3><p><strong>递归</strong></p><p>二叉树的后序遍历说白了就是 ”左右根“，展开来说就是先访问左子树，然后再访问右子树，最后访问根节点。</p><p>时间复杂度：O(n)，其中n为二叉树的节点数，遍历二叉树所有节点。</p><p>空间复杂度：O(n)，最坏情况下二叉树转换为链表，递归栈深度为n</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> *   public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postorder</span><span class="params">(List&lt;Integer&gt; list,TreeNode root)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">        postorder(list,root.left);</span><br><span class="line">        postorder(list,root.right);</span><br><span class="line">        list.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] postorderTraversal (TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        postorder(list,root);</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; list.size();i++)&#123;</span><br><span class="line">            res[i] = list.get(i);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>栈：</strong></p><p>二叉树的前序和中序遍历都可以使用栈来替代递归，同样二叉树的后序遍历同样可以。</p><p>我们根据 ”左右中“ 的顺序，首先要找到每棵子树的最左端节点，如果它还有一个右节点，根据 “左右根” 的遍历原则，我们还要访问右子树。之后该如何访问根节点呢？</p><p>当从栈中弹出根节点，那么一定是左节点已经被访问过了，同时还要保证右节点也已经被访问过了。如果右子树为空，则无需访问，如果右子树不为空，优先进入右子树，此时再将根节点加入栈中。</p><p>当右节点被访问了，又回到了根，我们如何知道右节点被访问呢？用一个前序指针 pre 标记一下，当要回到上一个根节点时，检查一下，如果 pre 确实是它的右子节点，那刚刚已经访问过了，可以访问根节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> *   public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> *   public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] postorderTraversal (TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;TreeNode&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span> || !s.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            s.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> s.pop();</span><br><span class="line">        <span class="keyword">if</span>(node.right == <span class="literal">null</span> || node.right == pre)&#123;</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            pre = node;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            s.push(node);</span><br><span class="line">            root = node.right;</span><br><span class="line">         &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; list.size();i++)</span><br><span class="line">            res[i] = list.get(i);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)，其中n为二叉树的节点数，遍历二叉树所有节点。</p><p>空间复杂度：O(n)，辅助栈空间最大为链表所有节点数。</p><h3 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h3><p><strong>递归</strong></p><p>二叉树的中序遍历，就是根据 “左根右” 的顺序来访问二叉树的节点。我们优先访问它的左子树，等左子树全部节点都访问完毕，再访问根节点，最后访问右子树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> *   public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">       </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(List&lt;Integer&gt; list,TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(list,root.left);</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        inorder(list,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] inorderTraversal (TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        inorder(list,root);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; list.size();i++)</span><br><span class="line">            res[i] = list.get(i);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>栈</strong></p><p>二叉树的中序遍历与前序遍历相似，我们利用栈来代替递归。从根节点开始不断向左访问，第一个访问的叶子节点一定是最左面的节点。然后访问该节点的右子树，最后向上回到父问题。</p><p>时间复杂度：O(n)，其中n为二叉树的节点数，遍历二叉树所有节点。</p><p>空间复杂度：O(n)，辅助栈空间最大为链表所有节点数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> *   public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] inorderTraversal (TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;TreeNode&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span> || !s.isEmpty())&#123;</span><br><span class="line"><span class="keyword">while</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">                s.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> s.pop();</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            root = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; list.size();i++)</span><br><span class="line">            res[i] = list.get(i);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h3><p><strong>递归：</strong></p><p>按行遍历的关键是每一行的深度对应了它输出在二维数组中的深度，即深度可以与二维数组的下标对应，那我们可以在递归的访问每个节点的时候记录深度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root,<span class="type">int</span> depth)</span></span><br></pre></td></tr></table></figure><p>进入子节点时，深度加1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">traverse(root.left,depth + <span class="number">1</span>);</span><br><span class="line">traverse(root.right,depth + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>每个节点值放入二维数组相应行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res[depth - <span class="number">1</span>].push_back(root-&gt;val);</span><br></pre></td></tr></table></figure><ul><li>首先，判断二叉树是否为空，空树则没有遍历结果</li><li>递归进行层次遍历输出，每次递归记录当前二叉树的深度，每当遍历到一个节点，如果为空直接返回</li><li>如果遍历的节点不为空，输出二维数组中一维数组的个数（即代表了输出的行数）小于深度，说明这个节点应该是新的一层，我们在二维数组中增加一个一维数组，然后再加入二叉树元素。</li><li>如果不是第三种情况说明这个深度我们已经有了数组，直接根据深度作为下标取出数组，将元素加在最后就可以了。</li><li>处理完这个节点，再依次递归进入左右节点，同时深度增加。因为我们进入递归的时候是先左后右，那么遍历的时候也是先左后右，正好是层次遍历的顺序。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型ArrayList&lt;ArrayList&lt;&gt;&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root,<span class="type">int</span> depth)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res.size() &lt; depth)&#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; row = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">                res.add(row);</span><br><span class="line">                row.add(root.val);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; row = res.get(depth - <span class="number">1</span>);</span><br><span class="line">                row.add(root.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        traverse(root.left,depth + <span class="number">1</span>);</span><br><span class="line">        traverse(root.right,depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span> <span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        traverse(root, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>队列</strong></p><ul><li>首先判断二叉树是否为空，空树没有遍历结果。</li><li>建立辅助队列，根节点首先进入队列。不管层次怎么访问，根节点一定是第一个，那它肯定排在队伍的最前面。</li><li>每次进入一层，统计队列中元素的个数。因为每当访问完一层，下一层作为这一层的子节点，一定都加入队列，而再下一层还没有加入，因此此时队列中的元素个数就是这一层的元素个数。</li><li>每次遍历这一层这么多的节点数，将其依次从队列中弹出，然后加入这一行的一维数组中，如果它们有子节点，依次加入队列排队等待访问。</li><li>访问完这一层的元素后，将这个一维数组加入二维数组中，再访问下一层。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型ArrayList&lt;ArrayList&lt;&gt;&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span> <span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;TreeNode&gt;();</span><br><span class="line">        q.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">ArrayList&lt;Integer&gt; row = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> q.size();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                row.add(cur.val);</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="literal">null</span>)</span><br><span class="line">                    q.add(cur.left);</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="literal">null</span>)</span><br><span class="line">                    q.add(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(row);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://congyx.com/categories/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <category domain="https://congyx.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      
      <comments>https://congyx.com/2022/05/27/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>java基础复习</title>
      <link>https://congyx.com/2022/05/24/java%E5%9F%BA%E7%A1%80/</link>
      <guid>https://congyx.com/2022/05/24/java%E5%9F%BA%E7%A1%80/</guid>
      <pubDate>Tue, 24 May 2022 09:55:53 GMT</pubDate>
      
      <description>&lt;p&gt;今天在刷牛客的时候，发现自己对一些数据结构的基础知识并不是很清晰。所以在这里做个笔记整理一下。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>今天在刷牛客的时候，发现自己对一些数据结构的基础知识并不是很清晰。所以在这里做个笔记整理一下。<span id="more"></span></p><p>List、LinkedList、ArrayList:</p><p>List:是一个<strong>有序</strong>的集合，可以包含重复的元素。提供了按索引访问的方式。继承Collection。</p><p>List有两个重要的实现类：ArrayList 和 LinkedList，那么 <strong>ArrayList 和 LinkedList 有什么区别呢？</strong></p><p>ArrayList：我们可以将其看作是<strong>能够自动增长容量的数组</strong>。可以利用 ArrayList 的 toArray() 返回一个数组。</p><p>同时，ArrayList采用数组实现的，查找效率一定会比 LinkedList 高。而 LinkedList 采用双向链表实现的，插入和删除的效率会比 ArrayList 高。如果要是在 list 的尾部添加元素，肯定是LinkedList效率高。</p><p>我们再展开一个问题 <strong>ArrayList 和 HashSet 区别：</strong></p><p>首先，ArrayList 底层是动态数组，可以存储重复的值，并且如果不约定下标的话，是有序的。而 hashset 底层是 hash 表，是不可重复并且是无序的。</p><p>Queue</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Queue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">//往队列插入元素，如果出现异常会抛出异常</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line">    <span class="comment">//往队列插入元素，如果出现异常则返回false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span>;</span><br><span class="line">    <span class="comment">//移除队列元素，如果出现异常会抛出异常</span></span><br><span class="line">    E <span class="title function_">remove</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//移除队列元素，如果出现异常则返回null</span></span><br><span class="line">    E <span class="title function_">poll</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//获取队列头部元素，如果出现异常会抛出异常</span></span><br><span class="line">    E <span class="title function_">element</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//获取队列头部元素，如果出现异常则返回null</span></span><br><span class="line">    E <span class="title function_">peek</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Deque 双端队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Deque</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Queue</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span>;<span class="comment">//插入头部，异常会报错</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offerFirst</span><span class="params">(E e)</span>;<span class="comment">//插入头部，异常返回false</span></span><br><span class="line">    E <span class="title function_">getFirst</span><span class="params">()</span>;<span class="comment">//获取头部，异常会报错</span></span><br><span class="line">    E <span class="title function_">peekFirst</span><span class="params">()</span>;<span class="comment">//获取头部，异常不报错</span></span><br><span class="line">    E <span class="title function_">removeFirst</span><span class="params">()</span>;<span class="comment">//移除头部，异常会报错</span></span><br><span class="line">    E <span class="title function_">pollFirst</span><span class="params">()</span>;<span class="comment">//移除头部，异常不报错</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span>;<span class="comment">//插入尾部，异常会报错</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offerLast</span><span class="params">(E e)</span>;<span class="comment">//插入尾部，异常返回false</span></span><br><span class="line">    E <span class="title function_">getLast</span><span class="params">()</span>;<span class="comment">//获取尾部，异常会报错</span></span><br><span class="line">    E <span class="title function_">peekLast</span><span class="params">()</span>;<span class="comment">//获取尾部，异常不报错</span></span><br><span class="line">    E <span class="title function_">removeLast</span><span class="params">()</span>;<span class="comment">//移除尾部，异常会报错</span></span><br><span class="line">    E <span class="title function_">pollLast</span><span class="params">()</span>;<span class="comment">//移除尾部，异常不报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayDeque</p><ul><li>实现于Deque，拥有队列或者栈特性的接口</li><li>实现于Cloneable，拥有克隆对象的特性</li><li>实现于Serializable，拥有序列化的能力</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组存储元素</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elements;</span><br><span class="line"><span class="comment">//头部元素索引</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> head;</span><br><span class="line"><span class="comment">//尾部元素索引</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> tail;</span><br><span class="line"><span class="comment">//最小容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">8</span>;</span><br></pre></td></tr></table></figure><p>ArrayDeque底层使用数组存储元素，同时还使用head和tail来表示索引，但注意tail不是尾部元素的索引，而是尾部元素的下一位，即下一个将要被加入的元素的索引。</p><p>ArrayDeque 是 Deque 接口的一种具体实现，是依赖于可变数组来实现的。ArrayDeque 没有容量限制，可根据需求自动进行扩容。ArrayDeque 可以作为栈来使用，效率要高于Stack；ArrayDeque 也可以作为队列来使用，效率相较于基于双向链表的LinkedList也要更好一些。</p>]]></content:encoded>
      
      
      <category domain="https://congyx.com/categories/java/">java</category>
      
      
      <category domain="https://congyx.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      
      <comments>https://congyx.com/2022/05/24/java%E5%9F%BA%E7%A1%80/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>合并k个已排序的链表</title>
      <link>https://congyx.com/2022/05/22/%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%B7%B2%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</link>
      <guid>https://congyx.com/2022/05/22/%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%B7%B2%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</guid>
      <pubDate>Sun, 22 May 2022 04:16:31 GMT</pubDate>
      
      <description>&lt;p&gt;今天刷题遇到了&lt;strong&gt;合并K个已排序的链表&lt;/strong&gt;这道题，记录，复习一下相关知识点。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>今天刷题遇到了<strong>合并K个已排序的链表</strong>这道题，记录，复习一下相关知识点。<span id="more"></span></p><p>题目描述为：</p><img src="/2022/05/22/%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%B7%B2%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/image-20220522131948214.png" alt="image-20220522131948214" style="zoom:80%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例</span><br><span class="line">输入：[&#123;1,2,3&#125;,&#123;4,5,6,7&#125;]</span><br><span class="line">返回值：&#123;1,2,3,4,5,6,7&#125;</span><br><span class="line"></span><br><span class="line">输入：[&#123;1,2&#125;,&#123;1,4,5&#125;,&#123;6&#125;]</span><br><span class="line">返回值：&#123;1,1,2,4,5,6&#125;</span><br></pre></td></tr></table></figure><p><strong>思路：</strong></p><ol><li><p>用朴素方式，遍历合并。</p><p>使用【合并两个有序链表】中的方法，合并前两个链表，将下一个链表与当前结果合并，遍历列表中的每个链表，一直循环下去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ArrayList&lt;ListNode&gt; lists)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> lists.size();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> lists.get(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> lists.get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">            node = mergeTwoList(lists.get(i),node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoList</span><span class="params">(ListNode node1,ListNode node2)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> node;</span><br><span class="line">        <span class="keyword">while</span>(node1!=<span class="literal">null</span> &amp;&amp; node2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node1.val &lt; node2.val)&#123;</span><br><span class="line">                tmp.next = node1;</span><br><span class="line">                node1 = node1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tmp.next = node2;</span><br><span class="line">                node2 = node2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.next = node1!=<span class="literal">null</span>?node1:node2;</span><br><span class="line">        <span class="keyword">return</span> node.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法时间复杂度为O(k²n)，提交结果显示运行超时，通过率90.91%。</p><img src="/2022/05/22/%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%B7%B2%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/image-20220522124304088.png" alt="image-20220522124304088" style="zoom: 80%;"></li><li><p>分治算法。</p><ul><li><p>将待排序元素分成大小大致相同的两个子序列</p></li><li><p>对两个子序列进行合并排序</p></li><li><p>将排好序的有序子序列进行合并，得到最终的有序序列。</p><img src="/2022/05/22/%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%B7%B2%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2hlbmdxaXVtaW5n,size_18,color_FFFFFF,t_70,g_se,x_16.png" alt="img" style="zoom:80%;"><p>参考：<a href="https://blog.csdn.net/chengqiuming/article/details/123146537?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1-123146537-blog-118992123.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1-123146537-blog-118992123.pc_relevant_default&utm_relevant_index=1"> 分治算法的经典案例——合并排序_chengqiuming的博客-CSDN博客_合并排序</a></p><p>首先将待排序序列分成大小大致相同的两个子序列，然后再把子序列继续分成大小大致相同的两个子序列，一直递归下去，直到分解成只剩一个元素；然后执行合并操作。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ArrayList&lt;ListNode&gt; lists)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> merge(lists,<span class="number">0</span>,lists.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">merge</span><span class="params">(ArrayList&lt;ListNode&gt; lists,<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r)</span><br><span class="line">            <span class="keyword">return</span> lists.get(l);</span><br><span class="line">        <span class="keyword">if</span>(l &gt; r)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r-l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> mergeTwoList(merge(lists,l,mid),merge(lists,mid+<span class="number">1</span>,r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//合并两个有序链表</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoList</span><span class="params">(ListNode node1,ListNode node2)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> node;</span><br><span class="line">        <span class="keyword">while</span>(node1!=<span class="literal">null</span> &amp;&amp; node2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node1.val &lt;= node2.val)&#123;</span><br><span class="line">                tmp.next = node1;</span><br><span class="line">                node1 = node1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tmp.next = node2;</span><br><span class="line">                node2 = node2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.next = node1!=<span class="literal">null</span>?node1:node2;</span><br><span class="line">        <span class="keyword">return</span> node.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>第一轮合并了 k&#x2F;2 组链表，每一组的时间代价是O(2n)；第二轮合并了 4&#x2F;k 组链表，每一组的时间代价是O(4n)………………时间复杂度为O(kn x log K)</p><p>空间复杂度：递归会使用到O(log k)空间代价的栈空间。</p></li><li><p>优先队列，小根堆。</p></li></ol><p>​        首先，了解<strong>优先级队列</strong>的概念(PriorityQueue)。</p><p>​        <strong>队列</strong>是一种先进先出（FIFO）的数据结构，一些情况下，操作的数据会有优先级，一般出队列时，要求优先级高的元素先进性操作，这种情况使用队列就        行不通了。在这种情况下，数据结构提供两个最基本的操作，一个是返回最高优先级对象，一个是添加新对象，这种数据结构就是优先级队列(PriorityQueue)</p><p>​        PriorityQueue的底层是<strong>堆</strong>，堆的底层是数组。</p><p>​        Java集合框架中提供了<strong>PriorityQueue</strong>和<strong>PriorityBlockingQueue</strong>两种类型的优先级队列，PriorityQueue是<strong>线程不安全</strong>的，PriorityBlockingQueue是<strong>线程安全</strong>的，这里主要使用PriorityQueue。</p><ul><li>导入PriorityQueue所在的包</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue</span><br></pre></td></tr></table></figure><ol><li>PriorityQueue中放置的元素必须要能够比较大小 （只有实现了 Comparable 和 Comparator 接口的类才能比较大小），不能插入无法比较大小的对象，否则会抛出 ClassCastException 异常</li><li>不能插入 null 对象，否则会抛出 NullPointerException 异常</li><li>没有容量限制，可以插入任意多个元素，其内部可以自动扩容</li><li>插入和删除元素的时间复杂度均为 O(log2N)</li><li>PriorityQueue底层使用了堆数据结构</li></ol><p>这道题使用优先队列构建一个小顶堆，每次堆顶为值最小的节点，按顺序取出，然后将下一个节点放回去，重复此过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ArrayList&lt;ListNode&gt; lists)</span> &#123;</span><br><span class="line">        <span class="comment">//小根堆</span></span><br><span class="line">        Queue&lt;ListNode&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((v1,v2) -&gt; v1.val - v2.val);</span><br><span class="line">        <span class="comment">//将全部的节点放进去</span></span><br><span class="line">        <span class="keyword">for</span>(ListNode node:lists)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">                pq.offer(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//队首为值最小的节点</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">minNode</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">            tail.next = minNode;</span><br><span class="line">            tail = minNode;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(minNode.next != <span class="literal">null</span>)&#123;</span><br><span class="line">                pq.offer(minNode.next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://congyx.com/categories/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <category domain="https://congyx.com/tags/%E7%AE%97%E6%B3%95%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">算法、数据结构</category>
      
      
      <comments>https://congyx.com/2022/05/22/%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%B7%B2%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Matplotlib数据可视化</title>
      <link>https://congyx.com/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/</link>
      <guid>https://congyx.com/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/</guid>
      <pubDate>Fri, 15 Apr 2022 01:26:05 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;Matplotlib数据可视化&quot;&gt;&lt;a href=&quot;#Matplotlib数据可视化&quot; class=&quot;headerlink&quot; title=&quot;Matplotlib数据可视化&quot;&gt;&lt;/a&gt;Matplotlib数据可视化&lt;/h1&gt;&lt;p&gt;Python语言的matplotlib扩展包是一个提供了跨平台的2D 图形库，它可以将数据用多种形式展示出来。Matplotlib可画出折线图，柱状图，饼图，雷达图等。在matplotlib的官网上给出了500多个图表展示的例子程序 (&lt;a href=&quot;https://matplotlib.org/gallery/index.html)%E3%80%82&quot;&gt;https://matplotlib.org/gallery/index.html)。&lt;/a&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="Matplotlib数据可视化"><a href="#Matplotlib数据可视化" class="headerlink" title="Matplotlib数据可视化"></a>Matplotlib数据可视化</h1><p>Python语言的matplotlib扩展包是一个提供了跨平台的2D 图形库，它可以将数据用多种形式展示出来。Matplotlib可画出折线图，柱状图，饼图，雷达图等。在matplotlib的官网上给出了500多个图表展示的例子程序 (<a href="https://matplotlib.org/gallery/index.html)%E3%80%82">https://matplotlib.org/gallery/index.html)。</a><span id="more"></span></p><p>Matplotlib提供了两种编程风格，一种是函数式绘图，这种方式参考了matlab里面的绘图函数语法。另一种是面向对象式绘图，这种方式更接近Matplotlib的底层架构，更能理 解细节。matplotlib.pyplot是一个函数式绘图的函数集合， 其中每一个pyplot的函数都对图进行一些改动，例如创建图， 画点或线，以及增加标签等。在面向对象方式中， matplotlib.axes.Axes和matplotlib.figure.Figure是最主要的两 个对象，分别表示坐标轴和图。这种模式下，通常使用 pyplot.subplots创建一个图和多个坐标轴，并在此基础上调用相关对象的方法绘制图。</p><p>Matplotlib模块依赖于NumPy和tkinter模块，可以绘制多 种形式的图形，包括线图、直方图、饼图、散点图等，图形质量满足出版要求，是数据可视化的重要工具。Matplotlib 中应用最广的是matplotlib.pyplot模块。Pyplot提供了一套和 Matlab类似的绘图API，使得Matplotlib的机制更像Matlab。 我们只需要调用Pyplot模块所提供的函数就可以实现快速绘图并设置图表的各个细节。</p><img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503093033761.png" alt="image-20220503093033761" style="zoom:67%;"><p><strong>标题：</strong>plt.title()</p><p><strong>轴标签：</strong>plt.xlable(); plt.ylabel()</p><p><strong>轴刻度标签：</strong>plt.xticks(); plt.yticks()</p><p><strong>显示图像：</strong>plt.show()</p><p><strong>显示图例：</strong>plt.legend()</p><p><strong>数值标签：</strong>plt.text()</p><p><strong>轴刻度范围：</strong>plt.xlim(); plt.ylim()</p><p><strong>以一个简单的正弦函数为例说明图表的绘制方法。</strong></p><p>程序首先准备了x，y两个数组，x是0~720度，y是对应的 正弦函数值。使用axis函数设定x，y坐标轴的起止范围， plot函数画出正弦曲线，xticks指定x轴的小刻度标示。xlabel 和ylabel分别是x，y轴的主题，title设置了图表的主题。</p><img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503093443680.png" alt="image-20220503093443680" style="zoom: 67%;"><p>figure（）：创建一个新的绘图窗口。  </p><p>figtext（）：为figure添加文字  </p><p>axes（）：为当前figure添加一个坐标轴 </p><p>plot（）：绘图函数  </p><p>polar（）：绘制极坐标图  </p><p>axis（）：获取或设置轴属性的边界方法（坐标的取值 范围） </p><p>clf ： 清除当前figure窗口  </p><p>cla ： 清除当前axes窗口  </p><p>close ： 关闭当前figure窗口  </p><p>subplot ： 一个图中包含多个axes </p><p>text（）： 在轴上添加文字</p><p>title（）： 设置当前axes标题  </p><p>xlabel&#x2F;ylabel：设置当前X轴或Y轴的标签  </p><p>hist（）：绘制直方图  </p><p>hist2d（）：绘制二维直方图  </p><p>hold ：设置当前图窗状态；</p><p>off或者on  imread（）：读取一个图像，从图形文件中提取数组 </p><p>legend（）：为当前axes放置标签  </p><p>pie（）：绘制饼状图 </p><p>scatter（）：做一个X和Y的散点图，其中X和Y是相同长 度的序列对象  </p><p>stackplot（）：绘制一个堆叠面积图 </p><p>acorr（）：绘制X的自相关函数  </p><p>annotate（）：用箭头在指定的数据点创建一个注释或 一段文本 </p><p>bar（）：绘制垂直条形图  </p><p>barh（）：绘制横向条形图  </p><p>barbs（）：绘制一个倒钩的二维场 </p><h2 id="图表类型："><a href="#图表类型：" class="headerlink" title="图表类型："></a>图表类型：</h2><h3 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pie</span>(<span class="params">x, explode=<span class="literal">None</span>, labels=<span class="literal">None</span>, colors=<span class="literal">None</span>, autopct=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params"> pctdistance=<span class="number">0.6</span>, shadow=<span class="literal">False</span>, labeldistance=<span class="number">1.1</span>, startangle=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params"> radius=<span class="literal">None</span>, counterclock=<span class="literal">True</span>, wedgeprops=<span class="literal">None</span>, textprops=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params"> center=(<span class="params"><span class="number">0</span>, <span class="number">0</span></span>), frame=<span class="literal">False</span>, hold=<span class="literal">None</span>, data=<span class="literal">None</span></span>): </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>x：</strong>(每一块)的比例，如果sum(x) &gt; 1会使用sum(x)归一化；</p><p><strong>labels：</strong>(每一块)饼图外侧显示的说明文字；</p><p><strong>explode：</strong>(每一块)离开中心距离；</p><p><strong>startangle：</strong>起始绘制角度,默认图是从x轴正方向逆时针画起,如设定&#x3D;90 则从y轴正方向画起；</p><p><strong>shadow：</strong>在饼图下面画一个阴影。默认值：False，即不画阴影；</p><p><strong>labeldistance：</strong>label标记的绘制位置,相对于半径的比例，默认值为1.1, 如&lt;1则绘制在饼图内侧；</p><p><strong>autopct：</strong>控制饼图内百分比设置,可以使用format字符串或者 formatfunction </p><p>**’%1.1f’**指小数点前后位数(没有用空格补齐)；</p><p><strong>pctdistance：</strong>类似于labeldistance,指定autopct的位置刻度,默认值为0.6；</p><p><strong>radius：</strong>控制饼图半径，默认值为1；</p><p><strong>counterclock：</strong>指定指针方向；布尔值，可选参数，默认为：True， 即逆时针。将值改为False即可改为顺时针。</p><p><strong>wedgeprops：</strong>字典类型，可选参数，默认值：None。参数字典传递给wedge对象用来画一个饼图。例如：wedgeprops&#x3D;{‘linewidth’:3}设置wedge线宽为3。</p><p><strong>textprops：</strong>设置标签（labels）和比例文字的格式；字典类型，可 选参数，默认值为：None。传递给text对象的字典参数。</p><p><strong>center：</strong>浮点类型的列表，可选参数，默认值：(0,0)，图标中心位置。 </p><p><strong>frame：</strong>布尔类型，可选参数，默认值：False。如果是true，绘制带有表的轴框架。</p><p><strong>rotatelabels：</strong>布尔类型，可选参数，默认为：False。如果为True， 旋转每个label到指定的角度。 </p><img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503130121640.png" alt="image-20220503130121640" style="zoom:67%;"><h3 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hist</span>(<span class="params">x,bins=<span class="literal">None</span>,<span class="built_in">range</span>=<span class="literal">None</span>,normed=<span class="literal">False</span>,weights=<span class="literal">None</span>,cumulative=<span class="literal">False</span>,bottom=<span class="literal">None</span>, histtype=<span class="string">&#x27;bar&#x27;</span>, align=<span class="string">&#x27;mid&#x27;</span>, orientation=<span class="string">&#x27;vertical&#x27;</span>,rwidth=<span class="literal">None</span>, log=<span class="literal">False</span>, color=<span class="literal">None</span>, label=<span class="literal">None</span>, stacked=<span class="literal">False</span>,hold=<span class="literal">None</span>, data=<span class="literal">None</span>, **kwargs</span>):</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>x：</strong>数据集，最终的直方图将对数据集进行统计；</p><p><strong>bins：</strong>指定直方图条形的个数； </p><p><strong>range：</strong>显示的区间； </p><p><strong>normed：</strong>标准化，是否将直方图的频数转换成频率；</p><p><strong>density：</strong>显示的是频数统计结果，默认为false，为True则显示频 率统计结果，这里需要注意，频率统计结果&#x3D;区间数目&#x2F;(总数*区间宽 度)，和normed效果一致，官方推荐使用density；</p><p><strong>histtype:</strong> 指定直方图的类型，可选{‘bar’, ‘barstacked’,  ‘step’, ‘stepfilled’}之一，默认为bar，推荐使用默认配置，step使用的是梯状，stepfilled则会对梯状内部进行填充，效果与bar类似； </p><p><strong>align:</strong> 设置条形边界值的对其方式，可选{‘left’, ‘mid’,  ‘right’}之一，默认为’mid’，还有 left或者right，会有部分空白区域，推荐使用默认；</p><p><strong>orientation：</strong>水平或垂直方向[‘horizontal’,’vertical’]，默认为垂直方向；</p><p><strong>rwidth：</strong>柱子与柱子之间的距离，默认是0；</p><p><strong>log：</strong>是否需要对绘图数据进行log变换，默认False；</p><p><strong>stacked：</strong>当有多个数据时，是否需要将直方图呈堆叠摆放，默认水平摆放。 </p><p><strong>color：</strong>设置直方图颜色；</p><p><strong>label：</strong>设置直方图的标签，可通过legend展示其图例；</p><p><strong>bottom：</strong>可以为直方图的每个条形添加基准线，默认为0。</p><p>hist函数主要输入一个序列，并指定分为几个区间进行统计。按照 在每个区间内的数据数量绘制图形，展示不同区间的数据数量。</p><img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503130612192.png" alt="image-20220503130612192" style="zoom:67%;"><h3 id="面积图"><a href="#面积图" class="headerlink" title="面积图"></a>面积图</h3><p>面积图可用于绘制随时间发生的变化量，用于引起人们对总值趋势的关注。 通过显示所绘制的值的总和，面积图还可以显示部分与整体的关系。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">stackplot</span>(<span class="params">x, *args, **kwargs</span>):</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>x：</strong>指定面积图的x轴数据；</p><p>*args：可变参数，可以接受任意多的y轴数据，即各个拆分的数据对象；</p><p>**kargs：关键字参数，可以通过传递其他参数来修饰面积图， 如标签、颜色，用法与之前的labels、colors用法一致。</p><img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503131024940.png" alt="image-20220503131024940" style="zoom:67%;"><h3 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h3><p>散点图由一些不连续的点组成，用来研究两个变量的相关性。包括正相关、负相关、不相关。主要通过scatter函数画散点图。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">scatter</span>(<span class="params">x, y, s=<span class="literal">None</span>, c=<span class="literal">None</span>, marker=<span class="literal">None</span>, cmap=<span class="literal">None</span>, norm=<span class="literal">None</span>, </span></span><br><span class="line"><span class="params">vmin=<span class="literal">None</span>, vmax=<span class="literal">None</span>, alpha=<span class="literal">None</span>, linewidths=<span class="literal">None</span>, verts=<span class="literal">None</span>, </span></span><br><span class="line"><span class="params">edgecolors=<span class="literal">None</span>, hold=<span class="literal">None</span>, data=<span class="literal">None</span>, **kwargs</span>):</span><br><span class="line">    </span><br><span class="line"><span class="comment"># x/y：数据，都是向量，而且必须长度相等。</span></span><br><span class="line"><span class="comment"># s：标记大小;以像素点的平方为单位的标记面积，指定为下列形式之一：数值标量：以相同的大小绘制所有标记。行或列向量：使每个标记具有不同的大小。x、y 和 sz向量中的 相应元素确定每个标记的位置和面积。sz向量的长度必须等于 x 和 y 的长度。默认大小为rcParams[&#x27;lines.markersize&#x27;] ** 2。</span></span><br><span class="line"><span class="comment"># c:标记颜色;RGB三元数或颜色名称 - 使用相同的颜色绘制所有标记。由RGB三元数组成的三列矩阵 - 对每个标记使用不同的颜色。矩阵的每行为对应标记指定一种RGB三元数颜色。行数必须等于 x 和 y 的长度;向量 - 对每个标记使用不同的颜色，并以线性方式将 c 中的值映射到当前颜色图中的颜色。c 的长度必须等于 x 和 y 的长度。 要更改坐标区的颜色图，需使用 colormap 函数。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503094758601.png" alt="image-20220503094758601" style="zoom:67%;"><p><strong>edgecolors：</strong>轮廓颜色和 c 类似，参数也相同 </p><p><strong>alpha：</strong>透明度 [0,1]：1不透明，0透明 </p><p><strong>cmap：</strong>色彩盘 可以使用默认的也可以使用自定义的，它实际上就是一个三列的矩阵(或者说，shape为 [N, 3]的 array ) </p><p>• 矩阵中的值取值范围为 [0. , 1.] </p><p>• 每一行代表一个颜色 (RGB) </p><p><strong>linewidths：</strong>线宽标记边缘的宽度，默认是没有外围轮廓线。 </p><p>注意事项： color、marker等不能同时作为一个参数，plt.scatter(x1, y1, ‘bo’, s&#x3D;5) 不合法。</p><p>例：</p><p>现在有一组女大学生的身高和体重数据，可以画散点图来观察两组数据之间的关系。</p><img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503101252240.png" alt="image-20220503101252240" style="zoom:67%;"><p>展示正相关，负相关，不相关:</p><img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503101325862.png" alt="image-20220503101325862" style="zoom:67%;"><img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503101341999.png" alt="image-20220503101341999" style="zoom:67%;"><h3 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h3><p>折线图常用于显示数据序列随时间变化，数据变化的趋势。非常适用于显示在相等时间间隔下数据的走向变化。主要通过plot函数来画折线图。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">plot</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line"><span class="comment"># 其中参数args是一个可变长度参数，允许多个x，y对和一个可选的格式字符串。</span></span><br><span class="line"><span class="comment"># plot(x, y) plot x和y使用默认线条样式和颜色;plot(x, y, &#x27;bo&#x27;) plot x和y使用蓝色圆圈标记;plot(y) plot y使用x作为索引数组0..N-1;plot(y, &#x27;r+&#x27;) 同上，但是用红色加号</span></span><br></pre></td></tr></table></figure><p>1.针对线条的处理</p><ul><li>线条类型</li></ul><p>​    参数：linestyle或者ls，表示折线的类型，可以是实线、虚线、点虚线、点点线等，即’-‘, ‘–’, ‘-.’, ‘:’等。</p><ul><li>线条粗细</li></ul><p>​    参数：linewidth或lw，可自行设置，默认值为1； </p><ul><li>线条颜色</li></ul><p>​    参数：color或c ，设置方法和散点图中设置颜色方法一致。</p><p>2.针对数据标记的处理</p><ul><li>参数marker：数据标记的类型</li><li>参数markeredgecolor 或 mec：数据标记的边界颜色</li><li>参数markeredgewidth 或 mew：数据标记的宽度</li><li>参数markerfacecolor 或 mfc：数据标记的填充色 </li><li>alpha：接收值为0~1之间的小数，表示点的透明度；</li></ul><p>3.图例</p><p>​    label：表示数据图例内容。参数中label&#x3D;‘数据序列名称’ 指定该数据序列的名称，其后通过调用legend()函数可显示不同数据序列的图例。 </p><p><strong>下面以1万元分别存入活期，1年定期，3年定期后， 在30年中的价值变化。2019年的活期，1年定期，3 年定期的利率分别是0.35%，1.50%和2.75%。</strong></p><img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503105939185.png" alt="image-20220503105939185" style="zoom:67%;"><img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503105957260.png" alt="image-20220503105957260" style="zoom:67%;"><h3 id="条形图"><a href="#条形图" class="headerlink" title="条形图"></a>条形图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">left, height, width=<span class="number">0.8</span>, bottom=<span class="literal">None</span>, hold=<span class="literal">None</span>, data=<span class="literal">None</span>, **kwargs</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>left：x轴的位置序列，一般采用range函数产生一个序列，  但是有时候可以是字符串；</p><p>height：表示条形图的高度，也就是y轴的数值；</p><p>alpha：表示柱形图的颜色透明度，默认值为1；</p><p>width：表示柱形图的宽度，默认值为0.8；</p><p>color（facecolor）：柱形图填充的颜色，默认为随机色；</p><p>edgecolor：图形边缘颜色；</p><p>label：解释每个图像代表的含义； </p><p>linewidth（linewidths &#x2F; lw)：边缘线的宽度，默认值为1。</p><p>注意：barh() 函数与 bar() 函数的主要区别是：在  bar() 函数中，width 这一参数代表的是柱子的宽度（胖 瘦），而在 barh() 函数中 width 这一参数代表的是横向 柱子的长度（长短）。 </p><p>以2019年各省人口数据为例，数据来源为中国国家统计局 (<a href="http://www.mnw.cn/news/shehui/726472.html)%EF%BC%8C">http://www.mnw.cn/news/shehui/726472.html)，</a> 数据文件为“2019分省人口及GDP.xlsx”。</p><img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503133314735.png" alt="image-20220503133314735" style="zoom:67%;"><p>有时显示在横轴上的数据很多，看起来很不方便。这种 情况下可以采用水平条形图。第一种方法是在<strong>plt.bar函数中指定orientation&#x3D;’horizontal’参数</strong>，第二种方法是是<strong>直接使用plt.barh函数</strong>。使用barh时x轴表示人口数量，y轴表示不同的省份。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.bar(<span class="number">0</span>,bottom=<span class="built_in">range</span>(<span class="built_in">len</span>(province)),width=population,height=<span class="number">0.7</span>,orientation=<span class="string">&#x27;horizontal&#x27;</span>)</span><br></pre></td></tr></table></figure><img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503133523695.png" alt="image-20220503133523695" style="zoom:67%;"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plt.barh(<span class="built_in">range</span>(<span class="built_in">len</span>(province)),population,height=<span class="number">0.7</span>)</span><br><span class="line">plt.yticks(<span class="built_in">range</span>(<span class="built_in">len</span>(province)),province)</span><br><span class="line">plt.tick_params(labelsize=<span class="number">8</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;人口(万人)&quot;</span>)</span><br></pre></td></tr></table></figure><img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503133612570.png" alt="image-20220503133612570" style="zoom:67%;"><p>其中在调用 bar时 <strong>men_means</strong> 对应的 x 为 <strong>x+width&#x2F;2</strong>, 而 <strong>women_means</strong> 对应的 x 为 <strong>x-width&#x2F;2</strong>。由于指定了不同的 x 位置，两组数据可以并排放置。</p><img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503133729426.png" alt="image-20220503133729426" style="zoom:67%;"><img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503133744725.png" alt="image-20220503133744725" style="zoom:67%;"><p>垂直堆叠条形图可以用来显示不同类别中各个子 类的比例关系。如大学不同专业中男女生比例。垂 直并列条形图需要通过bottom设置，bottom的坐标是建立在另一个条形图基础上。</p><img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/resources/image-20220503133852263.png" alt="image-20220503133852263" style="zoom:67%;"><p>垂直并列条形图需要通过bottom设置，bottom的坐标是建立在另一个条形图基础上。例子中画womenMeans时，指定的bottom为menMeans，即女生的数据在男生的上方。</p><img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503133957605.png" alt="image-20220503133957605" style="zoom:67%;"> <h3 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h3><p>有时候需要从不同的角度对比和分析数据。这可以通过将多个图放置在一起进行对比。</p><p>通过 <strong>plt.axes</strong> 函数可以创建基本子图，默认情况下它会创建一个标准的坐标轴，并填满整张图。但是可以通过参数指定子图的位置和大小。这个函数的参数是个列表形式，有四个值，从前往后，分别是子图左下角基点的x和y坐标以及子图的宽度和高度，数值的取值范围是0-1之间，画布左下角是（0，0），画布右上角是（1，1）。 </p><img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503134233615.png" alt="image-20220503134233615" style="zoom:67%;"><p>上面是Matlab接口的风格，面向对象画图接口中有类似的 <strong>fig.add_axes()</strong> 方法可以增加新的子图。下面的例子在两个子图里显示了sin和cos的变化趋势。</p><img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503134613286.png" alt="image-20220503134613286" style="zoom:67%;"><p>第二种方式为使用 <strong>plt.subplot</strong> 方法，该方法有三个整数参数，分别表示行数、列数和子图索引值。索引值从1开始， 从左上角到右下角依次自增。<strong>plt.subplots_adjust</strong> 方法可以指定子图的坐标和间距，参数分别为子图上下左右的坐标， 以及间距(wspace)和上下的间距(hspace)。</p><img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503134920879.png" alt="image-20220503134920879" style="zoom:67%;"><p>使用面向对象的方法 <strong>fig.add_subplot()</strong> 也可以实现同样的效果。</p><img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503141004086.png" alt="image-20220503141004086" style="zoom:67%;"><p>使用plt. subplots()方法可以快速地创建多子图环境， 并返回一个包含子图的Numpy数组。通过对返回的ax数组进 行调用，可以操作每个子图，绘制图形。但是需要注意的是， subplot()和subplots()两个方法在方法名上差个字母s外， subplots的索引是从0开始的。另外subplots()方法还可以通过两个布尔型参数sharex和sharey，指定是否只显示最外侧的x或y轴的标签。</p><img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503141030820.png" alt="image-20220503141030820" style="zoom:67%;"><p>对于不规则的子图，可以使用复杂网格的方式进行组织。 复杂网格首先指定一个多行多列的网格，然后每个子图占用相邻的一个或多个网格绘制。</p><img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503141203146.png" alt="image-20220503141203146" style="zoom:67%;"><img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503141215202.png" alt="image-20220503141215202" style="zoom:67%;"><p><strong>中文显示：</strong></p><p>matplotlib绘制图像的时候如指定了中文的坐标轴标签或标题，显示的时候中文字符会显示为小方格子。造成这个现象的原因是matplotlib库的配置信息里面没有中文字体的 相关信息。通过修改matplotlibrc配置文件可设置字体相关参数。但是更常用的方法是在程序中动态设置字体参数。下面的两种方式都可以达到同样的目的。</p><p><strong>通过pyplot进行设置：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>]=[<span class="string">&#x27;SimHei&#x27;</span>] <span class="comment">#指定默认字体正确显示中文</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>]=<span class="literal">False</span> <span class="comment">#用来正常显示负号</span></span><br></pre></td></tr></table></figure><p><strong>通过pylab进行设置:</strong> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> mpl</span><br><span class="line">mpl.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>]=[<span class="string">&#x27;SimHei&#x27;</span>] <span class="comment">#指定默认字体正确显示中文</span></span><br><span class="line">mpl.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>]=<span class="literal">False</span> <span class="comment">#用来正常显示负号</span></span><br></pre></td></tr></table></figure><p>黑体 SimHei</p><p>仿宋 FangSong </p><p>楷体 KaiTi</p><p>微软雅黑 Microsoft YaHei</p><p>微软正黑体 Microsoft JhengHei</p><h3 id="组合图形与标注"><a href="#组合图形与标注" class="headerlink" title="组合图形与标注"></a>组合图形与标注</h3><img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503163129982.png" alt="image-20220503163129982" style="zoom:67%;"><img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503163149587.png" alt="image-20220503163149587" style="zoom:67%;"><p>Matplotlib中辅助线相关的函数包括:</p><p>​    grid():显示网格线</p><p>​    hlines(y,minx,maxx):在指定的y处从minx到maxx画横线。</p><p>​    vlines(x,miny,maxy):在指定的x处从miny到maxx画竖线。</p><p>​    <img src="/../resources/image-20220503163256509.png" alt="image-20220503163256509"></p><img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503163325700.png" alt="image-20220503163325700" style="zoom:67%;">]]></content:encoded>
      
      
      <category domain="https://congyx.com/categories/python/">python</category>
      
      
      <category domain="https://congyx.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/">数据可视化</category>
      
      
      <comments>https://congyx.com/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>python爬虫</title>
      <link>https://congyx.com/2022/03/26/python%E7%88%AC%E8%99%AB/</link>
      <guid>https://congyx.com/2022/03/26/python%E7%88%AC%E8%99%AB/</guid>
      <pubDate>Sat, 26 Mar 2022 02:00:12 GMT</pubDate>
      
      <description>&lt;h3 id=&quot;python爬虫工作原理&quot;&gt;&lt;a href=&quot;#python爬虫工作原理&quot; class=&quot;headerlink&quot; title=&quot;python爬虫工作原理&quot;&gt;&lt;/a&gt;python爬虫工作原理&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;获取数据：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;爬虫程序会根据我们提供的网址，向服务器发起请求，然后返回数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解析数据：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;爬虫程序会把服务器返回的数据解析成我们能读懂的格式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提取数据：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;爬虫程序再从中提取出我们需要的数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;储存数据:&lt;/strong&gt;&lt;br&gt;爬虫程序把这些有用的数据保存起来,便于你以后的使用和分析。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="python爬虫工作原理"><a href="#python爬虫工作原理" class="headerlink" title="python爬虫工作原理"></a>python爬虫工作原理</h3><p><strong>获取数据：</strong></p><p>爬虫程序会根据我们提供的网址，向服务器发起请求，然后返回数据。</p><p><strong>解析数据：</strong></p><p>爬虫程序会把服务器返回的数据解析成我们能读懂的格式。</p><p><strong>提取数据：</strong></p><p>爬虫程序再从中提取出我们需要的数据。</p><p><strong>储存数据:</strong><br>爬虫程序把这些有用的数据保存起来,便于你以后的使用和分析。</p><span id="more"></span><h4 id="requests库"><a href="#requests库" class="headerlink" title="requests库"></a>requests库</h4><p>requests库可以帮我们下载网页源代码、文本、图片，甚至是音频。</p><p><strong>requests.get()</strong></p><p>requests.get 是在调用 requests 库中的 get() 方法，它向服务器发送了一个请求，括号里的参数是你需要的数据所在的网址，然后得到了服务器的响应。服务器返回的结果是个 Response 对象。</p><p>response对象常用的四个属性：</p><p><img src="/../resources/image-20220410100554836.png" alt="image-20220410100554836"></p><p><strong>response.status_code属性：</strong></p><p><img src="/../resources/image-20220410100621487.png" alt="image-20220410100621487"></p><p><strong>response.content属性：</strong></p><p>该属性能把Response对象的内容以二进制数据的形式返回，适用于图片、音频、视频的下载。</p><p><strong>response.text属性：</strong></p><p>该属性可以把Response对象的内容以字符串的形式返回， 适用于文字、网页源代码的下载。</p><p><strong>response.encoding属性：</strong></p><p>该属性能帮我们定义Response对象的编码。 遇上输出的文本有乱码问题，才考虑用res.encoding。首先，目标数据本身是什么编码是未知的。用requests.get() 发 送请求后，会取得一个Response对象，其中，requests库会对数据的编码类型做出自己的判断。但是这个判断有可能准确，也可能不准确。 如果它判断准确的话，打印出来的response.text的内容就是正常的、没有乱码的，就无需用res.encoding；如果判断不准确，就会出现一堆乱码，那我们就可以去查看目标数据的编码，然后再用res.encoding把编码定义成和目标数据一 致的类型即可。</p><h4 id="robots协议"><a href="#robots协议" class="headerlink" title="robots协议"></a>robots协议</h4><p>查看robots协议，在网站的域名后加上 &#x2F;robots.txt</p><p><img src="/../resources/image-20220410101501845.png" alt="image-20220410101501845"></p><h4 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h4><p>HTML文档包含了HTML标签（TAG）和元素，通过它们来描述网页。Web浏览器的作用是将HTML源文件转化成 网页形式，并显示出它们。浏览器本身并不会显示出HTML 标签，而是使用它们来解释页面的内容。</p><p><img src="/../resources/image-20220410101613520.png" alt="image-20220410101613520"></p><p>HTML常见标签：</p><p><img src="/../resources/image-20220410101647072.png" alt="image-20220410101647072"></p><h4 id="解析数据"><a href="#解析数据" class="headerlink" title="解析数据"></a>解析数据</h4><p>我们平时使用浏览器上网，浏览器会把服务器返 回来的HTML源代码翻译为我们能看懂的样子，之后我们才能在网页上做各种操作。 而在爬虫中，也要使用能读懂html的工具，才能提取到想要的数据。</p><p><strong>【提取数据】</strong>是指把我们需要的数据从众多数据中挑选出来。</p><p><img src="/../resources/image-20220410102609214.png" alt="image-20220410102609214"></p><p>在括号中，要输入两个参数，第0个参数是要被解析的文本，注意了，它必须是字符串。 括号中的第1个参数用来标识解析器，我们要用的是一个 Python内置库：html.parser。（它不是唯一的解析器，但是比较简单的）</p><p>以该网站为例（url： <a href="https://localprod.pandateacher.com/python%02manuscript/crawler-html/spider-men5.0.html%EF%BC%89%E5%81%87%E8%AE%BE%E6%88%91%E4%BB%AC%E6%83%B3%E7%88%AC%E5%8F%96%E7%BD%91%E9%A1%B5%E4%B8%AD%E7%9A%84%E4%B9%A6%E7%B1%8D%E7%B1%BB%E5%9E%8B%E3%80%81%E4%B9%A6%E5%90%8D%E3%80%81%E9%93%BE%E6%8E%A5%E3%80%81%E5%92%8C%E4%B9%A6%E7%B1%8D%E4%BB%8B%E7%BB%8D%E3%80%82%E6%A0%B9%E6%8D%AE%E4%B9%8B">https://localprod.pandateacher.com/pythonmanuscript/crawler-html/spider-men5.0.html）假设我们想爬取网页中的书籍类型、书名、链接、和书籍介绍。根据之</a> 前所学的 requests.get()，我们可以先获取到一个Response对象，并确认自己获取成功：</p><p><img src="/../resources/image-20220410110621682.png" alt="image-20220410110621682"></p><p>接着用BeautifulSoup解析数据，请特别留意第2行和第6 行新增的代码。第2行是引入BeautifulSoup库。第6行中的第 0个参数，必须是字符串类型；括号中的第1个参数是解析器。 这就是解析数据的用法。</p><p><img src="/../resources/image-20220410110641745.png" alt="image-20220410110641745"></p><p>接下来，我们来打印看看soup的数据类型，和soup本身 （第7行开始为新增代码）。</p><p> import requests </p><p>from bs4 import BeautifulSoup </p><p>res &#x3D;  requests.get(‘<a href="https://localprod.pandateacher.com/python-manuscript/crawler-html/spider-men5.0.html&#39;">https://localprod.pandateacher.com/python-manuscript/crawler-html/spider-men5.0.html&#39;</a>)  </p><p>soup &#x3D; BeautifulSoup( res.text,’html.parser’) </p><p>print(type(soup)) #查看soup的类型 </p><p>print(soup) # 打印soup</p><p>代码运行结果：</p><p><img src="/../resources/image-20220410110850553.png" alt="image-20220410110850553"></p><ul><li><p>soup的数据类型是， 说明soup是一个BeautifulSoup对象。打印的soup， 它是所请求网页的完整HTML源代码。我们所要提取的书名、链接、书籍内容这些数据都在这里面。</p></li><li><p>打印soup出来的源代码和我们之前使用 response.text 打印出来的源代码是完全一样的。</p></li><li><p>虽然 response.text 和 soup 打印出的内容一样，但它们属于不同的类： &lt;class ‘str’&gt;与&lt;class ‘bs4.BeautifulSoup’&gt;。前者是字符串，后者是已经被解析过的 BeautifulSoup 对象。之所以打印出来的是一样的文本，是因为 BeautifulSoup 对象在直 接打印它的时候会调用该对象内的 str 方法，所以直接打印 bs 对象显示字符串是str的返回结果。</p></li><li><p>之后还会用 BeautifulSoup 库来提取数据，如果这不是一 个 BeautifulSoup 对象，就没法调用相关的属性和方法的，所以，用 BeautifulSoup 解析数据是非常有用的，并不是重复劳动。</p></li><li><p><img src="/../resources/image-20220410111622337.png" alt="image-20220410111622337"></p></li></ul><p>仍然使用BeautifulSoup来提取数据。</p><p><img src="/../resources/image-20220410111721377.png" alt="image-20220410111721377"></p><p>find() 与 find_all()</p><p><img src="/../resources/image-20220410112341145.png" alt="image-20220410112341145"></p><p>Tag类对象的常用属性和方法</p><p><img src="/../resources/image-20220410112633026.png" alt="image-20220410112633026"></p><h4 id="定制请求头"><a href="#定制请求头" class="headerlink" title="定制请求头"></a>定制请求头</h4><p>最好将自己的爬虫伪装成真实的浏览器——因为在这种情况下，服务器很可能拒绝爬虫访问。甚至有的网站，一开始就不允许爬虫访问。 如，知乎、猫眼电影等。</p><p>每一个 request 请求，都会有一个Requests Headers，把它称作请求头。 它里面会有一些关于该请求的基本信息，比如：这个请求是从什么设备 什么浏览器上发出？这个请求是从哪个页面跳转而来？ user-agent会记录你电脑的信息和浏览器版本（如图，就是windows10的64位操作系统， 使用谷歌浏览器），它最大的应用是帮助我们应对“反爬虫”技术。</p><p><img src="/../resources/image-20220410113019785.png" alt="image-20220410113019785"></p><p>基于【豆瓣官网】【下厨房】等网站突然IP反爬的情况， 程序开始需要加上headers里的 user-agent，以后面的实操例 子下厨房为例，user-agent在这里。</p><p><img src="/../resources/image-20220410113100826.png" alt="image-20220410113100826"></p><p>给爬虫代码加上请求头后是这样的 <strong>headers&#x3D;{‘User-Agent’: ‘Mozilla&#x2F;5.0 (Windows NT 10.0;  Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko)  Chrome&#x2F;86.0.4240.193 Safari&#x2F;537.36’}</strong> 这个请求头是万能的，可以直接保存下来，后面加请求头都可以直接使用。 注意！！！提取数据那一行的第二个参数也要加上请求头！！！</p><p><img src="/../resources/image-20220410113214914.png" alt="image-20220410113214914"></p><p>从最开始用requests库获取数据，到用BeautifulSoup库来解析数据，再继续用BeautifulSoup库提取数据，不断经历的是操作对象的类型转换</p><p><img src="/../resources/image-20220410113315426.png" alt="image-20220410113315426"></p><p>例子：</p><p><img src="/../resources/image-20220410160211171.png" alt="image-20220410160211171"></p>]]></content:encoded>
      
      
      <category domain="https://congyx.com/categories/python/">python</category>
      
      
      <category domain="https://congyx.com/tags/python/">python</category>
      
      
      <comments>https://congyx.com/2022/03/26/python%E7%88%AC%E8%99%AB/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
