<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>程序人生</title>
    <link>https://congyx.com/</link>
    
    <atom:link href="https://congyx.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>欲买桂花同载酒，终不似，少年游。</description>
    <pubDate>Thu, 11 Aug 2022 07:22:19 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>知识图谱(三)</title>
      <link>https://congyx.com/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1-%E4%B8%89/</link>
      <guid>https://congyx.com/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1-%E4%B8%89/</guid>
      <pubDate>Thu, 11 Aug 2022 07:11:10 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;知识图谱的构建过程&quot;&gt;&lt;a href=&quot;#知识图谱的构建过程&quot; class=&quot;headerlink&quot; title=&quot;知识图谱的构建过程&quot;&gt;&lt;/a&gt;知识图谱的构建过程&lt;/h1&gt;&lt;h2 id=&quot;知识图谱的总体构建思路&quot;&gt;&lt;a href=&quot;#知识图谱的总体构建思路&quot; c</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="知识图谱的构建过程"><a href="#知识图谱的构建过程" class="headerlink" title="知识图谱的构建过程"></a>知识图谱的构建过程</h1><h2 id="知识图谱的总体构建思路"><a href="#知识图谱的总体构建思路" class="headerlink" title="知识图谱的总体构建思路"></a>知识图谱的总体构建思路</h2><img src="/知识图谱-三\935893-20190109090654567-18322997.png" alt="img" style="zoom:80%;"><p>如图所示，从原始的数据到形成知识图谱，经历了知识抽取、知识融合（实体对齐）、数据模型构建、质量评估等步骤。</p><p><img src="/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1-%E4%B8%89%5Cimage-20220811151518235.png" alt="image-20220811151518235"></p><p>原始的数据，按照数据的结构化程度来分，可以分为结构化数据、半结构化数据和非结构化数据，根据数据的不同的结构化形式，采用不同的方法，将数据转换为三元组的形式，然后对三元组的数据进行知识融合，主要是实体对齐，以及和数据模型进行结合，经过融合之后，会形成标准的数据表示，为了发现新知识，可以依据一定的推理规则，产生隐含的知识，所有形成的知识经过一定的质量评估，最终进入知识图谱，依据知识图谱这个数据平台，可以实现语义搜索，智能问答，推荐系统等一些应用。</p><h2 id="知识抽取"><a href="#知识抽取" class="headerlink" title="知识抽取"></a>知识抽取</h2><img src="/知识图谱-三\image-20220811151246698.png" alt="image-20220811151246698" style="zoom:80%;"><p>我们将原始数据分为结构化数据、半结构化数据和非结构化数据，根据不同的数据类型，我们采用不同的方法进行处理。</p><h3 id="结构化数据处理"><a href="#结构化数据处理" class="headerlink" title="结构化数据处理"></a>结构化数据处理</h3><p>针对结构化数据，通常是关系型数据库的数据，数据结构清晰，把关系型数据库中的数据转换为RDF数据（linked data），普遍采用的技术是D2R技术。D2R主要包括D2R Server，D2RQ Engine和D2RRQ Mapping语言。</p><p>D2R Server 是一个 HTTP Server，它的主要功能提供对RDF数据的查询访问接口，以供上层的RDF浏览器、SPARQL查询客户端以及传统的 HTML 浏览器调用。 D2RQ Engine的主要功能是使用一个可定制的 D2RQ Mapping 文件将关系型数据库中的数据换成 RDF 格式。D2RQ engine 并没有将关系型数据库发布成真实的 RDF 数据，而是使用 D2RQ Mapping 文件将其映射成虚拟的 RDF 格式。该文件的作用是在访问关系型数据时将 RDF 数据的查询语言 SPARQL 转换为 RDB 数据的查询语言 SQL，并将 SQL 查询结果转换为 RDF 三元组或者 SPARQL 查询结果。D2RQ Engine 是建立在 Jena（Jena 是一个创建 Semantic Web 应用的 Java 平台，它提供了基于 RDF，SPARQL 等的编程环境）的接口之上。 D2RQ Mapping 语言的主要功能是定义将关系型数据转换成 RDF 格式的 Mapping 规则。</p><h3 id="半结构化数据处理"><a href="#半结构化数据处理" class="headerlink" title="半结构化数据处理"></a>半结构化数据处理</h3><p>半结构化数据，主要是指那些具有一定的数据结构，但需要进一步提取整理的数据。比如百科的数据，网页中的数据等。对于这类数据，主要采用包装器的方式进行处理。</p><p>包装器是一个能够将数据从HTML网页中抽取出来,并且将它们还原为结构化的数据的软件程序。网页数据输入到包装器中，通过包装器的处理，输出为我们需要的信息。</p><p>对于一般的有规律的页面，我们可以使用正则表达式的方式写出XPath和CSS选择器表达式来提取网页中的元素。但这样的通用性很差，因此也可以通过包装器归纳这种基于有监督学习的方法,自动的从标注好的训练样例集合中学习数据抽取规则,用于从其他相同标记或相同网页模板抽取目标数据。</p><h3 id="非结构化数据处理"><a href="#非结构化数据处理" class="headerlink" title="非结构化数据处理"></a>非结构化数据处理</h3><p>对于非结构化的文本数据，我们抽取的知识包括实体、关系、属性。对应的研究问题就有三个，一是<strong>实体抽取</strong>，也称为命名实体识别，此处的实体包括概念，人物，组织，地名，时间等等。二是<strong>关系抽取</strong>，也就是实体和实体之间的关系，也是文本中的重要知识，需要采用一定的技术手段将关系信息提取出来。三是<strong>属性抽取</strong>，也就是实体的属性信息，和关系比较类似，关系反映实体的外部联系，属性体现实体的内部特征。</p><p>非结构化数据的抽取问题，研究的人比较多，对于具体的语料环境，采取的技术也不尽相同。举个例子，比如关系抽取，有的人采用深度学习的方法，将两个实体，他们的关系，以及出处的句子作为训练数据，训练出一个模型，然后对于测试数据进行关系抽取，测试数据需要提供两个实体和出处的句子，模型在训练得到的已知关系中查找，得出测试数据中两个实体之间的关系。这是一种关系抽取的方法。还有人用句法依存特征，来获取关系，这种方法认为，实体和实体之间的关系可以组成主谓宾结构，在一个句子中，找出主谓关系和动宾关系，其中的谓词和动词如果是一个词，那么这个词就是一个关系。比如说“小明吃了一个苹果”，主谓关系是“小明吃”，动宾关系是“吃苹果”，那么就认为“吃”是一个关系。</p><p>当然，还有其它很多方法，可以在一定程度上实现实体抽取，关系抽取和属性抽取，效果可能会有差异，这需要在实践中测试和完善。</p><h2 id="知识融合"><a href="#知识融合" class="headerlink" title="知识融合"></a>知识融合</h2><p>知识融合，简单理解，就是将多个知识库中的知识进行整合，形成一个知识库的过程，在这个过程中，主要需要解决的问题就是实体对齐。不同的知识库，收集知识的侧重点不同，对于同一个实体，有知识库的可能侧重于其本身某个方面的描述，有的知识库可能侧重于描述实体与其它实体的关系，知识融合的目的就是将不同知识库对实体的描述进行整合，从而获得实体的完整描述。</p><p>比如，对于历史人物曹操的描述，在百度百科、互动百科、维基百科等不同的知识库中，描述有一些差别，曹操所属时代，百度百科为东汉，互动百科为东汉末年，维基百科为东汉末期；曹操的主要成就，百度百科为“实行屯田制，安抚流民消灭群雄，统一北方，奠定曹魏政权的基础，开创建安文学，提倡薄葬”，互动百科为“统一北方”，维基百科为“统一了东汉帝国核心地区”。</p><p>由此可以看出，不同的知识库对于同一个实体的描述，还是有一些差异，所属时代的描述差别在于年代的具体程度，主要成就的差别在于成就的范围不同，等等，通过知识融合，可以将不同知识库中的知识进行互补融合，形成全面、准确、完整的实体描述。 知识融合过程中，主要涉及到的工作就是实体对齐，也包括关系对齐，属性对齐，可以通过相似度计算，聚合，聚类等技术来实现。</p><h2 id="数据模型构建"><a href="#数据模型构建" class="headerlink" title="数据模型构建"></a>数据模型构建</h2><p>数据模型就是知识图谱的数据组织框架，不同的知识图谱，会采用不同的数据模型。对于行业知识图谱来说，行业术语、行业数据都相对比较清晰，可以采用自顶向下的方式来建设知识图谱，也就是先确定知识图谱的数据模型，然后，根据数据模型约定的框架，再补充数据，完成知识图谱的建设。 数据模型的构建，一般都会找一个基础的参考模型，这个参考模型，可以参照行业的相关数据标准，整合标准中对数据的要求，慢慢形成一个基础的数据模型，再根据实际收集的数据情况，来完善数据模型。也可以从公共知识图谱数据模型中抽取，将与行业有关的数据模型从公共知识图谱数据模型中提取出来，然后结合行业知识进行完善。</p><h2 id="知识推理"><a href="#知识推理" class="headerlink" title="知识推理"></a>知识推理</h2><p>知识推理，就是根据已有的数据模型和数据，依据推理规则，获取新的知识或者结论，新的知识或结论应该是满足语义的。知识推理，依据描述逻辑系统实现。描述逻辑(Description Logic)是基于对象的知识表示的形式化，也叫概念表示语言或术语逻辑，是一阶谓词逻辑的一个可判定子集。</p><p>一个描述逻辑系统由四个基本部分组成： 最基本的元素：概念、关系、个体；TBox术语集：概念术语的公理集合； Abox断言集：个体的断言集合；TBox 和 ABox上的推理机制。</p><p>描述逻辑涉及到的内容也比较多，此处举几个例子，比如实体的分类包含关系，一个电脑椅是椅子，椅子是家具，可以说，一个电脑椅是家具。常识规则的推理，一个男人的孩子是A，一个女人的孩子是A，可以知道，这个男人和女人是配偶。</p><p>通过推理发现新的知识，应用比较多，说明知识图谱的时候也经常不自觉的会应用推理，比如前两年比较受人关注的王宝强离婚案，为什么会聘用张起淮做律师，通过知识图谱可以很清楚知道，王宝强和冯小刚关系比较密切，冯小刚聘用张起淮作为律师顾问，所以王宝强很容易和张起淮建立关系，这也可以看作是知识推理的范畴。当然，更确切地说，应该是规则的范畴。推理更强调的是固有的逻辑，规则一般是和业务相关的自定义逻辑，但推理和规则都是通过逻辑准则，获取新的知识或发现，在这里先不做区分。</p><h2 id="质量评估"><a href="#质量评估" class="headerlink" title="质量评估"></a>质量评估</h2><p>质量评估，就是对最后的结果数据进行评估，将合格的数据放入知识图谱中。质量评估的方法，根据所构建的知识图谱的不同，对数据要求的差异而有所差别。总的目的是要获得合乎要求的知识图谱数据，要求的标准根据具体情况确定。 比如对于公共领域的知识图谱，知识的获取采用了众包的方法，对于同一个知识点，可能会有很多人来完成，如果这个知识点只有一个答案，可以采用的一种策略是，将多人的标注结果进行比较，取投票多的结果作为最终的结果。当然，这是不严谨的，因为真理往往掌握在少数人的手里，特别是针对一些行业的知识图谱，表现尤为突出。行业内的一条知识，可能只有行业专家能够给出权威正确的答案，如果让大众投票来决定，可能会得到一条错误的知识。所以，针对行业知识图谱，可能会采用不同于公共知识图谱的策略，来进行知识的质量评估。</p>]]></content:encoded>
      
      
      <category domain="https://congyx.com/categories/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/">知识图谱</category>
      
      
      <category domain="https://congyx.com/tags/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/">知识图谱</category>
      
      
      <comments>https://congyx.com/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1-%E4%B8%89/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>知识图谱(二)</title>
      <link>https://congyx.com/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1-%E4%BA%8C/</link>
      <guid>https://congyx.com/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1-%E4%BA%8C/</guid>
      <pubDate>Thu, 11 Aug 2022 07:02:37 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;知识图谱的构建&quot;&gt;&lt;a href=&quot;#知识图谱的构建&quot; class=&quot;headerlink&quot; title=&quot;知识图谱的构建&quot;&gt;&lt;/a&gt;知识图谱的构建&lt;/h1&gt;&lt;p&gt;知识图谱的数据是通过三元组（主语，谓词，宾语）的方式进行组织，每一个三元组代表一条知识，这些三元组并不是杂乱无章的堆砌在知识图谱中，而是按照一定的逻辑组织起来的。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="知识图谱的构建"><a href="#知识图谱的构建" class="headerlink" title="知识图谱的构建"></a>知识图谱的构建</h1><p>知识图谱的数据是通过三元组（主语，谓词，宾语）的方式进行组织，每一个三元组代表一条知识，这些三元组并不是杂乱无章的堆砌在知识图谱中，而是按照一定的逻辑组织起来的。<span id="more"></span></p><h2 id="知识图谱的数据结构"><a href="#知识图谱的数据结构" class="headerlink" title="知识图谱的数据结构"></a>知识图谱的数据结构</h2><p>从知识图谱数据组织的架构来看，可以把知识图谱的数据分为两个层次，一个是<strong>数据模型层</strong>，数据模型是按照本体论的思想，勾画出来的数据组织模式，数据模型可以展示数据的组织方式，数据之间的相互关系，依据数据模型，数据才能得到有效的组织。数据模型除了确定对象之间的分类，关系，还要明确对象的属性，针对不同的知识图谱，需要收集的数据的内容也不相同，内容范围由对象的属性确定。数据模型的分类，关系反映了数据之间的关系特征，数据模型的属性反映了数据的内在特征。 另一个就是<strong>具体数据层</strong>，具体数据是一条条的知识，它是依据数据模型组织起来的。我们可以把数据模型看作是骨架，把具体数据看作是肌肉，两部分共同组成了一个健壮的整体，就是我们的知识图谱。不同类型的知识图谱，组织数据的方式也有所不同，涉及到具体数据，具体数据的内容也有差别。比如对于一个人物来说，如果是历史知识图谱，可能人物数据的内容主要侧重于人物的生平，主要事迹，人物关系等等，如果是文学知识图谱，人物数据的内容则会主要侧重人物的主要作品，师承关系，作品流派等等。 将知识图谱的数据分成了两个层次，在构建知识图谱的时候，是先确定数据模型再收集具体数据，还是先收集具体数据再确定数据模型，这就形成了两种构建知识图谱的方式。</p><h2 id="自顶向下的构建方式"><a href="#自顶向下的构建方式" class="headerlink" title="自顶向下的构建方式"></a>自顶向下的构建方式</h2><p>自顶向下的构建方式，是指先确定知识图谱的数据模型，再根据模型去填充具体数据，最终形成知识图谱。数据模型的设计，是知识图谱的顶层设计，根据知识图谱的特点确定数据模型，就相当于确定了知识图谱收集数据的范围，以及数据的组织方式。这种构建方式，一般适用于行业知识图谱的构建，对于一个行业来说，数据内容，数据组织方式相对来说比较容易确定。</p><p>总体来说，自顶向下的构建方式，适用于那些知识内容比较明确，关系比较清晰的领域构建知识图谱。</p><h2 id="自下向上的构建方式"><a href="#自下向上的构建方式" class="headerlink" title="自下向上的构建方式"></a>自下向上的构建方式</h2><p>自下向上的构建方式，是指先按照三元组的方式收集具体数据，然后根据数据内容来提炼数据模型。 采用这种方式构建知识图谱，是因为在开始构建知识图谱的时候，还不清楚收集数据的范围，也不清楚数据怎么使用，就是先把所有的数据收集起来，形成一个庞大的数据集，然后再根据数据内容，总结数据的特点，将数据进行整理、分析、归纳、总结，形成一个框架，也就是数据模型。一般公共领域的知识图谱采用这种方式，因为公共领域的知识图谱，涉及到海量数据，并且包括方方面面的知识，做出来的效果是大而全，这在构建初期，很难想清楚数据的整体架构，只能是根据数据的内容总结提炼特征，形成数据框架模型。比如google，百度的知识图谱，属于典型的公共领域知识图谱，现实中，使用他们的搜索工具进行内容搜索时，用户可能输入的内容千差万别，各个领域的问题都可能问到，也就使得他们的后台知识图谱内容也要覆盖所有知识，在构建他们这种公共领域的知识图谱过程中，随着数据的不断积累，才会对数据知识进行分类，慢慢呈现出知识架构。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>两种构建方式也不是一成不变的，在构建初期两种方式区别很明显，在知识图谱构建后期，两种方式可能会结合使用。对于自顶向下的构建方式，随着数据量的不断积累，可能会发现原来的数据模型并不完善，有很多数据可能没有包含在数据模型的体系中，这时候就需要修订数据模型，根据数据的特点，完善数据模型。同样，在自下向上的构建方式中，慢慢形成的数据模型，对于后期的数据收集，也有一定的指导作用，按照形成的数据模型，可以快速准确地收集相关数据。总之，数据和数据模型之间，是一个相辅相成的关系，二者在构建知识图谱的过程中缺一不可。</p>]]></content:encoded>
      
      
      <category domain="https://congyx.com/categories/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/">知识图谱</category>
      
      
      <category domain="https://congyx.com/tags/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/">知识图谱</category>
      
      
      <comments>https://congyx.com/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1-%E4%BA%8C/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>知识图谱</title>
      <link>https://congyx.com/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/</link>
      <guid>https://congyx.com/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/</guid>
      <pubDate>Thu, 11 Aug 2022 04:12:11 GMT</pubDate>
      
      <description>&lt;h3 id=&quot;知识图谱&quot;&gt;&lt;a href=&quot;#知识图谱&quot; class=&quot;headerlink&quot; title=&quot;知识图谱&quot;&gt;&lt;/a&gt;知识图谱&lt;/h3&gt;&lt;h4 id=&quot;知识图谱和人工智能&quot;&gt;&lt;a href=&quot;#知识图谱和人工智能&quot; class=&quot;headerlink&quot; title=&quot;知识图谱和人工智能&quot;&gt;&lt;/a&gt;知识图谱和人工智能&lt;/h4&gt;&lt;p&gt;​        谈到知识图谱大部人可能很陌生，但说到人工智能，大家早已耳熟能详。目前，很多行业应用人工智能，让机器代替人进行简单重复性的工作。我们可以把人工智能分为两个层次，一个是感知层次，也就是听觉、视觉、嗅觉、味觉等等，目前人工智能在听觉和视觉方面做的比较好，语音识别，图像识别等，研究的学者越来越多，技术逐渐落地。人工智能的第二个层次，也就是认知层次，能够认识这个客观世界。而认知世界是通过大量的知识积累实现的，我们见到狗和猫，见过几次就能分辨出狗和猫，但如何让机器来分辨？&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="知识图谱"><a href="#知识图谱" class="headerlink" title="知识图谱"></a>知识图谱</h3><h4 id="知识图谱和人工智能"><a href="#知识图谱和人工智能" class="headerlink" title="知识图谱和人工智能"></a>知识图谱和人工智能</h4><p>​        谈到知识图谱大部人可能很陌生，但说到人工智能，大家早已耳熟能详。目前，很多行业应用人工智能，让机器代替人进行简单重复性的工作。我们可以把人工智能分为两个层次，一个是感知层次，也就是听觉、视觉、嗅觉、味觉等等，目前人工智能在听觉和视觉方面做的比较好，语音识别，图像识别等，研究的学者越来越多，技术逐渐落地。人工智能的第二个层次，也就是认知层次，能够认识这个客观世界。而认知世界是通过大量的知识积累实现的，我们见到狗和猫，见过几次就能分辨出狗和猫，但如何让机器来分辨？<span id="more"></span>这种认知能力是知识的运用，当我们见到狗，就会在潜意识中总结狗的特征，长耳朵，瘦脸，汪汪叫。猫的特征，短耳朵，圆脸，喵喵叫。这些知识会存储在人类的大脑中，作为经验知识，再次碰到类似的动物，人们马上就从记忆中想起该动物的特征，对号入座，马上判断出动物的类型。机器要想具有认知能力，也需要建立一个知识库，然后运用知识库来做一些事，这个知识库就是我们要说的知识图谱。从这个角度说，知识图谱是人工职能的一个重要分支，也是机器具有认知能力的基石，在人工智能领域具有非常重要的地位。</p><h4 id="知识图谱的由来"><a href="#知识图谱的由来" class="headerlink" title="知识图谱的由来"></a>知识图谱的由来</h4><p>​        知识图谱（Knowledge Graph）是 Google 在2012年对其搜索引擎中使用的知识库的称谓。</p><p><img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/image-20220811123027705.png" alt="image-20220811123027705" style="zoom:67%;">众所周知，Google是做搜索引擎的，知识图谱出现之前，我们使用google、百度进行搜索的时候，搜索的结果是一堆网页，我们会根据搜索结果的网页题目再点击链接，才能看到具体内容，2012年google提出Google Knowldge Graph之后，利用知识图谱技术改善了搜索引擎核心，表现出来的效果就是我们现在使用搜索引擎进行搜索的时候，搜索结果会以一定的组织结构呈现，比如我们搜索比尔盖茨，结果如图所示</p><img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/935893-20181229144559553-575365779.png" alt="img" style="zoom:67%;"><p>这样的搜索结果，与知识图谱出现之前的结果有什么区别呢，辛格尔博士对知识图谱的介绍很简短，things，not string，抓住了知识图谱的核心，也点出了知识图谱加入之后搜索发生的变化，以前的搜索，都是将要搜索的内容看作字符串，结果是和字符串进行匹配，将匹配程度高的排在前面，后面按照匹配度依次显示。利用知识图谱之后，将搜索的内容不再看作字符串，而是看作客观世界的事物，也就是一个个的个体。搜索比尔盖茨的时候，搜索引擎不是搜索“比尔盖茨”这个字符串，而是搜索比尔盖茨这个人，围绕比尔盖茨这个人，展示与他相关的人和事，左侧百科会把比尔盖茨的主要情况列举出来，右侧显示比尔盖茨的微软产品和与他类似的人，主要是一些IT行业的创始人。一个搜索结果页面就把和比尔盖茨的基本情况和他的主要关系都列出来了，搜索的人很容易找到自己感兴趣的结果。</p><h4 id="知识图谱是什么"><a href="#知识图谱是什么" class="headerlink" title="知识图谱是什么"></a>知识图谱是什么</h4><p>​        知识图谱本质上是一种语义网络，用图的形式描述客观事物，这里的图指的是数据结构中的图，也就是由节点和边组成的，这也是知识图谱（Knowledge Graph）的真实含义。</p><img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/image-20220811122912945.png" alt="image-20220811122912945" style="zoom: 67%;"><p>​        知识图谱中的节点表示概念和实体，概念是抽象出来的事物，实体是具体的事物；边表示事物的关系和属性，事物的内部特征用属性来表示，外部联系用关系来表示。</p><img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/image-20220811122645526.png" alt="image-20220811122645526" style="zoom:67%;"><h4 id="知识图谱如何组织数据"><a href="#知识图谱如何组织数据" class="headerlink" title="知识图谱如何组织数据"></a>知识图谱如何组织数据</h4><p>知识图谱是由实体和实体的关系组成，通过图的形式表现出来，那么实体和实体关系的这些数据在知识图谱中怎么组织呢，这就涉及到三元组的概念，在知识图谱中，节点-边-节点可以看作一条记录，第一个节点看作主语，边看作谓语，第二个节点看作宾语，主谓宾构成一条记录。知识图谱由这样的一条条三元组构成，围绕着一个主语，可以有很多的关系呈现，随着知识的不断积累，最终会形成一个庞大的知识图谱，知识图谱建设完成后，会包含海量的数据，内涵丰富的知识。</p><img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/image-20220811123405135.png" alt="image-20220811123405135" style="zoom:67%;"><h4 id="知识图谱的应用场景"><a href="#知识图谱的应用场景" class="headerlink" title="知识图谱的应用场景"></a>知识图谱的应用场景</h4><ol><li><p>辅助搜索</p><img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/image-20220811123649860.png" alt="image-20220811123649860" style="zoom:67%;"></li><li><p>辅助问答</p><img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/image-20220811123933101.png" alt="image-20220811123933101" style="zoom:67%;"><img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/image-20220811124015557.png" alt="image-20220811124015557" style="zoom:67%;"></li><li><p>辅助数据集成</p><img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/image-20220811124037375.png" alt="image-20220811124037375" style="zoom:67%;"></li><li><p>辅助决策</p></li></ol><p>​        知识图谱是一个具有本体特征的语义网络，可以看成是按照本体模式组织数据的知识库，以知识图谱为基础进行搜索，可以根据查询的内容进行语义搜索，查找需要找的本体或者本体的信息，这种语义搜索功能在google、百度、阿里巴巴等数据量大的公司里得到应用。智能问答，和语义搜索类似，对于提问内容，计算机首先要分析提问问题的语义，然后再将语义转换为查询语句，到知识图谱中查找，将最贴近的答案提供给提问者。推荐系统首先要采集用户的需求，分析用户的以往数据，提取共同特征，然后根据一定的规则，对用户提供推荐的产品。比如淘宝中记录用户经常购买的商品，经常浏览的商品，提取这些商品的共同特征，然后给这个用户打上标签，然后就给用户推荐具有类似特征的商品。</p>]]></content:encoded>
      
      
      <category domain="https://congyx.com/categories/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/">知识图谱</category>
      
      
      <category domain="https://congyx.com/tags/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/">知识图谱</category>
      
      
      <comments>https://congyx.com/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>字符串的一些问题</title>
      <link>https://congyx.com/2022/06/23/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</link>
      <guid>https://congyx.com/2022/06/23/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</guid>
      <pubDate>Thu, 23 Jun 2022 10:05:28 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;最近刷题发现字符串的一类题是自己的弱项，这里记录巩固复习&lt;/p&gt;
</description>
        
      
      
      
      <content:encoded><![CDATA[<p>最近刷题发现字符串的一类题是自己的弱项，这里记录巩固复习</p>]]></content:encoded>
      
      
      <category domain="https://congyx.com/categories/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <category domain="https://congyx.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      
      <comments>https://congyx.com/2022/06/23/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>异或运算</title>
      <link>https://congyx.com/2022/06/15/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/</link>
      <guid>https://congyx.com/2022/06/15/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/</guid>
      <pubDate>Wed, 15 Jun 2022 06:42:38 GMT</pubDate>
      
      <description>&lt;p&gt;今天遇到这样一个题目，&lt;a href=&quot;https://leetcode.cn/problems/single-number/&quot;&gt;136. 只出现一次的数字 - 力扣（LeetCode）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;起初看题目想到用哈希表实现，使用哈希表存储每个数字和该数字出现的次数。遍历数组即可得到每个数字出现的次数，并更新哈希表，最后遍历哈希表，得到只出现一次的数字。但是时间复杂度以及空间复杂度都是 O(n)，貌似不符合题目的要求。查看答案，标准的解法是异或运算(压根没想到)。。。。。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>今天遇到这样一个题目，<a href="https://leetcode.cn/problems/single-number/">136. 只出现一次的数字 - 力扣（LeetCode）</a></p><p>起初看题目想到用哈希表实现，使用哈希表存储每个数字和该数字出现的次数。遍历数组即可得到每个数字出现的次数，并更新哈希表，最后遍历哈希表，得到只出现一次的数字。但是时间复杂度以及空间复杂度都是 O(n)，貌似不符合题目的要求。查看答案，标准的解法是异或运算(压根没想到)。。。。。<span id="more"></span></p><p>首先，我们要了解什么是<strong>异或运算</strong>。</p><p>按位操作符的字面意思很好理解，即对值的二进制格式进行处理的操作符。而异或的作用为：假设有值甲、乙，当甲乙值相等时，异或操作后结果为不等（False，0），反之，为相等（True，1）。所以按位异或操作符的释义便显而易见了：对某值的每个位上的值（0或1）进行异或操作。</p><img src="/2022/06/15/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/Users\Congyingxu\AppData\Roaming\Typora\typora-user-images\image-20220615145352777.png" alt="image-20220615145352777" style="zoom:67%;"><p><strong>异或运算有以下三个性质。</strong></p><ol><li>任何数和 00 做异或运算，结果仍然是原来的数。<em>a</em>⊕0&#x3D;<em>a</em>。</li><li>任何数和其自身做异或运算，结果是 0。<em>a</em>⊕<em>a</em>&#x3D;0。</li><li>异或运算满足交换律和结合律。<em>a</em>⊕<em>b</em>⊕<em>a</em>&#x3D;<em>b</em>⊕<em>a</em>⊕<em>a</em>&#x3D;<em>b</em>⊕(<em>a</em>⊕<em>a</em>)&#x3D;<em>b</em>⊕0&#x3D;<em>b</em>。</li></ol><p>最后附上官方解题代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">single</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            single ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://congyx.com/categories/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <category domain="https://congyx.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      
      <comments>https://congyx.com/2022/06/15/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>String、StringBuffer、StringBuilder之间的联系</title>
      <link>https://congyx.com/2022/06/05/String%E3%80%81StringBuffer%E3%80%81StringBuilder%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB/</link>
      <guid>https://congyx.com/2022/06/05/String%E3%80%81StringBuffer%E3%80%81StringBuilder%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB/</guid>
      <pubDate>Sun, 05 Jun 2022 04:21:10 GMT</pubDate>
      
      <description>&lt;p&gt;今天做题遇见 &lt;strong&gt;反转字符串中的单词&lt;/strong&gt; 这道题，给定一个字符串需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。题目链接：&lt;a href=&quot;https://leetcode.cn/problems/reverse-words-in-a-string-iii/&quot;&gt;557. 反转字符串中的单词 III - 力扣（LeetCode）&lt;/a&gt;。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>今天做题遇见 <strong>反转字符串中的单词</strong> 这道题，给定一个字符串需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。题目链接：<a href="https://leetcode.cn/problems/reverse-words-in-a-string-iii/">557. 反转字符串中的单词 III - 力扣（LeetCode）</a>。<span id="more"></span></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;Let&#x27;s take LeetCode contest&quot;</span><br><span class="line">输出：&quot;s&#x27;teL ekat edoCteeL tsetnoc&quot;</span><br><span class="line"></span><br><span class="line">输入： s = &quot;God Ding&quot;</span><br><span class="line">输出：&quot;doG gniD&quot;</span><br></pre></td></tr></table></figure><p>做题过程中，发现自己忘记了字符串的一些知识，所谓温故而知新。在此记录复习。</p><p>在 java 中字符串属于对象，Java 提供了 String 类来创建和操作字符串。String 类是不可变类，即一旦一个 String 对象被创建以后，包含在这个对象中的字符序列是不可改变的，直至这个对象被销毁。</p><p>Java 提供了两个可变字符串类 <strong>StringBuffer</strong> 和 <strong>StringBuilder</strong>，中文翻译为“字符串缓冲区”。</p><p>StringBuilder 类是 JDK 1.5 新增的类，它也代表可变字符串对象。实际上，StringBuilder 和 StringBuffer 功能基本相似，方法也差不多。不同的是，StringBuffer 是线程安全的，而 StringBuilder 则没有实现线程安全功能，所以性能略高。因此在通常情况下，如果需要创建一个内容可变的字符串对象，则应该优先考虑使用 StringBuilder 类。</p><p>StringBuffer、StringBuilder、String 中都实现了 CharSequence 接口。CharSequence 是一个定义字符串操作的接口，它只包括 length()、charAt(int index)、subSequence(int start, int end) 这几个 API。</p><p>StringBuffer、StringBuilder、String 对 CharSequence 接口的实现过程不一样，</p><img src="/2022/06/05/String%E3%80%81StringBuffer%E3%80%81StringBuilder%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB/image-20220605122937245.png" alt="image-20220605122937245" style="zoom:80%;"><p><strong>String、StringBuffer、StringBuilder 之间的区别：</strong></p><img src="/2022/06/05/String%E3%80%81StringBuffer%E3%80%81StringBuilder%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB/image-20220605122516694.png" alt="image-20220605122516694" style="zoom:80%;"><p><strong>String:</strong></p><p>对于String来说，是把数据存放在了常量池中，因为所有的String，默认都是以常量形式保存，且由final修饰，因此在线程池中它是线程安全的。因为每一个String当被创建好了以后，他就不再发生任何变化，但是它的执行速度是最差的。</p><p>我们要创建String的时候，他在常量池中对这些信息进行处理，如果在程序中出现了大量字符串拼接的工作，效率是非常底下的。<br>因此使用场景是在少量字符串操作的时候才建议直接使用String来操作。</p><p><strong>StringBuffer:</strong></p><p>StringBuffer相对于StringBuilder效率要相对低一点，但也远比String要高的多。效率低的原因：对于StringBuffer来说更多的考虑到了多线程的情况，在进行字符串操作的时候，它使用了synchronize关键字，对方法进行了同步处理。因此StringBuffer适用于多线程环境下的大量操作。</p><p><strong>StringBuilder:</strong></p><p>线程安全与线程不安全：<br>在进行多线程处理的时候，如果多个线程对于这一个对象同时产生操作，会产生预期之外的结果。对于StringBuilder来说，执行效率虽然高，但是因为线程不安全，所以不建议在多线程的环境下对同一个StringBuilder对象进行操作。因此StringBuilder适用于单线程环境下的大量字符串操作。</p><p><strong>参考：</strong><a href="http://c.biancheng.net/view/5822.html">String、StringBuffer和StringBuilder类的区别 (biancheng.net)</a></p>]]></content:encoded>
      
      
      <category domain="https://congyx.com/categories/java/">java</category>
      
      
      <category domain="https://congyx.com/tags/java/">java</category>
      
      
      <comments>https://congyx.com/2022/06/05/String%E3%80%81StringBuffer%E3%80%81StringBuilder%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>二叉树的问题（二）</title>
      <link>https://congyx.com/2022/06/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89/</link>
      <guid>https://congyx.com/2022/06/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89/</guid>
      <pubDate>Wed, 01 Jun 2022 00:36:05 GMT</pubDate>
      
      <description>&lt;p&gt;整理完二叉树的前序、中序、后序、层次遍历之后，进一步学习，记录一下其他有关二叉树的知识。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>整理完二叉树的前序、中序、后序、层次遍历之后，进一步学习，记录一下其他有关二叉树的知识。<span id="more"></span></p><h3 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h3><p><strong>递归：</strong></p><p>二叉树的深度是指树的根节点到任一叶子节点路径上节点的数量，因此从根节点每次向下一层深度都会加1。所以二叉树的深度等于根节点这个1层加上左子树和右子树深度的最大值。同时，我们可以将每一个子树都看成一个根节点，继续用上述方法求深度，将问题划分为子问题，利用递归解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span> <span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left),maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)，其中n为二叉树的节点数，遍历整棵二叉树。</p><p>空间复杂度：O(n)，最坏情况下，二叉树化为链表，递归栈深度最大为n。</p><p><strong>层次遍历（队列）</strong></p><p>根据层次遍历来统计二叉树最大深度，有的层可能会有很多节点，有的层只有一个节点，无论有多少个节点，它们都是一层。所以采取层次遍历，只需统计层数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span> <span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> q.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> q.poll()</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)</span><br><span class="line">                    q.offer(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)</span><br><span class="line">                    q.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">             res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h3><p><strong>递归前序遍历：</strong></p><p>如果想将两棵二叉树合并起来，那么一定要遍历两颗二叉树，那我们可以考虑同步遍历两棵二叉树，这样就可以将每次遍历的值相加在一起。</p><ul><li>首先判断t1与t2是否为空，若为则用另一个代替，若都为空，返回的值也是空。</li><li>然后依据前序遍历的特点，优先访问根节点，将两个根点的值相加创建到新树中。</li><li>s两棵树再依次同步进入左子树和右子树。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span> <span class="params">(TreeNode t1, TreeNode t2)</span> &#123;</span><br><span class="line">        <span class="comment">//若只有一个节点返回另一个，两个都为null自然返回null</span></span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">null</span>) </span><br><span class="line">            <span class="keyword">return</span> t2;</span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> t1;</span><br><span class="line">        <span class="comment">//根左右的方式递归</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(t1.val + t2.val);</span><br><span class="line">        head.left = mergeTrees(t1.left, t2.left);</span><br><span class="line">        head.right = mergeTrees(t1.right, t2.right);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(min(n,m))，m和n分别为两棵树的节点树，当一个树访问完时，自然就连接上另一个树的节点，故只访问了小树的节点数。</li><li>空间复杂度：O(min(n,m))，递归栈深度也同时间，只访问了小树的节点数。</li></ul><p><strong>队列：</strong></p><p>使用队列辅助两个二叉树分别同时层次遍历。</p><ul><li>首先判断t1与t2是否为空，若为则用另一个代替，若都为空，返回的值也是空。</li><li>使用三个辅助队列，第一个队列q用于暂存合并后的二叉树的层次遍历节点，第二个队列q1用于暂存t1的层次遍历节点，第三个队列q2用于暂存t2的层次遍历节点。</li><li>两棵树同步层次遍历，先将根节点加入队列中，同时根节点优先合并。</li><li>每次从队列分别弹出一个元素，判断分别二者的左右子节点是否存在，若是都存在，则相加合并，若是只存在一个则连接该存在的节点，若是都不存在则连接null。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span> <span class="params">(TreeNode t1, TreeNode t2)</span> &#123;</span><br><span class="line">        <span class="comment">//若只有一个节点返回另一个，两个都为null自然返回null</span></span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> t2;</span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> t1;</span><br><span class="line">        <span class="comment">//合并根节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(t1.val + t2.val); </span><br><span class="line">        <span class="comment">//连接后的树的层次遍历节点</span></span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;(); </span><br><span class="line">        <span class="comment">//分别存两棵树的层次遍历节点</span></span><br><span class="line">        Queue&lt;TreeNode&gt; q1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;(); </span><br><span class="line">        Queue&lt;TreeNode&gt; q2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        q.offer(head);</span><br><span class="line">        q1.offer(t1);  </span><br><span class="line">        q2.offer(t2);</span><br><span class="line">        <span class="keyword">while</span> (!q1.isEmpty() &amp;&amp; !q2.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node1</span> <span class="operator">=</span> q1.poll(); </span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node2</span> <span class="operator">=</span> q2.poll();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">left1</span> <span class="operator">=</span> node1.left;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">left2</span> <span class="operator">=</span> node2.left;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">right1</span> <span class="operator">=</span> node1.right;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">right2</span> <span class="operator">=</span> node2.right;</span><br><span class="line">            <span class="keyword">if</span>(left1 != <span class="literal">null</span> || left2 != <span class="literal">null</span>)&#123; </span><br><span class="line">                <span class="comment">//两个左节点都存在</span></span><br><span class="line">                <span class="keyword">if</span>(left1 != <span class="literal">null</span> &amp;&amp; left2 != <span class="literal">null</span>)&#123; </span><br><span class="line">                    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(left1.val + left2.val);</span><br><span class="line">                    node.left = left; </span><br><span class="line">                    <span class="comment">//新节点入队列</span></span><br><span class="line">                    q.offer(left);  </span><br><span class="line">                    q1.offer(left1);</span><br><span class="line">                    q2.offer(left2);</span><br><span class="line">                <span class="comment">//只连接一个节点</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left1 != <span class="literal">null</span>) </span><br><span class="line">                    node.left = left1;</span><br><span class="line">                 <span class="keyword">else</span></span><br><span class="line">                    node.left = left2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(right1 != <span class="literal">null</span> || right2 != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//两个右节点都存在</span></span><br><span class="line">                <span class="keyword">if</span>(right1 != <span class="literal">null</span> &amp;&amp; right2 != <span class="literal">null</span>) &#123; </span><br><span class="line">                    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(right1.val + right2.val);</span><br><span class="line">                    node.right = right;</span><br><span class="line">                    <span class="comment">//新节点入队列</span></span><br><span class="line">                    q.offer(right); </span><br><span class="line">                    q1.offer(right1);</span><br><span class="line">                    q2.offer(right2);</span><br><span class="line">                <span class="comment">//只连接一个节点</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(right1 != <span class="literal">null</span>)  </span><br><span class="line">                    node.right = right1;</span><br><span class="line">                 <span class="keyword">else</span> </span><br><span class="line">                    node.right = right2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h3><p><strong>递归：</strong></p><p>检查从根节点到叶子节点有没有一条等于目标值的路径，肯定需要从根节点遍历到叶子，可以在根节点每次往下一层的时候，用sum减去节点值，最后检查是否完整等于0。遍历的方法可以选取二叉树常用的递归前序遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span> <span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="comment">//空节点找不到路径</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//叶子节点，且路径和为sum</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; sum - root.val == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//递归进入子节点</span></span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>栈、dfs</strong></p><p>遍历过程除了使用递归也可以使用栈辅助，进行dfs（深度优先搜索）遍历，检查往下的路径中是否有等于sum的路径和。</p><p>注意，这里仅是dfs，而不是前序遍历，左右节点的顺序没有关系，因为每次往下都是单独添加某个节点的值相加然后继续往下，因此左右节点谁先遍历不管用。</p><ul><li>首先检查空节点，空树没有路径。</li><li>使用两个栈同步遍历，一个栈记录节点，辅助深度优先搜索，另一个栈跟随记录到该节点为止的路径和。根节点及根节点值先进栈。</li><li>遍历的时候每次弹出两个栈中的内容，判断是否是叶子节点且路径和是否等于目标值。</li><li>没有到叶子节点就将左右子节点（如果有）加入栈中，并跟随加入路径和。</li><li>如果遍历结束也没有找到路径和，则该二叉树中没有。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span> <span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="comment">//空节点找不到路径</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//栈辅助深度优先遍历</span></span><br><span class="line">        Stack&lt;TreeNode&gt; s1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;TreeNode&gt;(); </span><br><span class="line">        <span class="comment">//跟随s1记录到相应节点为止的路径和</span></span><br><span class="line">        Stack&lt;Integer&gt; s2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;(); </span><br><span class="line">        s1.push(root);</span><br><span class="line">        s2.push(root.val);</span><br><span class="line">        <span class="keyword">while</span>(!s1.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//弹出相应节点</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> s1.pop(); </span><br><span class="line">            <span class="comment">//弹出到该点为止的当前路径和</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">cur_sum</span> <span class="operator">=</span> s2.pop(); </span><br><span class="line">            <span class="comment">//叶子节点且当前路径和等于sum</span></span><br><span class="line">            <span class="keyword">if</span>(temp.left == <span class="literal">null</span> &amp;&amp; temp.right == <span class="literal">null</span> &amp;&amp; cur_sum == sum)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//左节点及路径和入栈</span></span><br><span class="line">            <span class="keyword">if</span>(temp.left != <span class="literal">null</span>)&#123; </span><br><span class="line">                s1.push(temp.left);</span><br><span class="line">                s2.push(cur_sum + temp.left.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//右节点及路径和入栈</span></span><br><span class="line">            <span class="keyword">if</span>(temp.right != <span class="literal">null</span>)&#123; </span><br><span class="line">                s1.push(temp.right);</span><br><span class="line">                s2.push(cur_sum + temp.right.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)，其中n为二叉树所有节点，遍历二叉树所有节点。</li><li>空间复杂度：O(n)，最坏情况二叉树化为链表，递归栈空间最大为n。</li></ul><h3 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h3><p><strong>递归：</strong></p><p>将二叉树镜像，意味着每个左右子树都会交换位置，如果我们从上到下对遍历到的节点交换位置，但是它们后面的节点无法跟着他们一起被交换，因此我们可以考虑自底向上对每两个相对位置的节点交换位置，这样往上各个子树也会被交换位置。</p><p>自底向上的遍历方式，我们可以采用<strong>后序递归</strong>的方法。</p><ul><li>时间复杂度：O(n)，其中n为二叉树的节点数，访问二叉树所有节点各一次。</li><li>空间复杂度：O(n)，最坏情况下，二叉树退化为链表，递归栈最大值为n。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">Mirror</span> <span class="params">(TreeNode pRoot)</span> &#123;</span><br><span class="line">        <span class="comment">//空树返回</span></span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//先递归子树</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> Mirror(pRoot.left);  </span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> Mirror(pRoot.right);</span><br><span class="line">        <span class="comment">//交换</span></span><br><span class="line">        pRoot.left = right; </span><br><span class="line">        pRoot.right = left;</span><br><span class="line">        <span class="keyword">return</span> pRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>栈：</strong></p><p>栈的访问是一种自顶向下的访问，因此我们需要在左右子节点入栈后直接交换，然后再访问后续栈中内容。</p><ul><li>优先检查空树的情况。</li><li>使用栈辅助遍历二叉树，根节点先进栈。</li><li>遍历过程中每次弹出栈中一个元素，然后该节点左右节点分别入栈。</li><li>同时我们交换入栈两个子节点的值，因为子节点已经入栈了再交换，就不怕后续没有交换。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">Mirror</span> <span class="params">(TreeNode pRoot)</span> &#123;</span><br><span class="line">        <span class="comment">//空树</span></span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">null</span>)  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//辅助栈</span></span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;TreeNode&gt;(); </span><br><span class="line">        <span class="comment">//根节点先进栈</span></span><br><span class="line">        s.push(pRoot); </span><br><span class="line">        <span class="keyword">while</span> (!s.isEmpty())&#123; </span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> s.pop();</span><br><span class="line">            <span class="comment">//左右节点入栈</span></span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>) </span><br><span class="line">                s.push(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>) </span><br><span class="line">                s.push(node.right);</span><br><span class="line">            <span class="comment">//交换左右</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> node.left; </span><br><span class="line">            node.left = node.right;</span><br><span class="line">            node.right = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h3>]]></content:encoded>
      
      
      <category domain="https://congyx.com/categories/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <category domain="https://congyx.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      
      <comments>https://congyx.com/2022/06/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>二叉树的一些问题</title>
      <link>https://congyx.com/2022/05/27/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</link>
      <guid>https://congyx.com/2022/05/27/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</guid>
      <pubDate>Fri, 27 May 2022 14:44:57 GMT</pubDate>
      
      <description>&lt;p&gt;最近在刷二叉树的相关题目，通过这篇博客记录相关知识点，梳理一些做题的思路。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>最近在刷二叉树的相关题目，通过这篇博客记录相关知识点，梳理一些做题的思路。</p><span id="more"></span><h3 id="二叉树的前序遍历"><a href="#二叉树的前序遍历" class="headerlink" title="二叉树的前序遍历"></a>二叉树的前序遍历</h3><p>二叉树的前序遍历说白了就是 按照“<strong>根左右”</strong>的访问顺序来访问二叉树。首先访问二叉树的根节点，如果有左子树就访问它的左子树，依此类推，等所有左子树访问完毕再访问其右子树。</p><p><strong>递归</strong></p><p>二叉树的递归就是将每个节点的左子树、右子树看成一棵完整的树，那么对于子树的访问或者操作就是对于原树的访问或者操作的子问题。</p><p>时间复杂度：O(n)，其中n为二叉树的节点数，遍历二叉树所有节点。</p><p>空间复杂度：O(n)，最坏情况二叉树化为链表，递归栈深度为n。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> *   public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(List&lt;Integer&gt; list, TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(list,root.val);</span><br><span class="line">        preorder(list,root.left);</span><br><span class="line">        preorder(list,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] preorderTraversal(TreeNode root)&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        preorder(list,root);</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; list.size();i++)</span><br><span class="line">        res[i] = list.get(i);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>栈</strong></p><p>根据 <strong>“根左右”</strong> 的顺序，首先遍历根节点，其次遍历左子树，再遍历右子树。在栈中，如何实现这种操作呢？首先，定义新的数组用来存放节点的值，再将根节点入栈。我们要考虑如何优先访问左子节点，根据栈的先进后出原则可以先将右子节点入栈，然后下一轮访问左子节点，这样每次从栈中弹出一个元素进行访问，实现二叉树的前序遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> *   public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] preorderTraversal (TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">       List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;TreeNode&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        s.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!s.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> s.pop();</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>)</span><br><span class="line">                s.push(node.right);</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>)</span><br><span class="line">                s.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; list.size();i++)</span><br><span class="line">            res[i] = list.get(i);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的后序遍历"><a href="#二叉树的后序遍历" class="headerlink" title="二叉树的后序遍历"></a>二叉树的后序遍历</h3><p><strong>递归</strong></p><p>二叉树的后序遍历说白了就是 ”左右根“，展开来说就是先访问左子树，然后再访问右子树，最后访问根节点。</p><p>时间复杂度：O(n)，其中n为二叉树的节点数，遍历二叉树所有节点。</p><p>空间复杂度：O(n)，最坏情况下二叉树转换为链表，递归栈深度为n</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> *   public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postorder</span><span class="params">(List&lt;Integer&gt; list,TreeNode root)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">        postorder(list,root.left);</span><br><span class="line">        postorder(list,root.right);</span><br><span class="line">        list.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] postorderTraversal (TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        postorder(list,root);</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; list.size();i++)&#123;</span><br><span class="line">            res[i] = list.get(i);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>栈：</strong></p><p>二叉树的前序和中序遍历都可以使用栈来替代递归，同样二叉树的后序遍历同样可以。</p><p>我们根据 ”左右中“ 的顺序，首先要找到每棵子树的最左端节点，如果它还有一个右节点，根据 “左右根” 的遍历原则，我们还要访问右子树。之后该如何访问根节点呢？</p><p>当从栈中弹出根节点，那么一定是左节点已经被访问过了，同时还要保证右节点也已经被访问过了。如果右子树为空，则无需访问，如果右子树不为空，优先进入右子树，此时再将根节点加入栈中。</p><p>当右节点被访问了，又回到了根，我们如何知道右节点被访问呢？用一个前序指针 pre 标记一下，当要回到上一个根节点时，检查一下，如果 pre 确实是它的右子节点，那刚刚已经访问过了，可以访问根节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> *   public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> *   public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] postorderTraversal (TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;TreeNode&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span> || !s.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            s.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> s.pop();</span><br><span class="line">        <span class="keyword">if</span>(node.right == <span class="literal">null</span> || node.right == pre)&#123;</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            pre = node;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            s.push(node);</span><br><span class="line">            root = node.right;</span><br><span class="line">         &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; list.size();i++)</span><br><span class="line">            res[i] = list.get(i);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)，其中n为二叉树的节点数，遍历二叉树所有节点。</p><p>空间复杂度：O(n)，辅助栈空间最大为链表所有节点数。</p><h3 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h3><p><strong>递归</strong></p><p>二叉树的中序遍历，就是根据 “左根右” 的顺序来访问二叉树的节点。我们优先访问它的左子树，等左子树全部节点都访问完毕，再访问根节点，最后访问右子树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> *   public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">       </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(List&lt;Integer&gt; list,TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(list,root.left);</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        inorder(list,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] inorderTraversal (TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        inorder(list,root);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; list.size();i++)</span><br><span class="line">            res[i] = list.get(i);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>栈</strong></p><p>二叉树的中序遍历与前序遍历相似，我们利用栈来代替递归。从根节点开始不断向左访问，第一个访问的叶子节点一定是最左面的节点。然后访问该节点的右子树，最后向上回到父问题。</p><p>时间复杂度：O(n)，其中n为二叉树的节点数，遍历二叉树所有节点。</p><p>空间复杂度：O(n)，辅助栈空间最大为链表所有节点数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> *   public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] inorderTraversal (TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;TreeNode&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span> || !s.isEmpty())&#123;</span><br><span class="line"><span class="keyword">while</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">                s.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> s.pop();</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            root = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; list.size();i++)</span><br><span class="line">            res[i] = list.get(i);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h3><p><strong>递归：</strong></p><p>按行遍历的关键是每一行的深度对应了它输出在二维数组中的深度，即深度可以与二维数组的下标对应，那我们可以在递归的访问每个节点的时候记录深度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root,<span class="type">int</span> depth)</span></span><br></pre></td></tr></table></figure><p>进入子节点时，深度加1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">traverse(root.left,depth + <span class="number">1</span>);</span><br><span class="line">traverse(root.right,depth + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>每个节点值放入二维数组相应行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res[depth - <span class="number">1</span>].push_back(root-&gt;val);</span><br></pre></td></tr></table></figure><ul><li>首先，判断二叉树是否为空，空树则没有遍历结果</li><li>递归进行层次遍历输出，每次递归记录当前二叉树的深度，每当遍历到一个节点，如果为空直接返回</li><li>如果遍历的节点不为空，输出二维数组中一维数组的个数（即代表了输出的行数）小于深度，说明这个节点应该是新的一层，我们在二维数组中增加一个一维数组，然后再加入二叉树元素。</li><li>如果不是第三种情况说明这个深度我们已经有了数组，直接根据深度作为下标取出数组，将元素加在最后就可以了。</li><li>处理完这个节点，再依次递归进入左右节点，同时深度增加。因为我们进入递归的时候是先左后右，那么遍历的时候也是先左后右，正好是层次遍历的顺序。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型ArrayList&lt;ArrayList&lt;&gt;&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root,<span class="type">int</span> depth)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res.size() &lt; depth)&#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; row = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">                res.add(row);</span><br><span class="line">                row.add(root.val);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; row = res.get(depth - <span class="number">1</span>);</span><br><span class="line">                row.add(root.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        traverse(root.left,depth + <span class="number">1</span>);</span><br><span class="line">        traverse(root.right,depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span> <span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        traverse(root, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>队列</strong></p><ul><li>首先判断二叉树是否为空，空树没有遍历结果。</li><li>建立辅助队列，根节点首先进入队列。不管层次怎么访问，根节点一定是第一个，那它肯定排在队伍的最前面。</li><li>每次进入一层，统计队列中元素的个数。因为每当访问完一层，下一层作为这一层的子节点，一定都加入队列，而再下一层还没有加入，因此此时队列中的元素个数就是这一层的元素个数。</li><li>每次遍历这一层这么多的节点数，将其依次从队列中弹出，然后加入这一行的一维数组中，如果它们有子节点，依次加入队列排队等待访问。</li><li>访问完这一层的元素后，将这个一维数组加入二维数组中，再访问下一层。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型ArrayList&lt;ArrayList&lt;&gt;&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span> <span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;TreeNode&gt;();</span><br><span class="line">        q.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">ArrayList&lt;Integer&gt; row = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> q.size();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                row.add(cur.val);</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="literal">null</span>)</span><br><span class="line">                    q.add(cur.left);</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="literal">null</span>)</span><br><span class="line">                    q.add(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(row);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://congyx.com/categories/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <category domain="https://congyx.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      
      <comments>https://congyx.com/2022/05/27/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>java基础复习</title>
      <link>https://congyx.com/2022/05/24/java%E5%9F%BA%E7%A1%80/</link>
      <guid>https://congyx.com/2022/05/24/java%E5%9F%BA%E7%A1%80/</guid>
      <pubDate>Tue, 24 May 2022 09:55:53 GMT</pubDate>
      
      <description>&lt;p&gt;今天在刷牛客的时候，发现自己对一些数据结构的基础知识并不是很清晰。所以在这里做个笔记整理一下。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>今天在刷牛客的时候，发现自己对一些数据结构的基础知识并不是很清晰。所以在这里做个笔记整理一下。<span id="more"></span></p><p>List、LinkedList、ArrayList:</p><p>List:是一个<strong>有序</strong>的集合，可以包含重复的元素。提供了按索引访问的方式。继承Collection。</p><p>List有两个重要的实现类：ArrayList 和 LinkedList，那么 <strong>ArrayList 和 LinkedList 有什么区别呢？</strong></p><p>ArrayList：我们可以将其看作是<strong>能够自动增长容量的数组</strong>。可以利用 ArrayList 的 toArray() 返回一个数组。</p><p>同时，ArrayList采用数组实现的，查找效率一定会比 LinkedList 高。而 LinkedList 采用双向链表实现的，插入和删除的效率会比 ArrayList 高。如果要是在 list 的尾部添加元素，肯定是LinkedList效率高。</p><p>我们再展开一个问题 <strong>ArrayList 和 HashSet 区别：</strong></p><p>首先，ArrayList 底层是动态数组，可以存储重复的值，并且如果不约定下标的话，是有序的。而 hashset 底层是 hash 表，是不可重复并且是无序的。</p><p>Queue</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Queue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">//往队列插入元素，如果出现异常会抛出异常</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line">    <span class="comment">//往队列插入元素，如果出现异常则返回false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span>;</span><br><span class="line">    <span class="comment">//移除队列元素，如果出现异常会抛出异常</span></span><br><span class="line">    E <span class="title function_">remove</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//移除队列元素，如果出现异常则返回null</span></span><br><span class="line">    E <span class="title function_">poll</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//获取队列头部元素，如果出现异常会抛出异常</span></span><br><span class="line">    E <span class="title function_">element</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//获取队列头部元素，如果出现异常则返回null</span></span><br><span class="line">    E <span class="title function_">peek</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Deque 双端队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Deque</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Queue</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span>;<span class="comment">//插入头部，异常会报错</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offerFirst</span><span class="params">(E e)</span>;<span class="comment">//插入头部，异常返回false</span></span><br><span class="line">    E <span class="title function_">getFirst</span><span class="params">()</span>;<span class="comment">//获取头部，异常会报错</span></span><br><span class="line">    E <span class="title function_">peekFirst</span><span class="params">()</span>;<span class="comment">//获取头部，异常不报错</span></span><br><span class="line">    E <span class="title function_">removeFirst</span><span class="params">()</span>;<span class="comment">//移除头部，异常会报错</span></span><br><span class="line">    E <span class="title function_">pollFirst</span><span class="params">()</span>;<span class="comment">//移除头部，异常不报错</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span>;<span class="comment">//插入尾部，异常会报错</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offerLast</span><span class="params">(E e)</span>;<span class="comment">//插入尾部，异常返回false</span></span><br><span class="line">    E <span class="title function_">getLast</span><span class="params">()</span>;<span class="comment">//获取尾部，异常会报错</span></span><br><span class="line">    E <span class="title function_">peekLast</span><span class="params">()</span>;<span class="comment">//获取尾部，异常不报错</span></span><br><span class="line">    E <span class="title function_">removeLast</span><span class="params">()</span>;<span class="comment">//移除尾部，异常会报错</span></span><br><span class="line">    E <span class="title function_">pollLast</span><span class="params">()</span>;<span class="comment">//移除尾部，异常不报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayDeque</p><ul><li>实现于Deque，拥有队列或者栈特性的接口</li><li>实现于Cloneable，拥有克隆对象的特性</li><li>实现于Serializable，拥有序列化的能力</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组存储元素</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elements;</span><br><span class="line"><span class="comment">//头部元素索引</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> head;</span><br><span class="line"><span class="comment">//尾部元素索引</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> tail;</span><br><span class="line"><span class="comment">//最小容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">8</span>;</span><br></pre></td></tr></table></figure><p>ArrayDeque底层使用数组存储元素，同时还使用head和tail来表示索引，但注意tail不是尾部元素的索引，而是尾部元素的下一位，即下一个将要被加入的元素的索引。</p><p>ArrayDeque 是 Deque 接口的一种具体实现，是依赖于可变数组来实现的。ArrayDeque 没有容量限制，可根据需求自动进行扩容。ArrayDeque 可以作为栈来使用，效率要高于Stack；ArrayDeque 也可以作为队列来使用，效率相较于基于双向链表的LinkedList也要更好一些。</p>]]></content:encoded>
      
      
      <category domain="https://congyx.com/categories/java/">java</category>
      
      
      <category domain="https://congyx.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      
      <comments>https://congyx.com/2022/05/24/java%E5%9F%BA%E7%A1%80/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>合并k个已排序的链表</title>
      <link>https://congyx.com/2022/05/22/%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%B7%B2%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</link>
      <guid>https://congyx.com/2022/05/22/%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%B7%B2%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</guid>
      <pubDate>Sun, 22 May 2022 04:16:31 GMT</pubDate>
      
      <description>&lt;p&gt;今天刷题遇到了&lt;strong&gt;合并K个已排序的链表&lt;/strong&gt;这道题，记录，复习一下相关知识点。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>今天刷题遇到了<strong>合并K个已排序的链表</strong>这道题，记录，复习一下相关知识点。<span id="more"></span></p><p>题目描述为：</p><img src="/2022/05/22/%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%B7%B2%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/image-20220522131948214.png" alt="image-20220522131948214" style="zoom:80%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例</span><br><span class="line">输入：[&#123;1,2,3&#125;,&#123;4,5,6,7&#125;]</span><br><span class="line">返回值：&#123;1,2,3,4,5,6,7&#125;</span><br><span class="line"></span><br><span class="line">输入：[&#123;1,2&#125;,&#123;1,4,5&#125;,&#123;6&#125;]</span><br><span class="line">返回值：&#123;1,1,2,4,5,6&#125;</span><br></pre></td></tr></table></figure><p><strong>思路：</strong></p><ol><li><p>用朴素方式，遍历合并。</p><p>使用【合并两个有序链表】中的方法，合并前两个链表，将下一个链表与当前结果合并，遍历列表中的每个链表，一直循环下去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ArrayList&lt;ListNode&gt; lists)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> lists.size();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> lists.get(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> lists.get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">            node = mergeTwoList(lists.get(i),node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoList</span><span class="params">(ListNode node1,ListNode node2)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> node;</span><br><span class="line">        <span class="keyword">while</span>(node1!=<span class="literal">null</span> &amp;&amp; node2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node1.val &lt; node2.val)&#123;</span><br><span class="line">                tmp.next = node1;</span><br><span class="line">                node1 = node1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tmp.next = node2;</span><br><span class="line">                node2 = node2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.next = node1!=<span class="literal">null</span>?node1:node2;</span><br><span class="line">        <span class="keyword">return</span> node.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法时间复杂度为O(k²n)，提交结果显示运行超时，通过率90.91%。</p><img src="/2022/05/22/%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%B7%B2%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/image-20220522124304088.png" alt="image-20220522124304088" style="zoom: 80%;"></li><li><p>分治算法。</p><ul><li><p>将待排序元素分成大小大致相同的两个子序列</p></li><li><p>对两个子序列进行合并排序</p></li><li><p>将排好序的有序子序列进行合并，得到最终的有序序列。</p><img src="/2022/05/22/%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%B7%B2%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2hlbmdxaXVtaW5n,size_18,color_FFFFFF,t_70,g_se,x_16.png" alt="img" style="zoom:80%;"><p>参考：<a href="https://blog.csdn.net/chengqiuming/article/details/123146537?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1-123146537-blog-118992123.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1-123146537-blog-118992123.pc_relevant_default&utm_relevant_index=1"> 分治算法的经典案例——合并排序_chengqiuming的博客-CSDN博客_合并排序</a></p><p>首先将待排序序列分成大小大致相同的两个子序列，然后再把子序列继续分成大小大致相同的两个子序列，一直递归下去，直到分解成只剩一个元素；然后执行合并操作。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ArrayList&lt;ListNode&gt; lists)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> merge(lists,<span class="number">0</span>,lists.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">merge</span><span class="params">(ArrayList&lt;ListNode&gt; lists,<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r)</span><br><span class="line">            <span class="keyword">return</span> lists.get(l);</span><br><span class="line">        <span class="keyword">if</span>(l &gt; r)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r-l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> mergeTwoList(merge(lists,l,mid),merge(lists,mid+<span class="number">1</span>,r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//合并两个有序链表</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoList</span><span class="params">(ListNode node1,ListNode node2)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> node;</span><br><span class="line">        <span class="keyword">while</span>(node1!=<span class="literal">null</span> &amp;&amp; node2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node1.val &lt;= node2.val)&#123;</span><br><span class="line">                tmp.next = node1;</span><br><span class="line">                node1 = node1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tmp.next = node2;</span><br><span class="line">                node2 = node2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.next = node1!=<span class="literal">null</span>?node1:node2;</span><br><span class="line">        <span class="keyword">return</span> node.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>第一轮合并了 k&#x2F;2 组链表，每一组的时间代价是O(2n)；第二轮合并了 4&#x2F;k 组链表，每一组的时间代价是O(4n)………………时间复杂度为O(kn x log K)</p><p>空间复杂度：递归会使用到O(log k)空间代价的栈空间。</p></li><li><p>优先队列，小根堆。</p></li></ol><p>​        首先，了解<strong>优先级队列</strong>的概念(PriorityQueue)。</p><p>​        <strong>队列</strong>是一种先进先出（FIFO）的数据结构，一些情况下，操作的数据会有优先级，一般出队列时，要求优先级高的元素先进性操作，这种情况使用队列就        行不通了。在这种情况下，数据结构提供两个最基本的操作，一个是返回最高优先级对象，一个是添加新对象，这种数据结构就是优先级队列(PriorityQueue)</p><p>​        PriorityQueue的底层是<strong>堆</strong>，堆的底层是数组。</p><p>​        Java集合框架中提供了<strong>PriorityQueue</strong>和<strong>PriorityBlockingQueue</strong>两种类型的优先级队列，PriorityQueue是<strong>线程不安全</strong>的，PriorityBlockingQueue是<strong>线程安全</strong>的，这里主要使用PriorityQueue。</p><ul><li>导入PriorityQueue所在的包</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue</span><br></pre></td></tr></table></figure><ol><li>PriorityQueue中放置的元素必须要能够比较大小 （只有实现了 Comparable 和 Comparator 接口的类才能比较大小），不能插入无法比较大小的对象，否则会抛出 ClassCastException 异常</li><li>不能插入 null 对象，否则会抛出 NullPointerException 异常</li><li>没有容量限制，可以插入任意多个元素，其内部可以自动扩容</li><li>插入和删除元素的时间复杂度均为 O(log2N)</li><li>PriorityQueue底层使用了堆数据结构</li></ol><p>这道题使用优先队列构建一个小顶堆，每次堆顶为值最小的节点，按顺序取出，然后将下一个节点放回去，重复此过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ArrayList&lt;ListNode&gt; lists)</span> &#123;</span><br><span class="line">        <span class="comment">//小根堆</span></span><br><span class="line">        Queue&lt;ListNode&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((v1,v2) -&gt; v1.val - v2.val);</span><br><span class="line">        <span class="comment">//将全部的节点放进去</span></span><br><span class="line">        <span class="keyword">for</span>(ListNode node:lists)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">                pq.offer(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//队首为值最小的节点</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">minNode</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">            tail.next = minNode;</span><br><span class="line">            tail = minNode;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(minNode.next != <span class="literal">null</span>)&#123;</span><br><span class="line">                pq.offer(minNode.next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://congyx.com/categories/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <category domain="https://congyx.com/tags/%E7%AE%97%E6%B3%95%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">算法、数据结构</category>
      
      
      <comments>https://congyx.com/2022/05/22/%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%B7%B2%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
