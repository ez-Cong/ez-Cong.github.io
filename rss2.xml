<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>程序人生</title>
    <link>https://congyx.com/</link>
    
    <atom:link href="https://congyx.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>欲买桂花同载酒，终不似，少年游。</description>
    <pubDate>Sun, 14 Aug 2022 02:10:10 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>正则表达式进阶</title>
      <link>https://congyx.com/2022/08/14/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E9%98%B6/</link>
      <guid>https://congyx.com/2022/08/14/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E9%98%B6/</guid>
      <pubDate>Sun, 14 Aug 2022 00:56:07 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;正则表达式进阶&quot;&gt;&lt;a href=&quot;#正则表达式进阶&quot; class=&quot;headerlink&quot; title=&quot;正则表达式进阶&quot;&gt;&lt;/a&gt;正则表达式进阶&lt;/h1&gt;&lt;h2 id=&quot;分组&quot;&gt;&lt;a href=&quot;#分组&quot; class=&quot;headerlink&quot; title=&quot;分组&quot;&gt;&lt;/a&gt;分组&lt;/h2&gt;&lt;p&gt;在正则表达式中还提供了一种将表达式&lt;strong&gt;分组&lt;/strong&gt;的机制，当使用分组时，除了获得整个匹配。还能够在匹配中选择每一个分组。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="正则表达式进阶"><a href="#正则表达式进阶" class="headerlink" title="正则表达式进阶"></a>正则表达式进阶</h1><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>在正则表达式中还提供了一种将表达式<strong>分组</strong>的机制，当使用分组时，除了获得整个匹配。还能够在匹配中选择每一个分组。<span id="more"></span></p><p>要实现分组很简单，使用<code>()</code>即可。</p><img src="/2022/08/14/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E9%98%B6/image-20220814085711087.png" alt="image-20220814085711087" style="zoom:80%;"><p>这段正则表达式将文本<strong>分成了两组</strong>，第一组为：<code>0731</code>，第二组为<code>8825951</code>。</p><p>分组有一个非常重要的功能——<code>捕获数据</code>。所以<code>()</code>被称为捕获分组，用来捕获数据，当我们想要从匹配好的数据中提取关键数据的时候可以使用分组。</p><h2 id="提取p标签中的数据"><a href="#提取p标签中的数据" class="headerlink" title="提取p标签中的数据"></a>提取p标签中的数据</h2><img src="/2022/08/14/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E9%98%B6/image-20220814090425091.png" alt="image-20220814090425091" style="zoom:80%;"><img src="/2022/08/14/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E9%98%B6/image-20220814090622623.png" alt="image-20220814090622623" style="zoom:80%;"><img src="/2022/08/14/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E9%98%B6/image-20220814090908705.png" alt="image-20220814090908705" style="zoom:80%;"><h2 id="或者条件"><a href="#或者条件" class="headerlink" title="或者条件"></a>或者条件</h2><p>使用分组的同时还可以使用 <strong>或者</strong>（<code>or</code>）条件。</p><p>例如要提取所有图片文件的后缀名，可以在各个后缀名之间加上一个 <code>|</code>符号：</p><img src="/2022/08/14/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E9%98%B6/image-20220814091140840.png" alt="image-20220814091140840" style="zoom:80%;"><img src="/2022/08/14/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E9%98%B6/image-20220814091347899.png" alt="image-20220814091347899" style="zoom:80%;"><h2 id="非捕获分组"><a href="#非捕获分组" class="headerlink" title="非捕获分组"></a>非捕获分组</h2><p>有时候，我们并不需要捕获某个分组的内容，但是又想使用分组的特性。</p><p>这个时候就可以使用非捕获组<code>(?:表达式)</code>，从而<strong>不捕获数据</strong>，还能使用分组的功能。</p><p>例如想要匹配<strong>两个字母组成的单词</strong>或者<strong>四个字母组成的单词</strong>就可以使用<strong>非捕获分组</strong>：</p><img src="/2022/08/14/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E9%98%B6/image-20220814091939853.png" alt="image-20220814091939853" style="zoom:80%;"><h2 id="分组使用技巧"><a href="#分组使用技巧" class="headerlink" title="分组使用技巧"></a>分组使用技巧</h2><p>日期可以有很多格式，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">20200102</span><br><span class="line">2020-01-02</span><br><span class="line">2020-1-2</span><br><span class="line">2020.01.02</span><br><span class="line">2020 01 02</span><br><span class="line">2020 1 2</span><br><span class="line">2020/01/02</span><br></pre></td></tr></table></figure><p>现在我们想要使用正则表达式将其中的<code>年月日</code>全都提取出来。</p><p>可以发现他们唯一的区别就在于分隔符和月份与日期，这个时候可以使用 <strong>[]</strong> 来匹配多种情况。</p><img src="/2022/08/14/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E9%98%B6/image-20220814092108110.png" alt="image-20220814092108110" style="zoom:80%;"><p>通过<code>(\d&#123;4&#125;)[-./\s]?(\d&#123;1,2&#125;)[-./\s]?(\d&#123;1,2&#125;)</code> 就可以从文本中将年月日分别提取出来了。</p><p>虽然这段正则表达式看起来内容挺多，但是还是很容易理解的，<code>[-./\s]</code>表示匹配三个可能出现的分隔符<code>-./</code>和空白，<code>?</code>表示匹配它们<code>0</code>次或者<code>1</code>次，其他年月日的数据使用<code>\d&#123;N&#125;</code>与<strong>分组</strong>结合就可以提取到目标数据。</p><img src="/2022/08/14/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E9%98%B6/image-20220814092537004.png" alt="image-20220814092537004" style="zoom:80%;"><img src="/2022/08/14/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E9%98%B6/image-20220814093251525.png" alt="image-20220814093251525" style="zoom:80%;"><h2 id="分组的回溯引用"><a href="#分组的回溯引用" class="headerlink" title="分组的回溯引用"></a>分组的回溯引用</h2><p>正则表达式还提供了一种引用之前匹配分组的机制，有些时候，我们或许会寻找到一个子匹配，该匹配接下来会再次出现。</p><p>例如，要匹配一段 HTML 代码，比如：<code>0123&lt;font&gt;提示&lt;/font&gt;abcd</code>，可能会编写出这样一段正则表达式：</p><img src="/2022/08/14/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E9%98%B6/image-20220814093333017.png" alt="image-20220814093333017" style="zoom:80%;"><p>这确实可以匹配，不过可能还有另一种情况，如果数据改成这样：<code>&lt;font&gt;提示&lt;/bar&gt;</code></p><img src="/2022/08/14/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E9%98%B6/image-20220814093351196.png" alt="image-20220814093351196" style="zoom:80%;"><p>在这里<code>font</code> 和 <code>bar</code> 明显不是一对正确的标签，但是我们编写的正则表达式还是将它们给匹配了，所以这个结果是错误的。</p><p>我们想让后面分组的正则也匹配<code>font</code>，但是现在所有形式的都会匹配。</p><p>那如果想让后面分组的正则和第一个分组的正则匹配同样的数据该如何做呢？</p><p>可以使用<strong>分组的回溯引用</strong>，使用<code>\N</code>可以引用编号为<code>N</code>的分组，因此上述例子的代码我们可以改为：</p><img src="/2022/08/14/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E9%98%B6/image-20220814093408216.png" alt="image-20220814093408216" style="zoom:80%;"><p>通过这个例子，可以发现 <code>\1</code> 表示的就是第一个分组，在这里第一个分组匹配的是 <code>font</code> 所以<code>\1</code> 就代表<code>font</code>。</p><img src="/2022/08/14/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E9%98%B6/image-20220814094252729.png" alt="image-20220814094252729" style="zoom:80%;"><img src="/2022/08/14/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E9%98%B6/image-20220814094657671.png" alt="image-20220814094657671" style="zoom:80%;"><h2 id="正向先行断言"><a href="#正向先行断言" class="headerlink" title="正向先行断言"></a>正向先行断言</h2><p>很多人也称先行断言和后行断言为<strong>环视</strong>，也有人叫<strong>预搜索</strong>，其实叫什么无所谓，重要的是知道如何使用它们！</p><p>先行断言和后行断言总共有四种：</p><ol><li>正向先行断言</li><li>反向先行断言</li><li>正向后行断言</li><li>反向后行断言</li></ol><p><strong>正向先行断言：</strong><code>(?=表达式)</code>，指在某个位置向右看，表示所在位置右侧必须能匹配<code>表达式</code></p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我喜欢你 我喜欢 我喜欢我 喜欢 喜欢你</span><br></pre></td></tr></table></figure><p>如果要取出<strong>喜欢</strong>两个字，要求这个<strong>喜欢</strong>后面有你，这个时候就要这么写：<code>喜欢(?=你)</code>，这就是<strong>正向先行断言</strong>。</p><p><strong>提取包含大小写的字符串：</strong></p><p>先行断言可以用来判断字符串是否符合特定的规则，例如提取包含至少一个大小写字母的字符串：</p><img src="/2022/08/14/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E9%98%B6/image-20220814094839343.png" alt="image-20220814094839343" style="zoom:80%;"><p><code>(?=.*?[a-z])(?=.*?[A-Z]).+</code> 这段正则表达式规定了匹配的字符串中必须包含<strong>至少一个大写和小写的字母</strong>。</p><img src="/2022/08/14/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E9%98%B6/image-20220814095307358.png" alt="image-20220814095307358" style="zoom:80%;"><h2 id="反向先行断言"><a href="#反向先行断言" class="headerlink" title="反向先行断言"></a>反向先行断言</h2><p><strong>反向先行断言</strong><code>(?!表达式)</code>的作用是保证右边不能出现某字符。</p><p>例如： <code>我喜欢你 我喜欢 我喜欢我 喜欢 喜欢你</code></p><p>如果要取出<strong>喜欢</strong>两个字，要求这个<strong>喜欢</strong>后面没有你，这个时候就要这么写：<code>喜欢(?!你)</code>，这就是<strong>反向先行断言</strong>。</p><img src="/2022/08/14/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E9%98%B6/image-20220814095514178.png" alt="image-20220814095514178" style="zoom:80%;"><img src="/2022/08/14/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E9%98%B6/image-20220814100049091.png" alt="image-20220814100049091" style="zoom:80%;"><h2 id="正向后行断言"><a href="#正向后行断言" class="headerlink" title="正向后行断言"></a>正向后行断言</h2><p>本小节只需要记住一句话：先行断言和后行断言只有一个区别，即<strong>先行断言从左往右看，后行断言从右往左看。</strong></p><p><strong>正向后行断言：</strong><code>(?&lt;=表达式)</code>，指在某个位置向左看，表示所在位置左侧必须能匹配<code>表达式</code></p><p>例如：如果要取出喜欢两个字，要求喜欢的<strong>前面有我</strong>，<strong>后面有你</strong>，这个时候就要这么写：<code>(?&lt;=我)喜欢(?=你)</code>。</p><img src="/2022/08/14/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E9%98%B6/image-20220814100341932.png" alt="image-20220814100341932" style="zoom:80%;"><h2 id="返向后行断言"><a href="#返向后行断言" class="headerlink" title="返向后行断言"></a>返向后行断言</h2><p><strong>反向后行断言：</strong><code>(?&lt;!表达式)</code>，指在某个位置向左看，表示所在位置左侧不能匹配<code>表达式</code></p><p>例如：如果要取出喜欢两个字，要求喜欢的<strong>前面没有我</strong>，<strong>后面没有你</strong>，这个时候就要这么写：<code>(?&lt;!我)喜欢(?!你)</code>。</p><img src="/2022/08/14/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E9%98%B6/image-20220814100420821.png" alt="image-20220814100420821" style="zoom:80%;"><img src="/2022/08/14/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E9%98%B6/image-20220814100554182.png" alt="image-20220814100554182" style="zoom:80%;"><img src="/2022/08/14/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E9%98%B6/image-20220814100626159.png" alt="image-20220814100626159" style="zoom:80%;"><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><img src="/2022/08/14/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E9%98%B6/image-20220814100730538.png" alt="image-20220814100730538" style="zoom:80%;"><img src="/2022/08/14/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E9%98%B6/image-20220814100935411.png" alt="image-20220814100935411" style="zoom:80%;">]]></content:encoded>
      
      
      
      <category domain="https://congyx.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</category>
      
      
      <comments>https://congyx.com/2022/08/14/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E9%98%B6/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>基于知识图谱的电影推荐</title>
      <link>https://congyx.com/2022/08/13/%E5%9F%BA%E4%BA%8E%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90/</link>
      <guid>https://congyx.com/2022/08/13/%E5%9F%BA%E4%BA%8E%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90/</guid>
      <pubDate>Sat, 13 Aug 2022 14:23:55 GMT</pubDate>
      
      
      
      
      
      
      <comments>https://congyx.com/2022/08/13/%E5%9F%BA%E4%BA%8E%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>正则表达式</title>
      <link>https://congyx.com/2022/08/13/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <guid>https://congyx.com/2022/08/13/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <pubDate>Sat, 13 Aug 2022 10:15:41 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;正则表达式&quot;&gt;&lt;a href=&quot;#正则表达式&quot; class=&quot;headerlink&quot; title=&quot;正则表达式&quot;&gt;&lt;/a&gt;正则表达式&lt;/h1&gt;&lt;p&gt;本文来源于编程胶囊，主要用于个人学习。&lt;/p&gt;
&lt;p&gt;一个测试网站：&lt;a href=&quot;https://regexr-cn.com/&quot;&gt;RegExr: 学习、构建 和 测试 正则表达式 Test RegEx (regexr-cn.com)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;匹配 a-z 的小写字母；&lt;/p&gt;
&lt;p&gt;匹配 A-F 的大写字母；&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>本文来源于编程胶囊，主要用于个人学习。</p><p>一个测试网站：<a href="https://regexr-cn.com/">RegExr: 学习、构建 和 测试 正则表达式 Test RegEx (regexr-cn.com)</a></p><p>匹配 a-z 的小写字母；</p><p>匹配 A-F 的大写字母；<span id="more"></span></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[a-zA-F]</span><br></pre></td></tr></table></figure><p><strong>取反：</strong><br><strong>n后面的字母不为e</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n[^e]</span><br></pre></td></tr></table></figure><p><strong>不含小写字母的数据;</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[^a-z]</span><br></pre></td></tr></table></figure><p><strong>快捷数字和字母：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\d : 匹配任意数字（0-9）</span><br><span class="line">\w : 匹配任意字母、数字、下划线</span><br></pre></td></tr></table></figure><p><strong>匹配空白，比如空格，tab，换行等：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\s</span><br></pre></td></tr></table></figure><p><strong>匹配单词边界；</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\b</span><br></pre></td></tr></table></figure><p><strong>快捷方式取反：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\W</span><br></pre></td></tr></table></figure><p><strong>开始和结束：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">正则表达式中 ^指定的是一个字符串的开始，$指定的是一个字符串的结束</span><br></pre></td></tr></table></figure><p><strong>任意字符：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.字符代表匹配任何单个字符，只能出现在方括号以外。</span><br><span class="line">.字符只有一个不能匹配的字符，也就是换行符(\n)。</span><br></pre></td></tr></table></figure><p><strong>可选字符 ？</strong></p><p>有时，我们可能想要匹配一个单词的不同写法，比如<code>color</code>和<code>colour</code>，或者<code>honor</code>与<code>honour</code>。</p><p>这个时候我们可以使用 <code>?</code> 符号指定一个字符、字符组或其他基本单元可选，这意味着正则表达式引擎将会期望该字符出现<strong>零次或一次</strong>。</p><p><strong>重复：</strong></p><p>实际开发中我们可能期望一个字符组连续匹配好几次。</p><p>在一个字符组后加上<code>&#123;N&#125;</code> 就可以表示在它之前的字符组出现<code>N</code>次。</p><p><strong>重复区间：</strong></p><p>有时候，我们不知道具体要匹配字符组要重复的次数，比如身份证有<code>15</code>位也有<code>18</code>位的。</p><p>这里重复区间就可以出场了，语法：**<code>&#123;M,N&#125;</code>，<code>M</code>是下界而<code>N</code>是上界。**</p><p><code>\d&#123;3,4&#125;</code> 既可以匹配<code>3</code>个数字也可以匹配<code>4</code>个数字，不过当有<code>4</code>个数字的时候，优先匹配的是<code>4</code>个数字，这是因为正则表达式默认是<strong>贪婪模式</strong>，即尽可能的匹配更多字符，而要使用<strong>非贪婪模式</strong>，我们要在<strong>表达式后面加上 <code>?</code>号</strong>。</p><p>使用正则表达式提取电话号码，假设电话号码有两种规则：</p><ul><li>以<code>3</code>个数字开头，后面<code>7</code>个数字，例如：<code>020-7281333</code></li><li>以<code>4</code>个数字开头，后面<code>7</code>个数字，例如：<code>0731-8283431</code></li></ul><p><strong>开闭区间：</strong></p><p>有时候我们可能遇到字符组的重复次数没有边界，例如：</p><img src="/2022/08/13/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20220813213651127.png" alt="image-20220813213651127" style="zoom:80%;"><p>闭区间不写即可表示匹配一个或无数个。</p><p><strong>速写：</strong></p><p>还可以使用两个速写字符指定常见的重复情况，可以使用 <code>+</code> 匹配<code>1</code>个到无数个，使用 <code>*</code>代表<code>0</code>个到无数个。</p><p>即：<code>+</code>等价于<code>&#123;1,&#125;</code>，<code>*</code>等价于<code>&#123;0,&#125;</code>。</p><p>+号示例：</p><img src="/2022/08/13/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20220813213812724.png" alt="image-20220813213812724" style="zoom:80%;"><p>*号示例：</p><img src="/2022/08/13/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20220813213826083.png" alt="image-20220813213826083" style="zoom:80%;"><p><strong>练习：</strong></p><img src="/2022/08/13/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20220813220642881.png" alt="image-20220813220642881" style="zoom:80%;"><img src="/2022/08/13/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20220813220758578.png" alt="image-20220813220758578" style="zoom:80%;"><img src="/2022/08/13/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20220813220911313.png" alt="image-20220813220911313" style="zoom:80%;"><img src="/2022/08/13/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20220813221627667.png" alt="image-20220813221627667" style="zoom:80%;"><img src="/2022/08/13/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20220813221816979.png" alt="image-20220813221816979" style="zoom:80%;">]]></content:encoded>
      
      
      
      <category domain="https://congyx.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</category>
      
      
      <comments>https://congyx.com/2022/08/13/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>知识图谱实践(七)</title>
      <link>https://congyx.com/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5-%E4%B8%83/</link>
      <guid>https://congyx.com/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5-%E4%B8%83/</guid>
      <pubDate>Thu, 11 Aug 2022 12:26:03 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;网页数据抽取&quot;&gt;&lt;a href=&quot;#网页数据抽取&quot; class=&quot;headerlink&quot; title=&quot;网页数据抽取&quot;&gt;&lt;/a&gt;网页数据抽取&lt;/h1&gt;&lt;p&gt;互联网中蕴含着大量的数据资源，这些数据存在于html的代码之中，如何从浩瀚的代码中提取有效的数据，针对不同的情况，可以采用多种方法来实现网页数据的提取。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="网页数据抽取"><a href="#网页数据抽取" class="headerlink" title="网页数据抽取"></a>网页数据抽取</h1><p>互联网中蕴含着大量的数据资源，这些数据存在于html的代码之中，如何从浩瀚的代码中提取有效的数据，针对不同的情况，可以采用多种方法来实现网页数据的提取。<span id="more"></span></p><h2 id="手工方法"><a href="#手工方法" class="headerlink" title="手工方法"></a>手工方法</h2><p>网页呈现数据的方式，一般都是按照导航页、列表页、详情页进行设计，这就会使得数据展示存在一定的规律，我们找出这种规律，就可以制定相应的规则，来获取数据。比如。京东商城中笔记本的列表页面。</p><img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5-%E4%B8%83/935893-20190923153137663-1112940991.png" style="zoom:80%;"><p> 我们想要在该页面提取笔记本的价格数据，则需要对页面的html代码进行分析，获取其html代码，如下所示：</p><img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5-%E4%B8%83/935893-20190923153204804-1915389282-16602242090062.png" alt="image-20220811203513854" style="zoom:80%;"><h3 id="利用XPath语言"><a href="#利用XPath语言" class="headerlink" title="利用XPath语言"></a>利用XPath语言</h3><p>利用其html代码进行数据提取，可以采用XPath语言，XPath即为XML路径语言（XML Path Language），它是一种用来确定XML文档中某部分位置的语言。XPath基于XML的树状结构，提供在数据结构树中找寻节点的能力。XPath被开发者采用来当作小型查询语言。</p><p>​    价格信息的Xpath代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//*[@id=”plist”]/ul/li[5]/div/div[3]/strong</span><br></pre></td></tr></table></figure><h3 id="利用CSS选择器"><a href="#利用CSS选择器" class="headerlink" title="利用CSS选择器"></a>利用CSS选择器</h3><p>与之类似的，也可以采用CSS选择器来进行定位笔记本价格，把html代码看作是一个dom树，按照树的层次结构，利用CSS选择器来一层层的定位到价格。该笔记本价格信息的CSS选择器的表达式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\#plist&gt;ul&gt;li:nth-child(5)&gt;div&gt;div.p-price&gt;strong</span><br></pre></td></tr></table></figure><h2 id="包装器归纳"><a href="#包装器归纳" class="headerlink" title="包装器归纳"></a>包装器归纳</h2><p>包装器就是将数据从网页中抽取出来，并将数据还原为结构化数据。包装器归纳是基于有监督学习的，它从标注好的训练样例集合中学习数据抽取规则，用于从其它相同标记或相同网页模板中抽取目标数据。</p><p>包装器归纳主要包括网页清洗、网页标注、包装器空间生成、包装器评估、包装器归纳结果等步骤。</p><h3 id="网页清洗"><a href="#网页清洗" class="headerlink" title="网页清洗"></a>网页清洗</h3><p>网页清洗主要解决网页代码不规范的问题，比如网页中的标签没有闭合，个别标签使用不规范等，网页结构代码不严谨，就会导致在抽取过程中的噪声，使用一些工具比如Tidy，对网页进行规范化处理，可以在后期的抽取过程中减少噪声的影响。</p><h3 id="网页标注"><a href="#网页标注" class="headerlink" title="网页标注"></a>网页标注</h3><p>网页标注就是在网页上标注所需要抽取的数据，标注的过程可以是在需要抽取的数据位置上打上特殊的标签，表示这个数据是需要抽取的。比如，我们前面抽取的笔记本的价格数据，就可以在价格标签上打上特殊符号，将价格信息标记为抽取数据。</p><h3 id="包装器空间的生成"><a href="#包装器空间的生成" class="headerlink" title="包装器空间的生成"></a>包装器空间的生成</h3><p>对标注的数据生成XPath集合空间，对生成的集合进行归纳，形成若干个子集。归纳的规则是在子集中的XPath能够覆盖多个标注的数据项，具有一定的泛化能力。</p><h3 id="包装器评估"><a href="#包装器评估" class="headerlink" title="包装器评估"></a>包装器评估</h3><p> 对包装器进行评估，需要采用一定的标准，主要有两个标准，准确率和召回率。</p><p>​    准确率。将筛选出来的包装器对原先训练的网页进行标注，统计与人工标注的相同项的数量，除以当前标注的总数量。准确率越高评分越高。</p><p>​    召回率。将筛选出来的包装器对原先训练的网页进行标注，统计与人工标注的相同项的数量，除以人工标注的总数量。召回率越高评分越高。</p><p>​    经过前面一系列的步骤之后，得到包装器归纳结果，也就是笔记本最后搜索页面价格信息的XPath路径。</p><h2 id="包装器归纳的简单举例"><a href="#包装器归纳的简单举例" class="headerlink" title="包装器归纳的简单举例"></a>包装器归纳的简单举例</h2><p>假如我们的标注信息，同时标注了n1，n2。它们的XPath分别是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n1的XPath：/html[1]/body[1]/table[1]/tbody[1]/tr[2]/td[1]</span><br><span class="line"></span><br><span class="line">n2的XPath：/html[1]/body[1]/table[1]/tbody[1]/tr[3]/td[1]</span><br></pre></td></tr></table></figure><p>将其归纳到一个集合，然后泛化后得到的XPath可能有两个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A: /html[1]/body[1]/table[1]/tbody[1]/tr[3]/td[1]；B: //*/td</span><br></pre></td></tr></table></figure><p>进行包装器评估：</p><p>​    准确率：包装器A的准确率高于包装器B，则A优于B</p><p>​    召回率：包装器A的召回率和包装器B的召回率一样，则A等于B</p><p>​    综上两个标准比较，选择包装器A。</p><h2 id="自动抽取"><a href="#自动抽取" class="headerlink" title="自动抽取"></a>自动抽取</h2><p> 首先来说，网站的数据自动抽取是可行的，因为网站中的数据通常是用很少的一些模板来编码的，通过挖掘多个数据记录中的重复模式来寻找这些模板是可能。其次，自动抽取也能够克服手工方法和包装器归纳的缺陷。手工方法，仅适用于那些较简单网站，工作量不大的情况。有监督的包装器则维护开销会很大，比如网站改变了以后的模板，之前生成的包装器就需要相应的进行修改，才能使用。</p><p>​    网页数据自动抽取的流程如下所示：</p><img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5-%E4%B8%83/935893-20190923153237874-1829310518.png" alt="image-20220811203513854" style="zoom:80%;"><p>对于需要抽取数据的网页，需要进行预处理，也就是网页清洗工作，规范网页代码结构和标签的使用，然后对网页进行聚类处理，通过一定的聚类算法，将特征相近的网页归为一组，然后，根据不同组的聚类网页，训练生成相应的包装器模板，使得每组相似的网页获得一个包装器模板，分别使用不同的包装器模板，对相应的网页进行信息抽取，获取网页中的目标数据，最后，将得到的数据保存到数据库中。</p><p>​    网页信息自动抽取的一个代表就是RoadRunner，它是自动抽取网页数据的包装器，通过比较同类网页的两个样本页面，然后分析两个页面的相似性和不同性，归纳出一个正则文法，然后根据正则文法生成一个网页所包含的数据模式，最后抽取网页的数据。</p><h2 id="三类网页数据抽取方法的比较"><a href="#三类网页数据抽取方法的比较" class="headerlink" title="三类网页数据抽取方法的比较"></a>三类网页数据抽取方法的比较</h2><img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5-%E4%B8%83/image-20220811203513854.png" alt="image-20220811203513854" style="zoom:80%;"><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p> 网页信息抽取除了使用包装器的方法，目前，使用爬虫技术对网页信息进行爬取也很普遍，这些技术并不是单一的一个技术，都有很多技术点组成，存在着一定的交叉。在实际的使用中，大家可以根据具体的情况，采用相应的技术，或者是多项技术的融合，来达到获取网页信息数据的目的。</p>]]></content:encoded>
      
      
      <category domain="https://congyx.com/categories/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/">知识图谱</category>
      
      
      <category domain="https://congyx.com/tags/%E4%BF%A1%E6%81%AF%E6%8A%BD%E5%8F%96/">信息抽取</category>
      
      
      <comments>https://congyx.com/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5-%E4%B8%83/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>知识图谱实践(六)</title>
      <link>https://congyx.com/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5-%E5%85%AD/</link>
      <guid>https://congyx.com/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5-%E5%85%AD/</guid>
      <pubDate>Thu, 11 Aug 2022 12:25:46 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;从结构化数据进行知识抽取-D2RQ&quot;&gt;&lt;a href=&quot;#从结构化数据进行知识抽取-D2RQ&quot; class=&quot;headerlink&quot; title=&quot;从结构化数据进行知识抽取(D2RQ)&quot;&gt;&lt;/a&gt;从结构化数据进行知识抽取(D2RQ)&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;D2RQ，含义是把关系型数据库当作虚拟的RDF图数据库进行访问。D2RQ平台是一个将关系型数据库当作虚拟的、只读的RDF图数据库进行访问的系统。提供了基于RDF访问关系数据库的内容，而无需复制这个数据库将其以RDF的形式进行保存。D2RQ有以下功能：&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="从结构化数据进行知识抽取-D2RQ"><a href="#从结构化数据进行知识抽取-D2RQ" class="headerlink" title="从结构化数据进行知识抽取(D2RQ)"></a>从结构化数据进行知识抽取(D2RQ)</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>D2RQ，含义是把关系型数据库当作虚拟的RDF图数据库进行访问。D2RQ平台是一个将关系型数据库当作虚拟的、只读的RDF图数据库进行访问的系统。提供了基于RDF访问关系数据库的内容，而无需复制这个数据库将其以RDF的形式进行保存。D2RQ有以下功能：<span id="more"></span></p><p>使用SPARQL查询非RDF数据库；</p><p>在Web上，将数据库内容当作链接数据进行访问；</p><p>以RDF形式创建一个自定义的数据库，加载成RDF存储；</p><p>使用Apache Jena API访问非RDF数据库的信息。</p><p>D2RQ是一个开源软件，基于Apache协议发布，源代码在Github上。</p><p>D2RQ平台的组成</p><p>l D2RQ映射语言，一种声明的映射语言，用于描述本体和关系数据模型之间的关系。</p><p>l D2RA引擎，一种服务于Jena语义网工具库插件，使用映射重写对数据库的SQL访问的Jena API调用，并且将查询结果传递给框架高层。</p><p>l D2R服务器，一个提供调试用的链接数据视图和HTML视图的HTTP服务器，还提供了一个SPARQL协议endpoint数据接口。</p><img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5-%E5%85%AD/935893-20190808153811462-1357317205.png" alt="img" style="zoom:80%;"><h2 id="D2RQ映射语言"><a href="#D2RQ映射语言" class="headerlink" title="D2RQ映射语言"></a>D2RQ映射语言</h2><p>D2RQ是一种声明式语言，描述了关系型数据库规则和RDFS词汇或OWL本体之间的关系。D2RQ本身是一个符合Trutle语法的RDF文档，映射是用在D2RQ命名空间下的术语表示的，D2RQ命名空间是</p><p><a href="http://www.wiwiss.fu-berlin.de/suhl/bizer/D2RQ/0.1#">http://www.wiwiss.fu-berlin.de/suhl/bizer/D2RQ/0.1#</a></p><p>映射定义了一个虚拟RDF图，包括数据库的信息。和SQL视图概念类似，除了虚拟的数据结构是一个RDF图而不是虚拟的关系表。这个虚拟的RDF图能够以多种方式访问，取决于映射的实现形式。D2RQ平台提供了SPARQL访问，一个链接数据服务器，一个RDF数据集生成器，一个简单的HTML界面和Jena API访问D2RQ映射数据库。</p><p>下图显示了一个D2RQ映射实例的结构</p><img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5-%E5%85%AD/935893-20190808153823045-818001472.png" alt="img" style="zoom:80%;"><p>数据库映射为RDF术语，显示在右侧的，使用d2rq:ClassMaps and d2rq:PropertyBridges。映射中最重要的问题是类的映射，一个类映射表示一个类或者一组相似的本体类。类映射描述了类的实例如何生成URI或者空节点。它还有一组属性映射规则，能够描述实例的属性如何创建。</p><h2 id="D2R服务器"><a href="#D2R服务器" class="headerlink" title="D2R服务器"></a>D2R服务器</h2><p>D2R服务器是一个工具，基于语义网发布关系型数据库的内容，所有的信息都是由链接数据组成。语义网上的数据都是用RDF模型化和表示，D2R服务器使用了一个定制化D2RQ映射将数据库内容转换为RDF的形式，允许以RDF数据浏览和搜索，这是语义网中最主要的两种访问数据的方式。</p><p>网络的请求通过映射重写为SQL查询语句，这种即时转换允许从大型实时数据库发布RDF，并且无需将数据复制到专用的RDF三元组存储中。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>非常简要的介绍了D2RQ的内容，实际的使用过程中，应该更深入的参考<a href="http://d2rq.org/%E7%9A%84%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%E3%80%82">http://d2rq.org/的相关内容。</a></p>]]></content:encoded>
      
      
      <category domain="https://congyx.com/categories/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/">知识图谱</category>
      
      
      <category domain="https://congyx.com/tags/D2RQ/">D2RQ</category>
      
      
      <comments>https://congyx.com/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5-%E5%85%AD/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>知识图谱实践(五)</title>
      <link>https://congyx.com/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5-%E4%BA%94/</link>
      <guid>https://congyx.com/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5-%E4%BA%94/</guid>
      <pubDate>Thu, 11 Aug 2022 12:15:09 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;Protege简介&quot;&gt;&lt;a href=&quot;#Protege简介&quot; class=&quot;headerlink&quot; title=&quot;Protégé简介&quot;&gt;&lt;/a&gt;Protégé简介&lt;/h1&gt;&lt;p&gt;Protégé是一个本体建模工具软件，由斯坦福大学基于java语言开发的，属于开放源代码软件。软件主要用于语义网中本体的构建和基于本体的知识应用，是本体构建的核心开发工具，最新版本为5.5.0（截至2019年7月）。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="Protege简介"><a href="#Protege简介" class="headerlink" title="Protégé简介"></a>Protégé简介</h1><p>Protégé是一个本体建模工具软件，由斯坦福大学基于java语言开发的，属于开放源代码软件。软件主要用于语义网中本体的构建和基于本体的知识应用，是本体构建的核心开发工具，最新版本为5.5.0（截至2019年7月）。</p><span id="more"></span><p>Protégé支持中文，能够实现实体关系的中文展示。如下图。</p><img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5-%E4%BA%94/935893-20190729172822437-707245774.png" alt="img" style="zoom: 80%;"><p>具体来说，Protégé具有以下功能。</p><p>类建模。Protégé提供了一个图形化用户界面来建模类（包括概念）和它们的属性以及关系。</p><p>实例编辑。根据创建的类型，Protégé会自动产生交互的形式，可以根据类之间的关系获得相应实例的约束，并对实例进行编辑。</p><p>模型处理。Protégé有一些插件库，可以定义语义、解答询问以及定义逻辑行为。</p><p>模型交换。最终的模型（类、实例、关系、属性等）能以各种各样的格式被保存和加载，包括XML、UML、RDF、OWL等。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>软件到官网<a href="https://protege.stanford.edu/products.php%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BD%E3%80%82Prot%C3%A9g%C3%A9%E6%98%AF%E7%94%B1java%E5%BC%80%E5%8F%91%E7%9A%84%EF%BC%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E9%9C%80%E8%A6%81java%E8%BF%90%E8%A1%8C%E6%97%B6%E7%8E%AF%E5%A2%83%EF%BC%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8F%AF%E8%83%BD%E9%9C%80%E8%A6%81%E9%85%8D%E7%BD%AE%E4%B8%80%E4%B8%8Bjava%E7%9A%84%E8%BF%90%E8%A1%8C%E6%97%B6%E7%8E%AF%E5%A2%83%EF%BC%8C%E6%8C%89%E7%85%A7%E6%8F%90%E7%A4%BA%E8%BF%9B%E8%A1%8C%E9%85%8D%E7%BD%AE%E5%B0%B1%E5%8F%AF%E4%BB%A5%E4%BA%86%E3%80%82">https://protege.stanford.edu/products.php直接下载。Protégé是由java开发的，运行时需要java运行时环境，运行时可能需要配置一下java的运行时环境，按照提示进行配置就可以了。</a></p><h2 id="主要工作tab"><a href="#主要工作tab" class="headerlink" title="主要工作tab"></a>主要工作tab</h2><p>打开软件后，可以看到工作区域是由很多tab组成。</p><img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5-%E4%BA%94/935893-20190729172901859-409384028.png" alt="img"><p>Active ontology是显示当前的实体名称，以URI的形式显示，前面是<a href="http://www.semanticweb.org/">www.semanticweb.org</a>后面跟着主机名（我的主机名称为dell），再后面是默认的根据时间命名实体。</p><p>Entities，可以看作是实体的总览，能够看到我们创建实体的一些主要信息，是对实体信息的汇总。</p><p>Classes，是对本体模型中，类型部分的编辑，能够定义类之间的层次关系，相互之间的关系。</p><p>Object properties，物体关系，可以理解为编辑实体外部的关系，也就是实体和实体之间的关系。</p><p>Data properties，数据属性，可以理解为编辑实体内部的属性，用来定义实体本身所具有的属性以及属性值。</p><p>Annotation Properties，标注属性，是w3c定义的一些常用的属性，根据URI可以看到这些属性的具体说明。</p><p>Individuals by class，根据类型创建的实例，用来编辑实例信息，类似于java程序中的对象，要归于某个类别。</p><p>OntoGraf，本体关系图，用来展示我们创建的本体里面各个实体之间的层次关系。</p><p>SPARQL Query，SPARQL查询，使用SPARQL语言，对创建的本体进行查询，获取查询结果。</p><h2 id="创建一个本体实例"><a href="#创建一个本体实例" class="headerlink" title="创建一个本体实例"></a>创建一个本体实例</h2><h3 id="创建本体"><a href="#创建本体" class="headerlink" title="创建本体"></a>创建本体</h3><p>软件打开后，就像大多数软件一样，利用file-new来创建一个本体，Protégé会自己根据默认规则为本体起一个名称，比如我创建的本体名称为：<a href="http://www.semanticweb.org/dell/ontologies/2019/6/untitled-ontology-35%EF%BC%8C%E7%84%B6%E5%90%8E%E6%88%91%E4%BB%AC%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%BC%96%E8%BE%91%E8%BF%99%E4%B8%AA%E6%9C%AC%E4%BD%93%E4%BA%86%E3%80%82">http://www.semanticweb.org/dell/ontologies/2019/6/untitled-ontology-35，然后我们就可以编辑这个本体了。</a></p><h2 id="建立模型层的数据"><a href="#建立模型层的数据" class="headerlink" title="建立模型层的数据"></a>建立模型层的数据</h2><p>本体分为模型层和数据层，模型层主要定义类和类之间的关系。Thing是所有类型的根节点，也就是基类，所有的类型都是从Thing派生出来的，我们建立如图的类型层次结构。</p><img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5-%E4%BA%94/935893-20190729172929101-333830764.png" alt="img" style="zoom:80%;"><p>在Classes这个tab页面下，可以看到红色方框标出来的是Add subclass，一个是工具栏直接增加子类，一个是通过右键选择增加子类，比如我们将鼠标点击owl:Thing之后，然后增加子类人物、势力、工具。然后再点击人物，再增加子类文官、武将和皇族，同样操作，增加工具的子类，武器和马匹。</p><p>还可以定义类之间的一些约束关系，比如人物和工具是互斥的，选择人物后，在右下方，Disjoint with关系选择工具。表示了人物和工具的互斥关系，这时候，我们点击工具，就会发现，Disjoint with已经自动添加了人物这个类。</p><h2 id="创建实体关系"><a href="#创建实体关系" class="headerlink" title="创建实体关系"></a>创建实体关系</h2><p>创建实体之间的关系，在Object Properties这个tab页面。</p><img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5-%E4%BA%94/935893-20190729172955386-785897198.png" alt="img" style="zoom:80%;"><p>编辑方法和添加类型的tab页面类似，最顶层的实体关系为owl:topObjectProperty，选择后，点击工具栏的按钮或者右键选择add sub-properties，添加使用、属于和骑三个关系。对于“使用”这个关系，Domains选择人物，Ranges选择武器，代表三元组中主语是人物，谓语是使用，宾语是武器，组成的三元组就是人使用武器。“属于”这个关系，Domains和Ranges分别为人物和势力，“骑”这个关系的Domains和Ranges分别为人物和马匹。</p><h2 id="创建实体属性"><a href="#创建实体属性" class="headerlink" title="创建实体属性"></a>创建实体属性</h2><p>创建实体的属性，在Data properties这个tab页面。</p><img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5-%E4%BA%94/935893-20190729173013316-486028324.png" alt="img" style="zoom:80%;"><p>三国里面的人物，人名都有一个字，比如一般都说，关羽关云长。关羽就是他的名字，云长是他的字。名字用于自称，字都是别人喊得，表示尊重。</p><p>添加属性“字”后，Domains我们选择人物，Ranges选自如图，在Built in datatypes中选择xsd:string，表示“字”的属性值类型是个字符串。</p><h2 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h2><p>创建本体的实例，在Individuals by class这个tab页面。</p> <img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5-%E4%BA%94/935893-20190729173030856-1805454646.png" alt="img"><p>在Individuals里面，创建关羽、刘备、诸葛亮、蜀、赤兔马、青龙偃月刀等实例。然后分别编辑这些实例。此处以关羽为例说明对实例的编辑。</p><p>首先是确定实例的类型，关羽的类型，选择武将。然后增加实体的关系，骑赤兔马，属于蜀，使用青龙偃月刀等三个关系。最后增加数据属性，字为云长。</p><p>这样就确定了关羽这个实例的类型、关系和属性，从而编辑完成关羽这个实例。同样方法，编辑其它实例的类型、关系和属性，如果某项内容空缺，可以不编辑。</p><h2 id="本体关系的展示"><a href="#本体关系的展示" class="headerlink" title="本体关系的展示"></a>本体关系的展示</h2><p>对于本体的关系信息展示，在OntoGrap这个tab页面。</p><img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5-%E4%BA%94/935893-20190729173046125-691914016.png" alt="img"><p>双击左侧的owl:Thing，在右侧区域会显示本体信息，将展示的信息中，有加号的都双击展开，就会看到整个本体的关系图。红色方框中，是以不同的方式展示关系图，依次是按字母网格展示，径向展示，弹簧展示，垂直树状展示，水平树状展示，垂直方向展示，水平方向展示等。如果将鼠标放到某个信息节点，就会显示该信息节点的详细信息。本例中显示的是“关羽”这个信息点的详细信息。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>介绍了Protégé的基础知识，并通过一个具体的本体创建过程，将软件的使用做了说明。Protégé作为一个强大的本体编辑工具，还有很多功能，比如推理能力，希望通过介绍，大家能够对Protégé进行简单的操作，并通过不断地实践和练习，能够更深入的理解和使用Protégé。</p>]]></content:encoded>
      
      
      <category domain="https://congyx.com/categories/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/">知识图谱</category>
      
      
      <category domain="https://congyx.com/tags/protege/">protege</category>
      
      
      <comments>https://congyx.com/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5-%E4%BA%94/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>知识图谱实践(四)</title>
      <link>https://congyx.com/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5-%E5%9B%9B/</link>
      <guid>https://congyx.com/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5-%E5%9B%9B/</guid>
      <pubDate>Thu, 11 Aug 2022 07:41:44 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;Sparql的使用&quot;&gt;&lt;a href=&quot;#Sparql的使用&quot; class=&quot;headerlink&quot; title=&quot;Sparql的使用&quot;&gt;&lt;/a&gt;Sparql的使用&lt;/h1&gt;&lt;h2 id=&quot;Sparql简介&quot;&gt;&lt;a href=&quot;#Sparql简介&quot; class=&quot;headerlink&quot; title=&quot;Sparql简介&quot;&gt;&lt;/a&gt;Sparql简介&lt;/h2&gt;&lt;p&gt;SPARQL的定义，是一个递归的定义，为SPARQL Protocal and RDF Query Language，是W3C制定的RDF知识图谱标准查询语言，大部分的图数据库都支持SPARQL查询。SPARQL在语法上借鉴了SQL。SPARQL是针对RDF三元组进行查询，通过图匹配的方式获得需要查找的内容。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="Sparql的使用"><a href="#Sparql的使用" class="headerlink" title="Sparql的使用"></a>Sparql的使用</h1><h2 id="Sparql简介"><a href="#Sparql简介" class="headerlink" title="Sparql简介"></a>Sparql简介</h2><p>SPARQL的定义，是一个递归的定义，为SPARQL Protocal and RDF Query Language，是W3C制定的RDF知识图谱标准查询语言，大部分的图数据库都支持SPARQL查询。SPARQL在语法上借鉴了SQL。SPARQL是针对RDF三元组进行查询，通过图匹配的方式获得需要查找的内容。<span id="more"></span></p><p>下面通过一个例子来说明SPARQL的查询语句的基本结构。这个例子可以在<a href="http://dbpedia.org/sparql%E4%B8%AD%E8%BF%90%E8%A1%8C%EF%BC%8C%E8%8E%B7%E5%8F%96%E7%BB%93%E6%9E%9C%E3%80%82">http://dbpedia.org/sparql中运行，获取结果。</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">prefix ontology:&lt;http://dbpedia.org/ontology/&gt;</span><br><span class="line"></span><br><span class="line">select distinct  ?p  ?o</span><br><span class="line"></span><br><span class="line">from &lt;http://dbpedia.org&gt;</span><br><span class="line"></span><br><span class="line">where &#123;ontology:deathDate ?p ?o&#125;</span><br><span class="line"></span><br><span class="line">LIMIT 10</span><br></pre></td></tr></table></figure><p>查询例句，包括了5个部分。</p><p>第一部分是前缀声明，这部分主要是为了后面查询内容的简洁，本例中用ontology代替<a href="http://dbpedia.org/ontology/%EF%BC%8C%E5%9C%A8%E5%90%8E%E9%9D%A2%E7%9A%84%E6%9F%A5%E8%AF%A2%E4%B8%AD%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8ontology%EF%BC%8C%E6%AF%94%E5%A6%82ontology:deathDate%E5%B0%B1%E8%A1%A8%E7%A4%BAhttp://dbpedia.org/ontology/deathDate%EF%BC%8C">http://dbpedia.org/ontology/，在后面的查询中直接使用ontology，比如ontology:deathDate就表示http://dbpedia.org/ontology/deathDate，</a></p><p>第二部分是select子句，用来确定需要查找的内容。以变量的形式体现，本例中就是查找?p和?o，按照三元组的主谓宾结构，这里查找的是谓语和宾语，分别用带问号的字符（串）来表示。</p><p>第三部分是from子句，用来确定从哪个图数据库中查找，类似于关系数据库的表名。本例需要查找的数据是在图数据库<a href="http://dbpedia.org中进行查找.也可以把http//dbpedia.org%E8%BF%99%E4%B8%AAGraph">http://dbpedia.org中进行查找。也可以把http://dbpedia.org这个Graph</a> IRI放到第一个方框内，作为默认的数据集名称。</p><p>第四部分是where子句，这部分是用来匹配三元组，把需要匹配的内容放到{}中，本例中，ontology:deathDate ?p ?o的含义就是主语是ontology:deathDate，即<a href="http://dbpedia.org/ontology/deathDate%EF%BC%8C%E8%B0%93%E8%AF%AD%E6%98%AF?p%EF%BC%8C%E5%AE%BE%E8%AF%AD%E6%98%AF?o%EF%BC%8C%E5%8C%B9%E9%85%8D%E8%BF%99%E4%B8%AA%E5%86%85%E5%AE%B9%E7%BB%93%E6%9E%84%E7%9A%84%E6%89%80%E6%9C%89%E4%B8%89%E5%85%83%E7%BB%84%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E6%89%BE%E5%87%BA%E4%B8%BB%E8%AF%AD%E6%98%AFhttp://dbpedia.org/ontology/deathDate%E7%9A%84%E6%89%80%E6%9C%89%E4%B8%89%E5%85%83%E7%BB%84%E3%80%82">http://dbpedia.org/ontology/deathDate，谓语是?p，宾语是?o，匹配这个内容结构的所有三元组，也就是找出主语是http://dbpedia.org/ontology/deathDate的所有三元组。</a></p><p>第五部分是查询修正的内容，类似于关系数据查询最后的一些限定子句，比如排序order by，限定前几个输出的limit等。本例就是用的limit 10，限定只输出10个结果。</p><p>查询结果如下</p><img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5-%E5%9B%9B/image-20220811201102773.png" alt="image-20220811201102773" style="zoom:80%;"><h2 id="一些常用的查询语句"><a href="#一些常用的查询语句" class="headerlink" title="一些常用的查询语句"></a>一些常用的查询语句</h2><h3 id="最简单的查询"><a href="#最简单的查询" class="headerlink" title="最简单的查询"></a>最简单的查询</h3><p>就像SQL语句中的查询所有内容select * from table，SPARQL也有一个查询全部数据的语句，也是最简单的语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select ?s ?p ?o where &#123;?o ?p ?o&#125;</span><br></pre></td></tr></table></figure><p>这个语句可以查看图数据库里面的所有三元组，不过如果数据集比较庞大，可能发生延时错误，也就是在一定的时间内查询不能完成导致最后无法完成查询，从而不能提供查询结果。</p><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p>在SPARQL中，也有类似SQL中的聚合函数，比如count，比较常用的一个就是查询图数据库的三元组数量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(?s) where &#123;?o ?p ?o&#125;</span><br></pre></td></tr></table></figure><p>我们用上面的语句查询<a href="http://dbpedia.org中三元组的数量,我查了几次,有几次是给出延时错误,有的时候能给出结果./">http://dbpedia.org中三元组的数量，我查了几次，有几次是给出延时错误，有的时候能给出结果。</a></p><p><img src="/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5-%E5%9B%9B/image-20220811201207293.png" alt="image-20220811201207293"></p><p>可以看到，<a href="http://dbpedia.org这个图数据库一共有3亿多条数据./">http://dbpedia.org这个图数据库一共有3亿多条数据。</a></p><h2 id="opional过滤"><a href="#opional过滤" class="headerlink" title="opional过滤"></a>opional过滤</h2><p>使用optional，可以起到过滤的作用，如果满足optional后面匹配的条件，则结果显示出来。比如下面的语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prefix ontology:&lt;http://dbpedia.org/ontology/&gt;</span><br><span class="line"></span><br><span class="line">select distinct ?p ?o</span><br><span class="line"></span><br><span class="line">where &#123;&#123;?s ?p &lt;http://schema.org/deathDate&gt;&#125; optional &#123;?s &lt;http://www.w3.org/2000/01/rdf-schema#label&gt; ?o&#125;&#125;</span><br></pre></td></tr></table></figure><p>查询的含义是先查找宾语是<a href="http://schema.org/deathDate">http://schema.org/deathDate</a> 的主语?s和谓语?p，将主语?s满足模式?s <a href="http://www.w3.org/2000/01/rdf-schema#label">http://www.w3.org/2000/01/rdf-schema#label</a> ?o的内容找出来，最后显示出两个条件都满足的结果，也可以理解为，通过optional后面的子句过滤掉一部分第一个子句的结果，得到最终的结果。<img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5-%E5%9B%9B/image-20220811201251463.png" alt="image-20220811201251463" style="zoom:80%;"></p><h2 id="union全集"><a href="#union全集" class="headerlink" title="union全集"></a>union全集</h2><p>union也是一个在SPARQL中常用的关键字，使用union表示，将所有union连接的子句匹配的结果都显示出来。我们还用2.3的例子，不过把optional替换为union，可以比较一下二者的不同。</p><p>查询语句为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prefix ontology:&lt;http://dbpedia.org/ontology/&gt;</span><br><span class="line"></span><br><span class="line">select distinct ?p ?o</span><br><span class="line"></span><br><span class="line">where &#123;&#123;?s ?p &lt;http://schema.org/deathDate&gt;&#125; union &#123;?s &lt;http://www.w3.org/2000/01/rdf-schema#label&gt; ?o&#125;&#125;</span><br></pre></td></tr></table></figure><p>查询结果为（部分结果）</p><img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5-%E5%9B%9B/935893-20190725115131858-68266755.png" alt="img" style="zoom:80%;"><h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><p>在SQL中的like查询，在SPARQL中也有对应的语句，就是使用FILTER 和regex。</p><p>例句为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prefix ontology:&lt;http://dbpedia.org/ontology/&gt;</span><br><span class="line"></span><br><span class="line">select distinct ?p ?o</span><br><span class="line"></span><br><span class="line">where &#123;ontology:deathDate ?p ?o filter regex(?p,&#x27;label&#x27;)&#125;</span><br></pre></td></tr></table></figure><p>还是查找主语deathDate这个主语的谓语和宾语列表，模糊查询的是谓语中含有’label’的谓语和宾语，这个filter和regex的组合实现的功能就是类似SQL的like功能。</p><p>查询结果为</p><img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5-%E5%9B%9B/image-20220811201343311.png" alt="image-20220811201343311" style="zoom:80%;"><p>从结果可以看到，模糊查询中谓语只包含了有label的内容，其它的给过滤掉了。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这里只是简单介绍了SPARQL的语法和常用的查询语句，实际环境中，应用SPARQL进行查询可能会复杂的多，会有很多复合语句，更为复杂的可能会跨数据集进行查询，也可能用到RDF的一些特性，比如只查找字面量或者只查找IRI的数据等等。总之，SPARQL查询，在实际的使用中，会碰到各种不同的需求，还要根据具体情况写出各种查询语句。</p><p>书写SPARQL查询语句的时候，还要细心，不能出错，不能写错一个字符，有的时候还要注意顺序，这些问题没有注意到，都可能导致查不到结果，或者是直接报错。在拼接SPARQL的时候，要多一些耐心，按照SPARQL规则来，循序渐进，慢慢就会初步掌握这种查询语言。</p><p>另外SPARQL还有UPDATE功能，有insert和delete关键字，但是没有update关键字，也就是说，SPARQL如果实现update操作，需要先insert再delete，从而达到update的效果。SPARQL的UPDATE功能，不如查询功能用的广泛，可能是因为数据集一般数据量大，都是直接以文件的形式存到数据库中的缘故。</p>]]></content:encoded>
      
      
      <category domain="https://congyx.com/categories/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/">知识图谱</category>
      
      
      <category domain="https://congyx.com/tags/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/">知识图谱</category>
      
      
      <comments>https://congyx.com/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5-%E5%9B%9B/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>知识图谱实践(三)</title>
      <link>https://congyx.com/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5-%E4%B8%89/</link>
      <guid>https://congyx.com/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5-%E4%B8%89/</guid>
      <pubDate>Thu, 11 Aug 2022 07:41:28 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;知识表示&quot;&gt;&lt;a href=&quot;#知识表示&quot; class=&quot;headerlink&quot; title=&quot;知识表示&quot;&gt;&lt;/a&gt;知识表示&lt;/h1&gt;&lt;p&gt;构建知识图谱的时候，首先是要建立知识表达的的数据模型，也就是知识图谱整个的数据组织体系，主要是数据的分类及层次关系，还有属性及属性的关系。数据组织体系建立之后，我们就要考虑数据如何表达的问题，这种表达方式应该是既可以让人们容易理解，也要让计算机能够理解和使用。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="知识表示"><a href="#知识表示" class="headerlink" title="知识表示"></a>知识表示</h1><p>构建知识图谱的时候，首先是要建立知识表达的的数据模型，也就是知识图谱整个的数据组织体系，主要是数据的分类及层次关系，还有属性及属性的关系。数据组织体系建立之后，我们就要考虑数据如何表达的问题，这种表达方式应该是既可以让人们容易理解，也要让计算机能够理解和使用。<span id="more"></span></p><h2 id="Linked-Data"><a href="#Linked-Data" class="headerlink" title="Linked Data"></a>Linked Data</h2><img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5-%E4%B8%89/935893-20190720155337201-1798654001.png" alt style="zoom:80%;"><p>在语义网的技术栈中，数据表示占了很大比重，按照语义网技术标准要求，所有的实体或属性数据都应该用URI&#x2F;IRI来表示，除了文本描述的数据，所有数据都应该有一个统一的标识，标识的形式可以是XML、RDF、RDFS或者本体语言OWL，这些都说明数据表示是整个语义网的基础。</p><p>万维网之父，也是语义网的创始人，Tim Berners-Lee也一直呼吁建立互联的数据（Linked Data），还在TED上发表了演讲，演讲题目是raw data now，号召人们开放共享原始数据，让整个世界成为一个互通互联的世界。他的演讲既说明了数据共享的重要性，也说明了数据互联互通的重要性。</p><p>Tim Berners-Lee为了鼓励人们开放共享数据，制定了Linked Data的五星规则，数据每加一颗星，这样的数据就更容易被得到和利用，能够增强数据的互联互通。</p><p>一星：以开放的协议提供到互联网上（不论什么格式），称为开放数据</p><p>二星：能够被机器识别的结构化数据（比如excel，而不是表格的扫描图片）</p><p>三星：非专有格式（比如csv代替excel）</p><p>四星：加上以上要求，使用开放标准从W3C（RDF和SPARQL）到实体，让人们能够根据表述就能确定你所要表达的东西。</p><p>五星：满足以上所有要求，并且能够将你的数据与其他人的数据链接起来，提供上下文。</p><img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5-%E4%B8%89/935893-20190720155347807-787014092.png" alt="img" style="zoom:80%;"><h2 id="RDF"><a href="#RDF" class="headerlink" title="RDF"></a>RDF</h2><p>上面提到让数据互联互通，那么，数据以何种形式展示，才能更好的互联互通呢，知识图谱中，数据的展示形式就是RDF，RDF是应为Resource Description Framework的缩写，即资源描述框架，它可以看作是一个数据模型，也可以看作是表示数据的方法手段。</p><p>其中Resource，资源，顾名思义，是一种数据资源，可以是图片、视频，也可以是人、物或者概念等等，是用URI可以唯一标识的对象。</p><p>Description，描述，是对资源的描述，资源被IRI标识之后，我们能够确定资源，这个资源得内涵外延等具体的内容，还是需要资源的属性和关系来确定。描述就是对资源的属性和关系的内容。</p><p>Framework，框架，是描述资源的语言、语法和模型。</p><p>在RDF中，知识总是以三元组的形式出现，一条知识都是分解为主语（subject）、谓语（predicate）和宾语（object）的三元组（triple）来表示。</p><p>我们以维基百科里面的莎士比亚为例，来看一下RDF的表示方式，莎士比亚的作品有哈姆雷特，用RDF表示为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://www.wikidata.org/wiki/Q692  https://www.wikidata.org/wiki/Property:P800 https://www.wikidata.org/wiki/Q41567</span><br><span class="line"></span><br><span class="line">其中https://www.wikidata.org/wiki/Q692是莎士比亚的URI，https://www.wikidata.org/wiki/Property:P800是notable work的URI</span><br><span class="line"></span><br><span class="line">https://www.wikidata.org/wiki/Q41567是哈姆雷特的URI。</span><br></pre></td></tr></table></figure><p>在维基数据里，关于莎士比亚的知识，都是通过这样的RDF，将一条条的知识汇聚起来，形成莎士比亚的知识卡片。以下是莎士比亚的知识卡片的一部分。</p><img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5-%E4%B8%89/935893-20190720155402433-153410570.png" alt="img" style="zoom:80%;"><p>在实际的应用中，RDF还有几种序列化方法，也就是存储和传输RDF数据的具体实现形式，主要有RDF&#x2F;XML，N-Triples，Turtle，RDFa，JSON-LD等。这些都是满足RDF规则的数据表现形式，各有特点，适于不同的应用场景。</p><p>XML格式技术成熟，存储和解析方便，但该格式比较冗长，不便于阅读，知识图谱很少使用这种格式来表示数据。N-Triples，比较直观简单，一行一个三元组表示一条知识，方便解析和处理，在知识图谱中应用较多。Turtle可以看作是N-Triples的全面版本，比N-Triples要复杂一些，但相对原始的RDF要简洁，语法规则也比较严谨清晰，在知识图谱中使用比较广泛。RDFa，RDF in Attributes，是将RDF数据嵌到网页中，对于前端显示没有影响，对于浏览器来说，能够在非结构化数据中较方便的提取结构化信息，有利于数据的获取和共享。JSON-LD，JSON for Linking Data，用键值对的形式存储RDF数据，也是为了网络数据的共享和传播。</p><p>和RDF一起使用的还有RDFS（RDF Schema），RDF表示的是数据层的内容，RDFS表示的是模型层的内容，RDFS为RDF数据提供一个类型系统，定义了数据的类型、子类型、属性、子属性、主语的范围、宾语的范围等信息，RDFS为数据定义了一个规则范围，RDF数据按照RDFS制定的规则组织数据。</p><h2 id="OWL"><a href="#OWL" class="headerlink" title="OWL"></a>OWL</h2><p>OWL，不是猫头鹰，是Web Ontology Language，Web本体语言，是W3C制定一种适用于语义网使用的数据模型规范，它融合了哲学中的本体的概念，研究世界上的各种实体以及它们是如何关联的。OWL是对RDFS的一种扩展，弥补了RDFS在表达能力的一些缺陷。OWL也是遵循RDF规范的，比RDF更加严谨，丰富了属性以及属性约束，定义域、值域的约束等等。</p><p>OWL又分为OWL Lite、OWL DL和OWL Full三个子语言。OWL Lite是最简单的OWL，可以看作是OWL Full的简化版本。OWL DL在OWL Lite的基础上，包括了OWL的所有属性约束。OWL Full允许在预定义的词汇上增加词汇，导致逻辑蕴含不可判定。</p><p>OWL的新版本是OWL2，OWL2也有三个子语言，OWL2 QL、OWL2 EL和OWL2 RL，OWL2 QL代表Query Language，专为基于本体的查询设计，可以使用标准关系型数据库技术（例如SQL）来实现，仅需要依据公理扩展查询。OWL2 EL为概念术语描述、推理而设计，拥有一个具备相对表达力的类表达式语言，并且对类表达式如何可以用在公理中没有限制。应用在大型生物健康本体模型的构建中。OWL2 RL面向需要可扩展又不能牺牲太多表达能力的应用程序，被设计用来适应可以牺牲语言的完整表达力以换取效率的OWL2应用程序，以及需要一些来自OWL2的额外表达力的RDF（S）应用程序。</p><p>OWL和OWL2属于W3C推荐的语义网数据模型组织语言，结构严谨，逻辑全面，但在实际的企业级应用中较少使用，主要是因为OWL相对来说比较复杂，不如直接使用Turtle或者N-Triples来的方便。</p><p>参考资料：</p><p>1 <a href="https://www.w3.org/DesignIssues/LinkedData.html">https://www.w3.org/DesignIssues/LinkedData.html</a></p><p>2 <a href="https://zhuanlan.zhihu.com/p/32122644">https://zhuanlan.zhihu.com/p/32122644</a></p><p>3 <a href="https://my.oschina.net/airship/blog/920020">https://my.oschina.net/airship/blog/920020</a></p>]]></content:encoded>
      
      
      <category domain="https://congyx.com/categories/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/">知识图谱</category>
      
      
      <category domain="https://congyx.com/tags/%E7%9F%A5%E8%AF%86%E8%A1%A8%E7%A4%BA/">知识表示</category>
      
      
      <comments>https://congyx.com/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5-%E4%B8%89/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>知识图谱实践(二)</title>
      <link>https://congyx.com/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5-%E4%BA%8C/</link>
      <guid>https://congyx.com/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5-%E4%BA%8C/</guid>
      <pubDate>Thu, 11 Aug 2022 07:40:44 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;知识图谱数据模型的构建&quot;&gt;&lt;a href=&quot;#知识图谱数据模型的构建&quot; class=&quot;headerlink&quot; title=&quot;知识图谱数据模型的构建&quot;&gt;&lt;/a&gt;知识图谱数据模型的构建&lt;/h1&gt;&lt;p&gt;数据模型就是数据组织方式，是构建知识图谱首要解决的问题，无论是开放域的知识图谱还是行业的知识图谱，都需要收集大量的数据，这些数据的收集是有选择性的，这个选择的依据就是数据模型。数据模型，也可以称为知识表达模型，解决知识图谱如何组织数据的问题，是数据的底层架构，是一个知识体系框架，能够涵盖住知识图谱所有的数据，决定了数据收集的范围。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="知识图谱数据模型的构建"><a href="#知识图谱数据模型的构建" class="headerlink" title="知识图谱数据模型的构建"></a>知识图谱数据模型的构建</h1><p>数据模型就是数据组织方式，是构建知识图谱首要解决的问题，无论是开放域的知识图谱还是行业的知识图谱，都需要收集大量的数据，这些数据的收集是有选择性的，这个选择的依据就是数据模型。数据模型，也可以称为知识表达模型，解决知识图谱如何组织数据的问题，是数据的底层架构，是一个知识体系框架，能够涵盖住知识图谱所有的数据，决定了数据收集的范围。<span id="more"></span></p><h2 id="数据的分类问题"><a href="#数据的分类问题" class="headerlink" title="数据的分类问题"></a>数据的分类问题</h2><p>通用知识图谱，它收集的数据比较全，涉及到各种各样的知识。我们可以把通用知识图谱认为是一个大而全的知识图谱，它基本能涵盖所有的知识，当然，这类通用知识图谱，由于涵盖的知识范围广，所有对于某一个知识点，可能不会说的特别细，也就是深度不够。行业知识图谱和通用知识图谱，正好是一个互补的关系，行业知识图谱是对某一个行业的知识，组织的很专业，研究的很深入。</p><p>无论是通用知识图谱还是行业知识图谱，都存在数据的组织问题，首要的就是数据如何分类，可以画一个树状图，根节点为物体或者对象，就是包含万物，然后再一层层的进行分类，知识图谱中的所有知识都可以在树状图中找到对应的节点。</p><p>下面我们以百科数据为例，介绍一下知识图谱的分类问题。其它通用知识图谱，也有自己的分类体系，和百科的分类大同小异，但也有自己的一些特点。</p><p>百科知识的组织，第一层分类为艺术、科学、自然、文化、地理、生活、社会、人物、经济、体育、历史等。</p><img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5-%E4%BA%8C/image-20220811154643178.png" alt="image-20220811154643178" style="zoom: 80%;"><p>选择一个分类，比如科学分类，就能看到第二层分类科学的分类体系，包括健康医疗、航空航天、天文学、环境生态、农业科学、生命科学、数理科学、心理学、信息科学、工程技术、化学、地球科学、其它等。</p><img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5-%E4%BA%8C/935893-20190707092245915-343172619.png" alt="img" style="zoom:80%;"><p>再继续选择，比如健康医疗，就可以看到第三层的分类，医学知识库的知识分类情况，从医疗症状、药物、中医药、诊断技术等几个维度来组织医学知识。</p><img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5-%E4%BA%8C/935893-20190707092301166-1243899689.png" alt="img" style="zoom:80%;"><p>通过这种分类体系，就会发现，无论收集什么知识，我们都可以在体系中找到对应的分类，这样有利于大家在这个知识图谱中查找知识，也有利于添加知识，扩展知识图谱的数据内容。</p><h2 id="数据的属性"><a href="#数据的属性" class="headerlink" title="数据的属性"></a>数据的属性</h2><p>对于数据组织体系，在分类到末端节点，也就是叶子节点，就需要对这个叶子节点（具体知识点）进行描述，如何将一个知识点描述清楚，在知识图谱中，需要使用属性来描述知识点。这些属性可以从多个方面，多个层次来描述事物。</p><p>我们还是以百科数据为例，在医学知识库中，找到叶子知识点，比如糖尿病， 词条中最重要的一个是定义或者叫做简介，说明什么是糖尿病，然后是几个主要属性，英文名称、常见症状、就诊科室、传染性等。把这些属性放到最开始的位置，人们看到后，就可以对糖尿病有一个大致的了解，这些属性也能够简单反映糖尿病这个知识点的基本情况。</p><p><img src="/../resources%5Cimage-20220811154917144.png" alt="image-20220811154917144"></p><p>除了基本的属性，对于糖尿病这个知识点，还有更多的描述，百科是从病因、检查、鉴别诊断、临床表现、诊断、治疗这几个维度，来阐述糖尿病，通过这些更进一步的属性，人们就会对糖尿病有一个更深入的了解。</p><img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5-%E4%BA%8C/image-20220811154935746.png" alt="image-20220811154935746" style="zoom:80%;"><p>下面我们再继续来看一下，检查这个属性，都包括哪些内容。百科中列出了比较多的检查项目或者称为检查内容，血糖、尿糖、尿酮体、糖基化血红蛋白（HbA1c）、糖化血清蛋白等等，而且对于每一项检查内容，都有一个简短的说明。</p><p><img src="/../resources%5Cimage-20220811155001033.png" alt="image-20220811155001033"></p><p>上面的属性，就是百科对于疾病症状的知识组织方式，我们可以看一下其他的疾病症状，基本上都是按照这个方式，来组织属性数据。糖尿病这个疾病症状，通过一些属性，还可以关联到其它词条，比如检查内容中的血糖。这样就可以在知识点之间建立关联，形成一个网状的知识图谱。</p><h2 id="数据模型的构建过程"><a href="#数据模型的构建过程" class="headerlink" title="数据模型的构建过程"></a>数据模型的构建过程</h2><p>在构建数据模型的实践中，基本上都会找一个类似的知识体系，或者粗略的数据分类体系，然后以其为基础，再进行扩展。当然，在收集数据的过程中，也可能会收集到大量脱离数据模型的数据，这时候，就可以根据这些数据进行数据模型的修改和完善。</p><p>构建数据模型的初始阶段，可以找一个知识图谱的中心数据，比如构建一个音乐知识图谱，可以以歌曲为中心，先考虑歌曲的属性，比如演唱者、作词、作曲、分类、歌词、乐谱等等，对于这些属性，一方面是考虑在知识图谱中是否合适，需要不断地斟酌，修改、增加或者删除一些属性，从而达到完善属性的目的。另一方面，还要确定这些属性对应的属性值，比如演唱者、作词、作曲都是对应的人，人也是一种实体，也会有很多属性，比如出生日期、性别、姓名、籍贯、主要事迹、作品等等，对于人的属性，又可以开启属性论证工作，确定使用哪些属性，属性值的范围等。</p><p>在不断确定属性和属性值范围的过程中，我们还要明确一个边界。因为对于这种关联关系，可以一直做下去，最后都会变成一个万物互联的通用知识图谱。我们有的时候，可能是构建一个行业知识图谱，这时候，边界的确定就很重要，比如出生日期，对于古代人，就不能写成年月日的形式，可能就是一个朝代，这个朝代也是一个实体，我们就没有必要再对朝代进行属性和属性值的确定。因为朝代对于我们知识图谱来说，已经是相关性很小的知识了。对于朝代这类和知识图谱相关性比较弱的知识实体来说，我们才觉得办法，最简单的处理就是直接写一个名称，将它看作一个字符串或者是一个枚举值，作为枚举值的话，需要罗列出所有的朝代。另外一种处理方法就是将包含的朝代链接到通用知识图谱，比如百度百科或者dbPedia等公认的通用知识图谱。我们专注于行业知识图谱中，关联性比较强的数据。</p><h2 id="数据模型需要注意的问题"><a href="#数据模型需要注意的问题" class="headerlink" title="数据模型需要注意的问题"></a>数据模型需要注意的问题</h2><p>我们最终构建的数据模型，需要注意两个方面的问题。</p><p>一个是体系的完备性。有类、子类这样的层次关系，实体都能划分到这个层次关系中。类的属性，子属性，每个类都有什么属性，属性之间存在什么样的关系，对于一个属性来说，它可以看作是谓语，主语和宾语的范围如何界定。将类、子类、属性、子属性之间的关系描述清楚，能够把知识图谱中的相关实体都纳入到这个体系中，并且通过属性叙述清楚实体，就表示这个数据模型满足了知识图谱的完备性要求。</p><p>另一个需要注意的是数据模型度的把握。虽然有完备性的要求，但也不能将所有的内容都罗列到数据模型中。对于数据模型中的类和属性，要有所取舍，只选取那些和知识图谱相关性强的类和属性，一开始可以选的粗一些，然后再逐渐细化。也可以一开始就做的比较细致，后面再进行删减，最后形成一个内容适当的数据模型。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>现在构建知识图谱数据模型，都有一定的依据，一般不会从零开始，有一个雏形作为数据模型的基础，再进行完善。基本模式是以自顶向下为主，再根据收集的数据，对数据模型进行修正，也就是自底向上为辅，这样的构建方式比较普遍。</p>]]></content:encoded>
      
      
      <category domain="https://congyx.com/categories/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/">知识图谱</category>
      
      
      <category domain="https://congyx.com/tags/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/">知识图谱</category>
      
      
      <comments>https://congyx.com/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5-%E4%BA%8C/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>知识图谱实践</title>
      <link>https://congyx.com/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5/</link>
      <guid>https://congyx.com/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5/</guid>
      <pubDate>Thu, 11 Aug 2022 07:28:28 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;知识图谱的演化过程&quot;&gt;&lt;a href=&quot;#知识图谱的演化过程&quot; class=&quot;headerlink&quot; title=&quot;知识图谱的演化过程&quot;&gt;&lt;/a&gt;知识图谱的演化过程&lt;/h1&gt;&lt;p&gt;知识图谱是一个包含很多技术内容的知识体系，总的来说，是处理关联的知识，核心是数据，但强调了数据之间的关联关系。简单来看，可以认为是数据库或知识库，和语义网有着千丝万缕的联系。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="知识图谱的演化过程"><a href="#知识图谱的演化过程" class="headerlink" title="知识图谱的演化过程"></a>知识图谱的演化过程</h1><p>知识图谱是一个包含很多技术内容的知识体系，总的来说，是处理关联的知识，核心是数据，但强调了数据之间的关联关系。简单来看，可以认为是数据库或知识库，和语义网有着千丝万缕的联系。<span id="more"></span>知识图谱是由谷歌首先提出来的，用于优化它的搜索能力，之后，获得了蓬勃的发展，研究的人也越来越多。</p><p>知识图谱的出现，不是一蹴而就的，有一个缓慢演进的过程，包括现在，也还在发展中。知识图谱的发展，可以从多个方面进行阐述，比如开放链接数据的思想，知识表示，知识推理，知识存储等，伴随着信息技术特别是人工智能技术的发展，知识图谱不断融合新的技术，不断发展和完善。此处主要讲述知识图谱理论的形成过程。</p><img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5/image-20220811162038819.png" alt="image-20220811162038819" style="zoom: 50%;"><p>Knowledge is a familiarity, awareness, or  understanding of someone or something,  such as facts, information, descriptions, or  skills, which is acquired through experience or education by perceiving, discovering, or  learning.    ——–维基百科</p><h2 id="信息及其Memex"><a href="#信息及其Memex" class="headerlink" title="信息及其Memex"></a>信息及其Memex</h2><p>1945年，一个美国科学家Vannevar Bush在《大西洋月刊》上发表了一篇文章《As We May Think》，提出一种信息机器的构想，就像下图中的样子。</p><img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5/image-20220811153233326.png" alt="image-20220811153233326" style="zoom:67%;"><p>在Bush博士的设想中，这种机器还可以与图书馆联网。通过某种机制，将图书馆收藏的胶卷，自动装载到本地机器上。因此，只通过这一个机器，就可以实现海量的信息检索。他将这种机器命名为Memex，也就是“memory extender”这两个单词词首的组合，意思是“记忆的延伸”。这个设想的影响非常大，后来许多早期的计算机论文中都提到了这个机器。然后，文中关于信息切换的描述，直接启发了“超文本协议”（hypertext）的发明。现在，我们在互联网上不同的链接之间跳转，其源头都可以追溯到这篇文章。</p><h2 id="以超链接为主的WEB"><a href="#以超链接为主的WEB" class="headerlink" title="以超链接为主的WEB"></a>以超链接为主的WEB</h2><p>1989年3 月，蒂姆·伯纳·李爵士（Tim Berners-Lee）向CERN递交了一份立项建议书，建议采用超文本技术（Hypertext）把CERN内部的各个实验室连接起来，在系统建成后，将可能扩展到全世界。</p><img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5/935893-20190707091638679-2026270082.png" alt="img" style="zoom:67%;"><p>文中说明了超文本利用圆圈和箭头可以自由的描述任何事物，比使用层级结构的表格要灵活的多，特别是描述复杂系统，作用更加突出，这就是超文本的作用。这个思想也是现在比较流行的思维导图的核心思想，利用发散思维，建立联系。</p><h2 id="已链接数据为核心的语义网"><a href="#已链接数据为核心的语义网" class="headerlink" title="已链接数据为核心的语义网"></a>已链接数据为核心的语义网</h2><p>语义网的概念也是由万维网联盟的蒂姆在1998年提出，它的核心是通过给万维网上的文档 （如：HTML文档、XML文档）添加能够被计算机所理解的语义“元数据”（外语：Meta data），从而使整个互联网成为一个通用的信息交换媒介。</p><p>语义网不同于现在WWW，现有的WWW是面向文档而语义网则面向文档所表示的数据，而语义网更重视于计算机“理解与处理”，并且具有一定的判断、推理能力。</p><p>2006年蒂姆·伯纳斯-李在普林斯顿大学演讲和后期接受媒体采访时公开表示，他最初将这种智能网络命名为语义网或许不够贴切，也许更准确的名称应该是数据网（外语：Data Web）。</p><img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5/935893-20190707091712841-1987031174.png" alt="img" style="zoom:67%;"><h2 id="谷歌知识图谱-things-not-strings"><a href="#谷歌知识图谱-things-not-strings" class="headerlink" title="谷歌知识图谱,things,not strings"></a>谷歌知识图谱,things,not strings</h2><p>链接数据不断积累，数据量以几何量级增长，如何更好的使用这些数据，搜索引擎公司Google提出了知识图谱的概念。辛格博士曾经说过，The world is not made of strings , but is made of things. </p><p>知识图谱的提出，目的在于更好的利用开放链接数据，将搜索字符串变为搜索真实世界中的事物，将一个事物通过内部特征（属性）和外部联系（关系），立体的呈现在人们面前，将知识图谱看作一张以关联关系为主的巨大图谱，图谱中，点代表客观事物，边代表了事物的属性或关系。</p><img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5/935893-20181229144559553-575365779.png" alt="img" style="zoom: 50%;">]]></content:encoded>
      
      
      <category domain="https://congyx.com/categories/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/">知识图谱</category>
      
      
      <category domain="https://congyx.com/tags/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/">知识图谱</category>
      
      
      <comments>https://congyx.com/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AE%9E%E8%B7%B5/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
