<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>SpringBoot</title>
    <url>/2022/03/09/SpringBoot/</url>
    <content><![CDATA[<p>SpringBoot是整合Spring技术栈的一站式框架</p>
<p>SpringBoot是简化Spring技术栈的快速开发脚手架<span id="more"></span></p>
<h3 id="SpringBoot特点"><a href="#SpringBoot特点" class="headerlink" title="SpringBoot特点"></a>SpringBoot特点</h3><h4 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h4><p>父项目依赖管理</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">依赖管理    </span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">父项目</span><br><span class="line"> <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>start 场景启动器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">1	spring-boot-starter-* ： *就某种场景</span><br><span class="line">2	只要引入starter，这个场景的所有常规需要的依赖我们都自动引入</span><br><span class="line">3	SpringBoot所有支持的场景</span><br><span class="line">https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter</span><br><span class="line">4	 *-spring-boot-starter： 第三方为我们提供的简化开发的场景启动器。</span><br><span class="line">5	所有场景启动器最底层的依赖</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>自动配置 Tomcat</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    &lt;/dependency</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line">等同于</span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;xxx.xxx.xxx&quot;)</span></span><br></pre></td></tr></table></figure>



<h3 id="容器功能"><a href="#容器功能" class="headerlink" title="容器功能"></a>容器功能</h3><h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><p><strong>@Configuration</strong></p>
<ul>
<li>Full模式于Lite模式<ul>
<li>配置类组件之间无依赖关系用Lite模式加速容器启动过程，减少判断</li>
<li>配置类组件之间有依赖关系，方法会被调用得到之前单实例组件，用Full模式</li>
</ul>
</li>
</ul>
<p>1、配置类里面使用@Bean标注在方法上给容器注册组件，默认也是单实例的</p>
<p>2、配置类本身也是组件</p>
<p>3、proxyBeanMethods：代理bean的方法</p>
<ul>
<li>Full(proxyBeanMethods &#x3D; true)、【保证每个@Bean方法被调用多少次返回的组件都是单实例的】</li>
<li>Lite(proxyBeanMethods &#x3D; false)【每个@Bean方法被调用多少次返回的组件都是新创建的】</li>
<li>组件依赖必须使用Full模式默认。其他默认是否Lite模式</li>
</ul>
<p><strong>@Bean、@Component、@Controller、@Service、@Repository</strong></p>
<p><strong>@ComponentScan、@Import</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;User.class,DBHelper.class&#125;)</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Myconfig</span>()&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@Conditional</strong></p>
<p>条件装配 @Conditional：满足Conditional指定的条件，进行组件注入</p>
<h4 id="原生配置文件引入"><a href="#原生配置文件引入" class="headerlink" title="原生配置文件引入"></a>原生配置文件引入</h4><p><strong>@ImportResource</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">======================beans.xml=========================</span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;haha&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.boot.bean.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;zhangsan&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hehe&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.boot.bean.Pet&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;tomcat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ImportResource(&quot;classpath:beans.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">======================测试=================</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">haha</span> <span class="operator">=</span> run.containsBean(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">hehe</span> <span class="operator">=</span> run.containsBean(<span class="string">&quot;hehe&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;haha：&quot;</span>+haha);<span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;hehe：&quot;</span>+hehe);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>



<h4 id="配置绑定"><a href="#配置绑定" class="headerlink" title="配置绑定"></a>配置绑定</h4><p>读取properties文件中内容，封装到JavaBean中</p>
<p><strong>@ConfigurationProperties</strong></p>
<p><strong>@EnableConfigurationProperties + @ConfigurationProperties</strong></p>
<p><strong>@Component + @ConfigurationProperties</strong></p>
<h3 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h3><p><strong>SpringBootConfiguration</strong></p>
<p>@Configuration。代表当前是一个配置类</p>
<p><strong>@ComponentScan</strong></p>
<p>指定扫描</p>
<p><strong>@EnableAutoConfiguration</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>@AutoConfigurationPackage</strong></p>
<p>自动配置包，指定默认的包规则。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(AutoConfigurationPackages.Registrar.class)</span>  <span class="comment">//给容器中导入一个组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoConfigurationPackage &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用Registrar给容器中导入一系列组件</span></span><br><span class="line"><span class="comment">//将指定的一个包下的所有组件导入进来？MainApplication 所在包下。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>@Import(AutoConfigurationImportSelector.class)</strong></p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、利用getAutoConfigurationEntry(annotationMetadata);给容器中批量导入一些组件</span><br><span class="line"><span class="number">2</span>、调用List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes)获取到所有需要导入到容器中的配置类</span><br><span class="line"><span class="number">3</span>、利用工厂加载 Map&lt;String, List&lt;String&gt;&gt; <span class="title function_">loadSpringFactories</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span>；得到所有的组件</span><br><span class="line"><span class="number">4</span>、从META-INF/spring.factories位置来加载一个文件。</span><br><span class="line">	默认扫描我们当前系统里面所有META-INF/spring.factories位置的文件</span><br><span class="line">    spring-boot-autoconfigure-<span class="number">2.3</span><span class="number">.4</span>.RELEASE.jar包里面也有META-INF/spring.factories</span><br><span class="line">    </span><br></pre></td></tr></table></figure>







<p><strong>蠢事：</strong>忘记填写@RestController</p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><h4 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h4><p>“YAML Ain’t Markup Language”</p>
<h4 id="yaml"><a href="#yaml" class="headerlink" title="yaml"></a>yaml</h4><p>适合用来做以数据为中心的配置文件</p>
<p><strong>自定义的类和配置文件绑定一般没有提示</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">exclude</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="静态资源访问"><a href="#静态资源访问" class="headerlink" title="静态资源访问"></a>静态资源访问</h3><h4 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h4><p>静态资源放在类路径下：called <code>/static</code> (or <code>/public</code> or <code>/resources</code> or <code>/META-INF/resources</code></p>
<p>访问：当前项目根路径&#x2F; + 静态资源名</p>
<p><strong>原理：</strong>静态映射&#x2F;**</p>
<p>请求进来，先去找Controller看能不能处理。不能处理的所有请求又都交给静态资源处理器。静态资源也找不到则响应404页面。</p>
<p>改变默认的静态资源路径</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">static-path-pattern:</span> <span class="string">/res/**</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">static-locations:</span> [<span class="string">classpath:/haha/</span>]</span><br></pre></td></tr></table></figure>

<h4 id="欢迎页"><a href="#欢迎页" class="headerlink" title="欢迎页"></a>欢迎页</h4><p>静态资源路径下配置 index.html</p>
<ul>
<li>可以配置静态资源路径</li>
<li>需要注意的是，如果配置了静态资源的访问前缀，会导致 index.html 不能被默认访问</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="comment">#  mvc:</span></span><br><span class="line"><span class="comment">#    static-path-pattern: /res/**   导致welcome page功能失效</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">static-locations:</span> [<span class="string">classpath:/haha/</span>]</span><br></pre></td></tr></table></figure>

<h4 id="自定义-Favicon"><a href="#自定义-Favicon" class="headerlink" title="自定义 Favicon"></a>自定义 Favicon</h4><p>favicon.io 放在静态资源目录</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="comment">#  mvc:</span></span><br><span class="line"><span class="comment">#    static-path-pattern: /res/**   这个会导致 Favicon 功能失效</span></span><br></pre></td></tr></table></figure>

<h4 id="静态资源配置原理"><a href="#静态资源配置原理" class="headerlink" title="静态资源配置原理"></a>静态资源配置原理</h4><ul>
<li>SpringBoot启动默认加载  xxxAutoConfiguration 类（自动配置类）</li>
<li>SpringMVC功能的自动配置类 WebMvcAutoConfiguration，生效</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>String、StringBuffer、StringBuilder之间的联系</title>
    <url>/2022/06/05/String%E3%80%81StringBuffer%E3%80%81StringBuilder%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB/</url>
    <content><![CDATA[<p>今天做题遇见 <strong>反转字符串中的单词</strong> 这道题，给定一个字符串需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。题目链接：<a href="https://leetcode.cn/problems/reverse-words-in-a-string-iii/">557. 反转字符串中的单词 III - 力扣（LeetCode）</a>。<span id="more"></span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;Let&#x27;s take LeetCode contest&quot;</span><br><span class="line">输出：&quot;s&#x27;teL ekat edoCteeL tsetnoc&quot;</span><br><span class="line"></span><br><span class="line">输入： s = &quot;God Ding&quot;</span><br><span class="line">输出：&quot;doG gniD&quot;</span><br></pre></td></tr></table></figure>

<p>做题过程中，发现自己忘记了字符串的一些知识，所谓温故而知新。在此记录复习。</p>
<p>在 java 中字符串属于对象，Java 提供了 String 类来创建和操作字符串。String 类是不可变类，即一旦一个 String 对象被创建以后，包含在这个对象中的字符序列是不可改变的，直至这个对象被销毁。</p>
<p>Java 提供了两个可变字符串类 <strong>StringBuffer</strong> 和 <strong>StringBuilder</strong>，中文翻译为“字符串缓冲区”。</p>
<p>StringBuilder 类是 JDK 1.5 新增的类，它也代表可变字符串对象。实际上，StringBuilder 和 StringBuffer 功能基本相似，方法也差不多。不同的是，StringBuffer 是线程安全的，而 StringBuilder 则没有实现线程安全功能，所以性能略高。因此在通常情况下，如果需要创建一个内容可变的字符串对象，则应该优先考虑使用 StringBuilder 类。</p>
<p>StringBuffer、StringBuilder、String 中都实现了 CharSequence 接口。CharSequence 是一个定义字符串操作的接口，它只包括 length()、charAt(int index)、subSequence(int start, int end) 这几个 API。</p>
<p>StringBuffer、StringBuilder、String 对 CharSequence 接口的实现过程不一样，</p>
<img src="/2022/06/05/String%E3%80%81StringBuffer%E3%80%81StringBuilder%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB/image-20220605122937245.png" alt="image-20220605122937245" style="zoom:80%;">

<p><strong>String、StringBuffer、StringBuilder 之间的区别：</strong></p>
<img src="/2022/06/05/String%E3%80%81StringBuffer%E3%80%81StringBuilder%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB/image-20220605122516694.png" alt="image-20220605122516694" style="zoom:80%;">

<p><strong>String:</strong></p>
<p>对于String来说，是把数据存放在了常量池中，因为所有的String，默认都是以常量形式保存，且由final修饰，因此在线程池中它是线程安全的。因为每一个String当被创建好了以后，他就不再发生任何变化，但是它的执行速度是最差的。</p>
<p>我们要创建String的时候，他在常量池中对这些信息进行处理，如果在程序中出现了大量字符串拼接的工作，效率是非常底下的。<br>因此使用场景是在少量字符串操作的时候才建议直接使用String来操作。</p>
<p><strong>StringBuffer:</strong></p>
<p>StringBuffer相对于StringBuilder效率要相对低一点，但也远比String要高的多。效率低的原因：对于StringBuffer来说更多的考虑到了多线程的情况，在进行字符串操作的时候，它使用了synchronize关键字，对方法进行了同步处理。因此StringBuffer适用于多线程环境下的大量操作。</p>
<p><strong>StringBuilder:</strong></p>
<p>线程安全与线程不安全：<br>在进行多线程处理的时候，如果多个线程对于这一个对象同时产生操作，会产生预期之外的结果。对于StringBuilder来说，执行效率虽然高，但是因为线程不安全，所以不建议在多线程的环境下对同一个StringBuilder对象进行操作。因此StringBuilder适用于单线程环境下的大量字符串操作。</p>
<p><strong>参考：</strong><a href="http://c.biancheng.net/view/5822.html">String、StringBuffer和StringBuilder类的区别 (biancheng.net)</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Matplotlib数据可视化</title>
    <url>/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    <content><![CDATA[<h1 id="Matplotlib数据可视化"><a href="#Matplotlib数据可视化" class="headerlink" title="Matplotlib数据可视化"></a>Matplotlib数据可视化</h1><p>Python语言的matplotlib扩展包是一个提供了跨平台的2D 图形库，它可以将数据用多种形式展示出来。Matplotlib可画出折线图，柱状图，饼图，雷达图等。在matplotlib的官网上给出了500多个图表展示的例子程序 (<a href="https://matplotlib.org/gallery/index.html)%E3%80%82">https://matplotlib.org/gallery/index.html)。</a><span id="more"></span></p>
<p>Matplotlib提供了两种编程风格，一种是函数式绘图，这种方式参考了matlab里面的绘图函数语法。另一种是面向对象式绘图，这种方式更接近Matplotlib的底层架构，更能理 解细节。matplotlib.pyplot是一个函数式绘图的函数集合， 其中每一个pyplot的函数都对图进行一些改动，例如创建图， 画点或线，以及增加标签等。在面向对象方式中， matplotlib.axes.Axes和matplotlib.figure.Figure是最主要的两 个对象，分别表示坐标轴和图。这种模式下，通常使用 pyplot.subplots创建一个图和多个坐标轴，并在此基础上调用相关对象的方法绘制图。</p>
<p>Matplotlib模块依赖于NumPy和tkinter模块，可以绘制多 种形式的图形，包括线图、直方图、饼图、散点图等，图形质量满足出版要求，是数据可视化的重要工具。Matplotlib 中应用最广的是matplotlib.pyplot模块。Pyplot提供了一套和 Matlab类似的绘图API，使得Matplotlib的机制更像Matlab。 我们只需要调用Pyplot模块所提供的函数就可以实现快速绘图并设置图表的各个细节。</p>
<img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503093033761.png" alt="image-20220503093033761" style="zoom:67%;">

<p><strong>标题：</strong>plt.title()</p>
<p><strong>轴标签：</strong>plt.xlable(); plt.ylabel()</p>
<p><strong>轴刻度标签：</strong>plt.xticks(); plt.yticks()</p>
<p><strong>显示图像：</strong>plt.show()</p>
<p><strong>显示图例：</strong>plt.legend()</p>
<p><strong>数值标签：</strong>plt.text()</p>
<p><strong>轴刻度范围：</strong>plt.xlim(); plt.ylim()</p>
<p><strong>以一个简单的正弦函数为例说明图表的绘制方法。</strong></p>
<p>程序首先准备了x，y两个数组，x是0~720度，y是对应的 正弦函数值。使用axis函数设定x，y坐标轴的起止范围， plot函数画出正弦曲线，xticks指定x轴的小刻度标示。xlabel 和ylabel分别是x，y轴的主题，title设置了图表的主题。</p>
<img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503093443680.png" alt="image-20220503093443680" style="zoom: 67%;">

<p>figure（）：创建一个新的绘图窗口。  </p>
<p>figtext（）：为figure添加文字  </p>
<p>axes（）：为当前figure添加一个坐标轴 </p>
<p>plot（）：绘图函数  </p>
<p>polar（）：绘制极坐标图  </p>
<p>axis（）：获取或设置轴属性的边界方法（坐标的取值 范围） </p>
<p>clf ： 清除当前figure窗口  </p>
<p>cla ： 清除当前axes窗口  </p>
<p>close ： 关闭当前figure窗口  </p>
<p>subplot ： 一个图中包含多个axes </p>
<p>text（）： 在轴上添加文字</p>
<p>title（）： 设置当前axes标题  </p>
<p>xlabel&#x2F;ylabel：设置当前X轴或Y轴的标签  </p>
<p>hist（）：绘制直方图  </p>
<p>hist2d（）：绘制二维直方图  </p>
<p>hold ：设置当前图窗状态；</p>
<p>off或者on  imread（）：读取一个图像，从图形文件中提取数组 </p>
<p>legend（）：为当前axes放置标签  </p>
<p>pie（）：绘制饼状图 </p>
<p>scatter（）：做一个X和Y的散点图，其中X和Y是相同长 度的序列对象  </p>
<p>stackplot（）：绘制一个堆叠面积图 </p>
<p>acorr（）：绘制X的自相关函数  </p>
<p>annotate（）：用箭头在指定的数据点创建一个注释或 一段文本 </p>
<p>bar（）：绘制垂直条形图  </p>
<p>barh（）：绘制横向条形图  </p>
<p>barbs（）：绘制一个倒钩的二维场 </p>
<h2 id="图表类型："><a href="#图表类型：" class="headerlink" title="图表类型："></a>图表类型：</h2><h3 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pie</span>(<span class="params">x, explode=<span class="literal">None</span>, labels=<span class="literal">None</span>, colors=<span class="literal">None</span>, autopct=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params"> pctdistance=<span class="number">0.6</span>, shadow=<span class="literal">False</span>, labeldistance=<span class="number">1.1</span>, startangle=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params"> radius=<span class="literal">None</span>, counterclock=<span class="literal">True</span>, wedgeprops=<span class="literal">None</span>, textprops=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params"> center=(<span class="params"><span class="number">0</span>, <span class="number">0</span></span>), frame=<span class="literal">False</span>, hold=<span class="literal">None</span>, data=<span class="literal">None</span></span>): </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>x：</strong>(每一块)的比例，如果sum(x) &gt; 1会使用sum(x)归一化；</p>
<p><strong>labels：</strong>(每一块)饼图外侧显示的说明文字；</p>
<p><strong>explode：</strong>(每一块)离开中心距离；</p>
<p><strong>startangle：</strong>起始绘制角度,默认图是从x轴正方向逆时针画起,如设定&#x3D;90 则从y轴正方向画起；</p>
<p><strong>shadow：</strong>在饼图下面画一个阴影。默认值：False，即不画阴影；</p>
<p><strong>labeldistance：</strong>label标记的绘制位置,相对于半径的比例，默认值为1.1, 如&lt;1则绘制在饼图内侧；</p>
<p><strong>autopct：</strong>控制饼图内百分比设置,可以使用format字符串或者 formatfunction </p>
<p>**’%1.1f’**指小数点前后位数(没有用空格补齐)；</p>
<p><strong>pctdistance：</strong>类似于labeldistance,指定autopct的位置刻度,默认值为0.6；</p>
<p><strong>radius：</strong>控制饼图半径，默认值为1；</p>
<p><strong>counterclock：</strong>指定指针方向；布尔值，可选参数，默认为：True， 即逆时针。将值改为False即可改为顺时针。</p>
<p><strong>wedgeprops：</strong>字典类型，可选参数，默认值：None。参数字典传递给wedge对象用来画一个饼图。例如：wedgeprops&#x3D;{‘linewidth’:3}设置wedge线宽为3。</p>
<p><strong>textprops：</strong>设置标签（labels）和比例文字的格式；字典类型，可 选参数，默认值为：None。传递给text对象的字典参数。</p>
<p><strong>center：</strong>浮点类型的列表，可选参数，默认值：(0,0)，图标中心位置。 </p>
<p><strong>frame：</strong>布尔类型，可选参数，默认值：False。如果是true，绘制带有表的轴框架。</p>
<p><strong>rotatelabels：</strong>布尔类型，可选参数，默认为：False。如果为True， 旋转每个label到指定的角度。 </p>
<img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503130121640.png" alt="image-20220503130121640" style="zoom:67%;">

<h3 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hist</span>(<span class="params">x,bins=<span class="literal">None</span>,<span class="built_in">range</span>=<span class="literal">None</span>,normed=<span class="literal">False</span>,weights=<span class="literal">None</span>,cumulative=<span class="literal">False</span>,bottom=<span class="literal">None</span>, histtype=<span class="string">&#x27;bar&#x27;</span>, align=<span class="string">&#x27;mid&#x27;</span>, orientation=<span class="string">&#x27;vertical&#x27;</span>,rwidth=<span class="literal">None</span>, log=<span class="literal">False</span>, color=<span class="literal">None</span>, label=<span class="literal">None</span>, stacked=<span class="literal">False</span>,hold=<span class="literal">None</span>, data=<span class="literal">None</span>, **kwargs</span>):</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>x：</strong>数据集，最终的直方图将对数据集进行统计；</p>
<p><strong>bins：</strong>指定直方图条形的个数； </p>
<p><strong>range：</strong>显示的区间； </p>
<p><strong>normed：</strong>标准化，是否将直方图的频数转换成频率；</p>
<p><strong>density：</strong>显示的是频数统计结果，默认为false，为True则显示频 率统计结果，这里需要注意，频率统计结果&#x3D;区间数目&#x2F;(总数*区间宽 度)，和normed效果一致，官方推荐使用density；</p>
<p><strong>histtype:</strong> 指定直方图的类型，可选{‘bar’, ‘barstacked’,  ‘step’, ‘stepfilled’}之一，默认为bar，推荐使用默认配置，step使用的是梯状，stepfilled则会对梯状内部进行填充，效果与bar类似； </p>
<p><strong>align:</strong> 设置条形边界值的对其方式，可选{‘left’, ‘mid’,  ‘right’}之一，默认为’mid’，还有 left或者right，会有部分空白区域，推荐使用默认；</p>
<p><strong>orientation：</strong>水平或垂直方向[‘horizontal’,’vertical’]，默认为垂直方向；</p>
<p><strong>rwidth：</strong>柱子与柱子之间的距离，默认是0；</p>
<p><strong>log：</strong>是否需要对绘图数据进行log变换，默认False；</p>
<p><strong>stacked：</strong>当有多个数据时，是否需要将直方图呈堆叠摆放，默认水平摆放。 </p>
<p><strong>color：</strong>设置直方图颜色；</p>
<p><strong>label：</strong>设置直方图的标签，可通过legend展示其图例；</p>
<p><strong>bottom：</strong>可以为直方图的每个条形添加基准线，默认为0。</p>
<p>hist函数主要输入一个序列，并指定分为几个区间进行统计。按照 在每个区间内的数据数量绘制图形，展示不同区间的数据数量。</p>
<img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503130612192.png" alt="image-20220503130612192" style="zoom:67%;">

<h3 id="面积图"><a href="#面积图" class="headerlink" title="面积图"></a>面积图</h3><p>面积图可用于绘制随时间发生的变化量，用于引起人们对总值趋势的关注。 通过显示所绘制的值的总和，面积图还可以显示部分与整体的关系。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">stackplot</span>(<span class="params">x, *args, **kwargs</span>):</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>x：</strong>指定面积图的x轴数据；</p>
<p>*args：可变参数，可以接受任意多的y轴数据，即各个拆分的数据对象；</p>
<p>**kargs：关键字参数，可以通过传递其他参数来修饰面积图， 如标签、颜色，用法与之前的labels、colors用法一致。</p>
<img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503131024940.png" alt="image-20220503131024940" style="zoom:67%;">

<h3 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h3><p>散点图由一些不连续的点组成，用来研究两个变量的相关性。包括正相关、负相关、不相关。主要通过scatter函数画散点图。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">scatter</span>(<span class="params">x, y, s=<span class="literal">None</span>, c=<span class="literal">None</span>, marker=<span class="literal">None</span>, cmap=<span class="literal">None</span>, norm=<span class="literal">None</span>, </span></span><br><span class="line"><span class="params">vmin=<span class="literal">None</span>, vmax=<span class="literal">None</span>, alpha=<span class="literal">None</span>, linewidths=<span class="literal">None</span>, verts=<span class="literal">None</span>, </span></span><br><span class="line"><span class="params">edgecolors=<span class="literal">None</span>, hold=<span class="literal">None</span>, data=<span class="literal">None</span>, **kwargs</span>):</span><br><span class="line">    </span><br><span class="line"><span class="comment"># x/y：数据，都是向量，而且必须长度相等。</span></span><br><span class="line"><span class="comment"># s：标记大小;以像素点的平方为单位的标记面积，指定为下列形式之一：数值标量：以相同的大小绘制所有标记。行或列向量：使每个标记具有不同的大小。x、y 和 sz向量中的 相应元素确定每个标记的位置和面积。sz向量的长度必须等于 x 和 y 的长度。默认大小为rcParams[&#x27;lines.markersize&#x27;] ** 2。</span></span><br><span class="line"><span class="comment"># c:标记颜色;RGB三元数或颜色名称 - 使用相同的颜色绘制所有标记。由RGB三元数组成的三列矩阵 - 对每个标记使用不同的颜色。矩阵的每行为对应标记指定一种RGB三元数颜色。行数必须等于 x 和 y 的长度;向量 - 对每个标记使用不同的颜色，并以线性方式将 c 中的值映射到当前颜色图中的颜色。c 的长度必须等于 x 和 y 的长度。 要更改坐标区的颜色图，需使用 colormap 函数。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503094758601.png" alt="image-20220503094758601" style="zoom:67%;">

<p><strong>edgecolors：</strong>轮廓颜色和 c 类似，参数也相同 </p>
<p><strong>alpha：</strong>透明度 [0,1]：1不透明，0透明 </p>
<p><strong>cmap：</strong>色彩盘 可以使用默认的也可以使用自定义的，它实际上就是一个三列的矩阵(或者说，shape为 [N, 3]的 array ) </p>
<p>• 矩阵中的值取值范围为 [0. , 1.] </p>
<p>• 每一行代表一个颜色 (RGB) </p>
<p><strong>linewidths：</strong>线宽标记边缘的宽度，默认是没有外围轮廓线。 </p>
<p>注意事项： color、marker等不能同时作为一个参数，plt.scatter(x1, y1, ‘bo’, s&#x3D;5) 不合法。</p>
<p>例：</p>
<p>现在有一组女大学生的身高和体重数据，可以画散点图来观察两组数据之间的关系。</p>
<img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503101252240.png" alt="image-20220503101252240" style="zoom:67%;">

<p>展示正相关，负相关，不相关:</p>
<img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503101325862.png" alt="image-20220503101325862" style="zoom:67%;">

<img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503101341999.png" alt="image-20220503101341999" style="zoom:67%;">

<h3 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h3><p>折线图常用于显示数据序列随时间变化，数据变化的趋势。非常适用于显示在相等时间间隔下数据的走向变化。主要通过plot函数来画折线图。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">plot</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line"><span class="comment"># 其中参数args是一个可变长度参数，允许多个x，y对和一个可选的格式字符串。</span></span><br><span class="line"><span class="comment"># plot(x, y) plot x和y使用默认线条样式和颜色;plot(x, y, &#x27;bo&#x27;) plot x和y使用蓝色圆圈标记;plot(y) plot y使用x作为索引数组0..N-1;plot(y, &#x27;r+&#x27;) 同上，但是用红色加号</span></span><br></pre></td></tr></table></figure>



<p>1.针对线条的处理</p>
<ul>
<li>线条类型</li>
</ul>
<p>​    参数：linestyle或者ls，表示折线的类型，可以是实线、虚线、点虚线、点点线等，即’-‘, ‘–’, ‘-.’, ‘:’等。</p>
<ul>
<li>线条粗细</li>
</ul>
<p>​    参数：linewidth或lw，可自行设置，默认值为1； </p>
<ul>
<li>线条颜色</li>
</ul>
<p>​    参数：color或c ，设置方法和散点图中设置颜色方法一致。</p>
<p>2.针对数据标记的处理</p>
<ul>
<li>参数marker：数据标记的类型</li>
<li>参数markeredgecolor 或 mec：数据标记的边界颜色</li>
<li>参数markeredgewidth 或 mew：数据标记的宽度</li>
<li>参数markerfacecolor 或 mfc：数据标记的填充色 </li>
<li>alpha：接收值为0~1之间的小数，表示点的透明度；</li>
</ul>
<p>3.图例</p>
<p>​    label：表示数据图例内容。参数中label&#x3D;‘数据序列名称’ 指定该数据序列的名称，其后通过调用legend()函数可显示不同数据序列的图例。 </p>
<p><strong>下面以1万元分别存入活期，1年定期，3年定期后， 在30年中的价值变化。2019年的活期，1年定期，3 年定期的利率分别是0.35%，1.50%和2.75%。</strong></p>
<img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503105939185.png" alt="image-20220503105939185" style="zoom:67%;">

<img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503105957260.png" alt="image-20220503105957260" style="zoom:67%;">





<h3 id="条形图"><a href="#条形图" class="headerlink" title="条形图"></a>条形图</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">left, height, width=<span class="number">0.8</span>, bottom=<span class="literal">None</span>, hold=<span class="literal">None</span>, data=<span class="literal">None</span>, **kwargs</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>left：x轴的位置序列，一般采用range函数产生一个序列，  但是有时候可以是字符串；</p>
<p>height：表示条形图的高度，也就是y轴的数值；</p>
<p>alpha：表示柱形图的颜色透明度，默认值为1；</p>
<p>width：表示柱形图的宽度，默认值为0.8；</p>
<p>color（facecolor）：柱形图填充的颜色，默认为随机色；</p>
<p>edgecolor：图形边缘颜色；</p>
<p>label：解释每个图像代表的含义； </p>
<p>linewidth（linewidths &#x2F; lw)：边缘线的宽度，默认值为1。</p>
<p>注意：barh() 函数与 bar() 函数的主要区别是：在  bar() 函数中，width 这一参数代表的是柱子的宽度（胖 瘦），而在 barh() 函数中 width 这一参数代表的是横向 柱子的长度（长短）。 </p>
<p>以2019年各省人口数据为例，数据来源为中国国家统计局 (<a href="http://www.mnw.cn/news/shehui/726472.html)%EF%BC%8C">http://www.mnw.cn/news/shehui/726472.html)，</a> 数据文件为“2019分省人口及GDP.xlsx”。</p>
<img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503133314735.png" alt="image-20220503133314735" style="zoom:67%;">

<p>有时显示在横轴上的数据很多，看起来很不方便。这种 情况下可以采用水平条形图。第一种方法是在<strong>plt.bar函数中指定orientation&#x3D;’horizontal’参数</strong>，第二种方法是是<strong>直接使用plt.barh函数</strong>。使用barh时x轴表示人口数量，y轴表示不同的省份。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.bar(<span class="number">0</span>,bottom=<span class="built_in">range</span>(<span class="built_in">len</span>(province)),width=population,height=<span class="number">0.7</span>,orientation=<span class="string">&#x27;horizontal&#x27;</span>)</span><br></pre></td></tr></table></figure>

<img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503133523695.png" alt="image-20220503133523695" style="zoom:67%;">

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.barh(<span class="built_in">range</span>(<span class="built_in">len</span>(province)),population,height=<span class="number">0.7</span>)</span><br><span class="line">plt.yticks(<span class="built_in">range</span>(<span class="built_in">len</span>(province)),province)</span><br><span class="line">plt.tick_params(labelsize=<span class="number">8</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;人口(万人)&quot;</span>)</span><br></pre></td></tr></table></figure>

<img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503133612570.png" alt="image-20220503133612570" style="zoom:67%;">

<p>其中在调用 bar时 <strong>men_means</strong> 对应的 x 为 <strong>x+width&#x2F;2</strong>, 而 <strong>women_means</strong> 对应的 x 为 <strong>x-width&#x2F;2</strong>。由于指定了不同的 x 位置，两组数据可以并排放置。</p>
<img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503133729426.png" alt="image-20220503133729426" style="zoom:67%;">

<img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503133744725.png" alt="image-20220503133744725" style="zoom:67%;">

<p>垂直堆叠条形图可以用来显示不同类别中各个子 类的比例关系。如大学不同专业中男女生比例。垂 直并列条形图需要通过bottom设置，bottom的坐标是建立在另一个条形图基础上。</p>
<img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/resources/image-20220503133852263.png" alt="image-20220503133852263" style="zoom:67%;">

<p>垂直并列条形图需要通过bottom设置，bottom的坐标是建立在另一个条形图基础上。例子中画womenMeans时，指定的bottom为menMeans，即女生的数据在男生的上方。</p>
<img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503133957605.png" alt="image-20220503133957605" style="zoom:67%;"> 



<h3 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h3><p>有时候需要从不同的角度对比和分析数据。这可以通过将多个图放置在一起进行对比。</p>
<p>通过 <strong>plt.axes</strong> 函数可以创建基本子图，默认情况下它会创建一个标准的坐标轴，并填满整张图。但是可以通过参数指定子图的位置和大小。这个函数的参数是个列表形式，有四个值，从前往后，分别是子图左下角基点的x和y坐标以及子图的宽度和高度，数值的取值范围是0-1之间，画布左下角是（0，0），画布右上角是（1，1）。 </p>
<img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503134233615.png" alt="image-20220503134233615" style="zoom:67%;">

<p>上面是Matlab接口的风格，面向对象画图接口中有类似的 <strong>fig.add_axes()</strong> 方法可以增加新的子图。下面的例子在两个子图里显示了sin和cos的变化趋势。</p>
<img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503134613286.png" alt="image-20220503134613286" style="zoom:67%;">



<p>第二种方式为使用 <strong>plt.subplot</strong> 方法，该方法有三个整数参数，分别表示行数、列数和子图索引值。索引值从1开始， 从左上角到右下角依次自增。<strong>plt.subplots_adjust</strong> 方法可以指定子图的坐标和间距，参数分别为子图上下左右的坐标， 以及间距(wspace)和上下的间距(hspace)。</p>
<img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503134920879.png" alt="image-20220503134920879" style="zoom:67%;">

<p>使用面向对象的方法 <strong>fig.add_subplot()</strong> 也可以实现同样的效果。</p>
<img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503141004086.png" alt="image-20220503141004086" style="zoom:67%;">

<p>使用plt. subplots()方法可以快速地创建多子图环境， 并返回一个包含子图的Numpy数组。通过对返回的ax数组进 行调用，可以操作每个子图，绘制图形。但是需要注意的是， subplot()和subplots()两个方法在方法名上差个字母s外， subplots的索引是从0开始的。另外subplots()方法还可以通过两个布尔型参数sharex和sharey，指定是否只显示最外侧的x或y轴的标签。</p>
<img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503141030820.png" alt="image-20220503141030820" style="zoom:67%;">

<p>对于不规则的子图，可以使用复杂网格的方式进行组织。 复杂网格首先指定一个多行多列的网格，然后每个子图占用相邻的一个或多个网格绘制。</p>
<img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503141203146.png" alt="image-20220503141203146" style="zoom:67%;">

<img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503141215202.png" alt="image-20220503141215202" style="zoom:67%;">

<p><strong>中文显示：</strong></p>
<p>matplotlib绘制图像的时候如指定了中文的坐标轴标签或标题，显示的时候中文字符会显示为小方格子。造成这个现象的原因是matplotlib库的配置信息里面没有中文字体的 相关信息。通过修改matplotlibrc配置文件可设置字体相关参数。但是更常用的方法是在程序中动态设置字体参数。下面的两种方式都可以达到同样的目的。</p>
<p><strong>通过pyplot进行设置：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>]=[<span class="string">&#x27;SimHei&#x27;</span>] <span class="comment">#指定默认字体正确显示中文</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>]=<span class="literal">False</span> <span class="comment">#用来正常显示负号</span></span><br></pre></td></tr></table></figure>

<p><strong>通过pylab进行设置:</strong> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> mpl</span><br><span class="line">mpl.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>]=[<span class="string">&#x27;SimHei&#x27;</span>] <span class="comment">#指定默认字体正确显示中文</span></span><br><span class="line">mpl.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>]=<span class="literal">False</span> <span class="comment">#用来正常显示负号</span></span><br></pre></td></tr></table></figure>

<p>黑体 SimHei</p>
<p>仿宋 FangSong </p>
<p>楷体 KaiTi</p>
<p>微软雅黑 Microsoft YaHei</p>
<p>微软正黑体 Microsoft JhengHei</p>
<h3 id="组合图形与标注"><a href="#组合图形与标注" class="headerlink" title="组合图形与标注"></a>组合图形与标注</h3><img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503163129982.png" alt="image-20220503163129982" style="zoom:67%;">

<img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503163149587.png" alt="image-20220503163149587" style="zoom:67%;">

<p>Matplotlib中辅助线相关的函数包括:</p>
<p>​    grid():显示网格线</p>
<p>​    hlines(y,minx,maxx):在指定的y处从minx到maxx画横线。</p>
<p>​    vlines(x,miny,maxy):在指定的x处从miny到maxx画竖线。</p>
<p>​    <img src="/../resources/image-20220503163256509.png" alt="image-20220503163256509"></p>
<img src="/2022/04/15/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/image-20220503163325700.png" alt="image-20220503163325700" style="zoom:67%;">



]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据可视化</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础复习</title>
    <url>/2022/05/24/java%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>今天在刷牛客的时候，发现自己对一些数据结构的基础知识并不是很清晰。所以在这里做个笔记整理一下。<span id="more"></span></p>
<p>List、LinkedList、ArrayList:</p>
<p>List:是一个<strong>有序</strong>的集合，可以包含重复的元素。提供了按索引访问的方式。继承Collection。</p>
<p>List有两个重要的实现类：ArrayList 和 LinkedList，那么 <strong>ArrayList 和 LinkedList 有什么区别呢？</strong></p>
<p>ArrayList：我们可以将其看作是<strong>能够自动增长容量的数组</strong>。可以利用 ArrayList 的 toArray() 返回一个数组。</p>
<p>同时，ArrayList采用数组实现的，查找效率一定会比 LinkedList 高。而 LinkedList 采用双向链表实现的，插入和删除的效率会比 ArrayList 高。如果要是在 list 的尾部添加元素，肯定是LinkedList效率高。</p>
<p>我们再展开一个问题 <strong>ArrayList 和 HashSet 区别：</strong></p>
<p>首先，ArrayList 底层是动态数组，可以存储重复的值，并且如果不约定下标的话，是有序的。而 hashset 底层是 hash 表，是不可重复并且是无序的。</p>
<p>Queue</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Queue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">//往队列插入元素，如果出现异常会抛出异常</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line">    <span class="comment">//往队列插入元素，如果出现异常则返回false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span>;</span><br><span class="line">    <span class="comment">//移除队列元素，如果出现异常会抛出异常</span></span><br><span class="line">    E <span class="title function_">remove</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//移除队列元素，如果出现异常则返回null</span></span><br><span class="line">    E <span class="title function_">poll</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//获取队列头部元素，如果出现异常会抛出异常</span></span><br><span class="line">    E <span class="title function_">element</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//获取队列头部元素，如果出现异常则返回null</span></span><br><span class="line">    E <span class="title function_">peek</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Deque 双端队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Deque</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Queue</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span>;<span class="comment">//插入头部，异常会报错</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offerFirst</span><span class="params">(E e)</span>;<span class="comment">//插入头部，异常返回false</span></span><br><span class="line">    E <span class="title function_">getFirst</span><span class="params">()</span>;<span class="comment">//获取头部，异常会报错</span></span><br><span class="line">    E <span class="title function_">peekFirst</span><span class="params">()</span>;<span class="comment">//获取头部，异常不报错</span></span><br><span class="line">    E <span class="title function_">removeFirst</span><span class="params">()</span>;<span class="comment">//移除头部，异常会报错</span></span><br><span class="line">    E <span class="title function_">pollFirst</span><span class="params">()</span>;<span class="comment">//移除头部，异常不报错</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span>;<span class="comment">//插入尾部，异常会报错</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offerLast</span><span class="params">(E e)</span>;<span class="comment">//插入尾部，异常返回false</span></span><br><span class="line">    E <span class="title function_">getLast</span><span class="params">()</span>;<span class="comment">//获取尾部，异常会报错</span></span><br><span class="line">    E <span class="title function_">peekLast</span><span class="params">()</span>;<span class="comment">//获取尾部，异常不报错</span></span><br><span class="line">    E <span class="title function_">removeLast</span><span class="params">()</span>;<span class="comment">//移除尾部，异常会报错</span></span><br><span class="line">    E <span class="title function_">pollLast</span><span class="params">()</span>;<span class="comment">//移除尾部，异常不报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>ArrayDeque</p>
<ul>
<li>实现于Deque，拥有队列或者栈特性的接口</li>
<li>实现于Cloneable，拥有克隆对象的特性</li>
<li>实现于Serializable，拥有序列化的能力</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组存储元素</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elements;</span><br><span class="line"><span class="comment">//头部元素索引</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> head;</span><br><span class="line"><span class="comment">//尾部元素索引</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> tail;</span><br><span class="line"><span class="comment">//最小容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">8</span>;</span><br></pre></td></tr></table></figure>

<p>ArrayDeque底层使用数组存储元素，同时还使用head和tail来表示索引，但注意tail不是尾部元素的索引，而是尾部元素的下一位，即下一个将要被加入的元素的索引。</p>
<p>ArrayDeque 是 Deque 接口的一种具体实现，是依赖于可变数组来实现的。ArrayDeque 没有容量限制，可根据需求自动进行扩容。ArrayDeque 可以作为栈来使用，效率要高于Stack；ArrayDeque 也可以作为队列来使用，效率相较于基于双向链表的LinkedList也要更好一些。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo + github 搭建个人博客</title>
    <url>/2022/02/20/hello-world/</url>
    <content><![CDATA[<p>搭建博客最重要的就是<strong>耐心</strong>和<strong>坚持</strong>。搭建时候遇见许多问题(权限、版本等等)，经过耐心的搜索解决方案逐一解决还是非常开心的！<span id="more"></span></p>
<h2 id="利用-hexo-github-搭建个人博客"><a href="#利用-hexo-github-搭建个人博客" class="headerlink" title="利用 hexo + github 搭建个人博客"></a>利用 hexo + github 搭建个人博客</h2><h3 id="注册-Github-和安装-Git"><a href="#注册-Github-和安装-Git" class="headerlink" title="注册 Github 和安装 Git"></a>注册 Github 和安装 Git</h3><p>首先，我们需要注册一个<a href="https://github.com/">GitHub</a>账号，有时候会因为网络问题而刷新不出页面就需要多刷新几次。(也可以利用Gitee)。然后进入Git官方(<a href="https://git-scm.com/">Git (git-scm.com)</a>)，下载Git。</p>
<h3 id="绑定-Github"><a href="#绑定-Github" class="headerlink" title="绑定 Github"></a>绑定 Github</h3><p>绑定GitHub方便我们上传文件。虽然在GitHub上我们可以直接上传文件，但是由于网络的原因并不好用，所以我们利用SSH来完成GitHub的绑定并提交文件，这样很方便快捷。</p>
<p>检查是否安装SSH，我们在新建的文件夹中右键打开Git Bash:</p>
<p>输入 ssh 命令，查看本机是否安装ssh。</p>
<p><img src="/../resources/image-20220307100552958.png"></p>
<p>已安装 ssh 输入ssh-keygen -t rsa 命令，指定 RSA 算法生成密钥，然后敲四次回车键，之后会生成两个文件，分别为密钥 id_rsa 和公钥id_rsa.pub。接下来我们把公钥 id_rsa.pub 的内容添加到 Github。输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd ~/.ssh</span><br><span class="line">$ ls</span><br><span class="line">$ cat id_rsa.pub</span><br></pre></td></tr></table></figure>

<p>然后我们进入 Github 主页，点击右上角，然后点击 settings。</p>
<p><img src="/../resources/image-20220227222617803.png" alt="image-20220227222617803-16466193186986"></p>
<p>点击 SSH and GPG keys，再点击 New SSH key</p>
<p><img src="/../resources/image-20220227222722625.png" alt="image-20220227222722625"></p>
<p>将复制的公钥 id_rsa.pub 的内容粘贴到 key 内，再点击  Add SSH key，如下图(Title可以为空)：</p>
<p><img src="/../resources/image-20220227222758260.png" alt="image-20220227222758260"></p>
<p>验证是否成功，我们可以通过在 Git Bash 中输入 ssh -T <a href="mailto:&#103;&#x69;&#116;&#x40;&#103;&#105;&#116;&#104;&#x75;&#x62;&#x2e;&#x63;&#x6f;&#109;">&#103;&#x69;&#116;&#x40;&#103;&#105;&#116;&#104;&#x75;&#x62;&#x2e;&#x63;&#x6f;&#109;</a> 进行检验。</p>
<h3 id="提交文件"><a href="#提交文件" class="headerlink" title="提交文件"></a>提交文件</h3><p><strong>本地没有 git 仓库</strong></p>
<ol>
<li>直接将远程仓库 clone 到本地；</li>
<li>将文件添加并 commit 到本地仓库；</li>
<li>将本地仓库的内容push到远程仓库。</li>
</ol>
<p>首先，进入 Github 个人主页。</p>
<p>点击进入我新建的 <strong>text</strong> 项目：</p>
<p><img src="/../resources/image-20220227224505608.png" alt="image-20220227224505608"></p>
<p>点击 <strong>Code</strong> ，再复制地址，然后进入我们准备存储 Git 仓库的目录，如下图：</p>
<p><img src="/../resources/image-20220227224802896.png" alt="image-20220227224802896"></p>
<p>点击 <strong>Clone or download</strong>，再复制地址，然后进入我们准备存储 Git 仓库的目录，如下图：</p>
<p><img src="/../resources/image-20220227224831420.png" alt="image-20220227224831420"></p>
<p>接下来，输入 git clone <a href="mailto:&#103;&#x69;&#116;&#x40;&#103;&#x69;&#116;&#104;&#x75;&#98;&#46;&#99;&#111;&#109;">&#103;&#x69;&#116;&#x40;&#103;&#x69;&#116;&#104;&#x75;&#98;&#46;&#99;&#111;&#109;</a>:ez-Cong&#x2F;text.git，将远程仓库 clone 到本地。然后检查 clone 到本地的仓库内容与远程仓库的内容是否完全一致。</p>
<p>然后创建一个 text.txt 测试文件，如下图。</p>
<p><img src="/../resources/image-20220227225419620.png" alt="image-20220227225419620"></p>
<p>从此目录进入 Git Bash， 输入 git status 查看仓库状态：</p>
<p><img src="/../resources/image-20220227225710786.png" alt="image-20220227225710786"></p>
<p>text 已经是一个 Git 仓库了，而我们刚刚创建的文件 text.txt 没有被追踪，也就是没有提交到本地仓库。现在我们使用 git add 命令将文件添加到了「临时缓冲区」，再用 git commit -m “提交信息” 将其提交到本地仓库。</p>
<p>如果你是第一次提交的话，就会出现下图的情况，会让你输入用户名和邮箱：</p>
<p><img src="/../resources/image-20220227225819195.png" alt="image-20220227225819195"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#你只要再加两行代码就行：</span><br><span class="line">$ git config --global user.name<span class="string">&quot;xxxxx&quot;</span></span><br><span class="line">$ git config --global user.email<span class="string">&quot;xxxxxxx.com&quot;</span></span><br></pre></td></tr></table></figure>

<p>完成后输入 git log 命令查看仓库提交日志：</p>
<p><img src="/../resources/image-20220227225915090.png" alt="image-20220227225915090"></p>
<p>再输入 git status 查看一下仓库状态：</p>
<p><img src="/../resources/image-20220227225955725.png" alt="image-20220227225955725"></p>
<p>现在输入 git push origin main 命令，将本地仓库提交到远程仓库，origin是远程主机的名字。</p>
<p>刷新 GitHub 中 text 仓库。我们会发现这时我们的测试文件已经上传到了 text 仓库中。</p>
<h3 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h3><p>我是在万网购买的域名。</p>
<p>登录万网：<a href="https://link.zhihu.com/?target=https://wanwang.aliyun.com/">万网-阿里云官网</a></p>
<p><img src="/../resources/image-20220227230302506.png" alt="image-20220227230302506"></p>
<p>如果没有注册要先注册一个账号，如果已经注册过直接登录就行。（这里网络上有很多教程，所以就 ……..）</p>
<h3 id="安装node-js和Hexo"><a href="#安装node-js和Hexo" class="headerlink" title="安装node.js和Hexo"></a>安装node.js和Hexo</h3><p><strong>1.安装Nodejs</strong></p>
<p>下载地址：<a href="https://link.zhihu.com/?target=https://nodejs.org/en/">node.js官网</a></p>
<p><img src="/../resources/image-20220227230526391.png" alt="image-20220227230526391"></p>
<p>如上图，直接点击下载，完成后双击安装，安装直接默认 <em><strong>next</strong></em> 就好，我是在E盘新建了一个文件夹 nodejs，安装在这个文件夹里。如果要看详细到每一步的话，可以看一下这个文章：<a href="https://link.zhihu.com/?target=https://blog.csdn.net/antma/article/details/86104068">node.js 安装详细步骤教程</a>。</p>
<p>安装完成可以用打开cmd检验一下是否安装成功，用 node -v 和 npm -v 命令检查版本，如下图：</p>
<p><img src="/../resources/image-20220227230619080.png" alt="image-20220227230619080"></p>
<p><strong>设置npm在安装全局模块时的路径和环境变量</strong></p>
<p>因为如果不设置的话，安装模块的时候就会把模块装到C盘，占用C盘的空间，并且有可能安装好hexo后却无法使用，所以我们需要设置一下：</p>
<p>在 nodejs 文件夹中新建两个空文件夹 node_cache、node_global，如下图：</p>
<p><img src="/../resources/image-20220227230720158.png" alt="image-20220227230720158"></p>
<p>打开cmd，输入如下两个命令：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">npm config set prefix &quot;D:\nodejs\node_global&quot;</span><br><span class="line">npm config set cache &quot;D:\nodejs\node_cache&quot;</span><br></pre></td></tr></table></figure>

<p>设置环境变量：<strong>win10系统 –&gt; 打开控制面板 –&gt; 系统 –&gt;高级系统设置 –&gt; 环境变量 ，</strong>然后在系统变量中新建一个变量名为“NODE_PATH”，值为“E:\nodejs\node_global\node_modules”，如下图：</p>
<p><img src="/../resources/image-20220227230852841.png" alt="image-20220227230852841"></p>
<p>然后编辑用户变量里的Path，将相应npm的路径改为：E:\nodejs\node_global，如下图：</p>
<p><img src="/../resources/image-20220227230932586.png" alt="image-20220227230932586"></p>
<p>然后编辑用户变量里的Path，将相应npm的路径改为：E:\nodejs\node_global，如下图：</p>
<p><img src="/../resources/image-20220227231020336.png" alt="image-20220227231020336"></p>
<p><strong>测试</strong></p>
<p>在 cmd 命令下执行 npm install webpack -g，然后会发现 webpack 这个模块已经在我们设置默认的文件夹中了。</p>
<p><img src="/../resources/image-20220227231158159.png" alt="image-20220227231158159"></p>
<p><strong>注意：</strong></p>
<p>这里有时候会显示安装失败，我们要以管理员启动 cmd 安装就可以解决这一问题。</p>
<p><strong>2.安装hexo</strong></p>
<p>Hexo是我们的个人博客网站的框架，安装之前，我们要先在GitHub上创立一个仓库，如下图：</p>
<p><img src="/../resources/image-20220227231519202.png" alt="image-20220227231519202"></p>
<p><img src="/../resources/image-20220227231638458.png" alt="image-20220227231638458"></p>
<p>接下来安装Hexo，首先在E盘建立一个文件夹 Blog，点开 Blog 文件夹，鼠标右键打开 Git Bush Here，输入npm命令安装Hexo：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>这里可能会出现安装失败，同样要使用管理员权限打开 git bash。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">hexo init 初始化博客</span><br><span class="line">hexo g    静态部署</span><br><span class="line">hexo s	  网页部署完成，输入命令查看</span><br></pre></td></tr></table></figure>

<p><strong>将Hexo部署到GitHub</strong></p>
<p>找到我们的 Blog 文件夹，用记事本打开 _config.yml 文件，下滑到文件底部，补充如下内容：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:ez-Cong/ez-Cong.github.io.git  #你的仓库地址</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>_config.yml 文件格式要求很严格！！！一定要注意空格！！！！</p>
<p><img src="/../resources/image-20220227232242004.png" alt="image-20220227232242004"></p>
<p>仓库地址如下图：</p>
<p><img src="/../resources/image-20220227232323366.png" alt="image-20220227232323366"></p>
<p>回到 Blog 文件夹中，打开 Git Bash，安装Git部署插件，输入命令：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>然后分别输入以下三条命令：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">hexo clean   #清除缓存文件 db.json 和已生成的静态文件 public</span><br><span class="line">hexo g       #生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)</span><br><span class="line">hexo d       #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</span><br></pre></td></tr></table></figure>

<p>完成以后，打开浏览器，输入 <a href="https://link.zhihu.com/?target=https://fengye97.github.io/">https://xxx.github.io</a> 就可以打开你的网页了！</p>
<h3 id="解析域名"><a href="#解析域名" class="headerlink" title="解析域名"></a>解析域名</h3><ol>
<li>登录<a href="https://link.zhihu.com/?target=https://wanwang.aliyun.com/">万网</a>，点击控制台，在你已购买的域名后点击解析添加两条解析记录：</li>
</ol>
<p><img src="/../resources/image-20220227232754828.png" alt="image-20220227232754828"></p>
<p>IPV4地址可以通过ping得到，具体方法是：打开cmd输入下面命令：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ping ez-Cong.github.io    #ping + 你的GitHub的网址</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>打开 Blog 文件夹里的 source 文件夹，添加CNAME文件，可以先创建一个CNAME.txt文件，打开后写上你的域名，不要加www否则每次访问都必须加www，但如果不带有www，以后访问的时候带不带www都可以访问，保存后记得要重命名，将.txt删除，如下图：</p>
<p><img src="/../resources/image-20220227232946124.png" alt="image-20220227232946124"></p>
<p><img src="/../resources/image-20220227233002760.png" alt="image-20220227233002760"></p>
<p>然后回到 Blog 文件夹，右键打开 Git Bash，依次输入下面三条命令：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>打开GitHub，点击 <strong>settings</strong> ，看看CNAME文件是否已经在你的项目中。</p>
<p>大功告成！这时候就可以浏览器直接输入你的域名就会进入自己搭建的网页啦！！！</p>
</li>
</ol>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo搭建博客</tag>
      </tags>
  </entry>
  <entry>
    <title>python中lambda表达式</title>
    <url>/2022/03/25/python%E4%B8%ADlambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>lambda表达式可以用来声明匿名函数，也就是没有函数名字的临时使用的函数。在使用函数作为参数的时候，如果传入的函数比较简单或者使用次数较少，直接定义这些函数就显得比较浪费，这是就可以使用lambda表达式。<span id="more"></span> lambda : 其中variables是函数的参数，expression是函数的返回值，它们之间用冒号:分隔。</p>
<ul>
<li>lambda表达式必须使用lambda关键字定义。</li>
<li>在lambda关键字之后、冒号左边的是参数列表， 可以没有参数，也可以有多个参数，由逗号隔开，冒号右边是该 lambda 表达式的返回值。</li>
<li>lambda表达式必须是单行的。</li>
<li>lambda表达式可以直接在程序中使用，也可以将这一表达式赋值给一个变量。</li>
<li>lambda表达式的计算结果就是函数的返回值。 </li>
<li>lambda表达式只可以包含一个表达式，不允许包含选择、循环等语法结构，该表达式的计算结果可以看作是函数的返回值，不允许包含复合语句，但在表达式中可以调用其他函数。</li>
<li>lambda函数拥有自己的命名空间，且不能访问自有参数列表之外或全局命名空间里的参数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="keyword">lambda</span> x,y,z:<span class="built_in">max</span>(x,y,z)</span><br><span class="line"><span class="built_in">print</span>(f(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>))</span><br><span class="line">g = <span class="keyword">lambda</span> x:x*<span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(g(<span class="number">3</span>))</span><br><span class="line">f = <span class="keyword">lambda</span> x,y,z:x+y+z</span><br><span class="line"><span class="built_in">print</span>(f(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<p><img src="/../resources/image-20220328092818168.png" alt="image-20220328092818168"></p>
<p><img src="/../resources/image-20220328092923895.png" alt="image-20220328092923895"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>numpy&amp;pandas</title>
    <url>/2022/03/19/numpy-pandas/</url>
    <content><![CDATA[<p>由于打算后期学习机器学习以及 NLP 等课程，这里先学习一下有关的两个库 numpy 和 pandas。</p>
<span id="more"></span>

<h3 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h3><p>官方文档介绍 numpy 为：numPy 是Python中科学计算的基础包。它是一个Python库，提供多维数组对象，各种派生对象（如掩码数组和矩阵），以及用于数组快速操作的各种API，有包括数学、逻辑、形状操作、排序、选择、输入输出、离散傅立叶变换、基本线性代数，基本统计运算和随机模拟等等。</p>
<p>这里，我们做个练习。我们需要先下载 numpy 包，输入 pip install numpy 命令。</p>
<p>导入 numpy包 输入一个二维矩阵：</p>
<p><img src="/../resources/image-20220319225611515.png" alt="image-20220319225611515"></p>
<p>生成一个3行4列矩阵：</p>
<p><img src="/../resources/image-20220319230232125.png" alt="image-20220319230232125"></p>
<p>生成一个3行4列全部为1的矩阵：</p>
<p><img src="/../resources/image-20220319232342472.png" alt="image-20220319232342472"></p>
<p><strong>arange函数：</strong>创建等差一维数组</p>
<p>每隔三个数输出10-20：</p>
<p><img src="/../resources/image-20220319230959161.png" alt="image-20220319230959161"></p>
<p>生成 0-11, reshape为矩阵行列：</p>
<p><img src="/../resources/image-20220319232411028.png" alt="image-20220319232411028"></p>
<p><strong>linspace函数</strong>：创建等差以为数组，接受元素数量作为参数。</p>
<p>1-10分成5段数列：<br><img src="/../resources/image-20220319231555369.png"></p>
<p><strong>需要注意：</strong> <strong>linspace</strong>包含终值，<strong>range</strong> 和 <strong>arange</strong>不包含终值。</p>
<p><strong>logspace函数：</strong>创建等比一维数组</p>
<p><img src="/../resources/image-20220410161730947.png" alt="image-20220410161730947"></p>
<p>专门创建数组的函数：</p>
<p><strong>zeros函数</strong>：创建指定长度或形状的全0数组。 格式：np.zeros(shape, dtype&#x3D;float, order&#x3D;’C’)</p>
<p><strong>ones函数</strong>：创建指定长度或形状的全1数组。 格式：np. ones(shape, dtype&#x3D;None, order&#x3D;’C’)</p>
<p>使用 **empty() **函数创建一个随机数组。 格式：np.empty(shape, dtype&#x3D;float, order&#x3D;’C’)</p>
<p><strong>eye()函数</strong>:</p>
<p>eye(N, M&#x3D;None, k&#x3D;0) </p>
<p>返回值：返回一个对角线全1，其余位置全是0的二维数组， <strong>其中k&#x3D;0时，全1对角线为主对角线；k&gt;0时，全1对角线向 右上方偏移；k&lt;0时，全1对角线向左下方偏移。</strong> </p>
<p>参数说明： </p>
<p>N：行数；</p>
<p>M：可选参数，列数，默认值为N；</p>
<p>k：k&#x3D;0时，全1对角线为主对角线；k&gt;0时，全1对角线向上移 动相应的位置；k&lt;0时，全1对角线向下移动相应的位置。</p>
<p><img src="/../resources/image-20220410162343643.png" alt="image-20220410162343643"></p>
<p><img src="/../resources/image-20220410162428830.png" alt="image-20220410162428830"></p>
<p><strong>使用full()函数创建数组</strong>:</p>
<p>full(shape, fill_value, dtype&#x3D;None, order&#x3D;’C’) </p>
<p>返回值：返回由固定值填充的数组。 </p>
<p>参数说明： </p>
<p>shape：int或int类型序列，表示矩阵形状； </p>
<p>fill_value：填充值； </p>
<p>dtype：可选参数，指定元素的数据类型； </p>
<p>order：可选参数，取值’C’或者’F’，表示数组在内存的存放次序是以 行(C)为主还是以列(F)为主，默认值为’C’。</p>
<p><img src="/../resources/image-20220410162626029.png" alt="image-20220410162626029"></p>
<p><strong>随机分布：</strong></p>
<p>normal(loc&#x3D;0.0, scale&#x3D;1.0, size&#x3D;None)：产生size个正态（高斯）分布的样本值。</p>
<p><img src="/../resources/image-20220410164519264.png" alt="image-20220410164519264"></p>
<h4 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h4><p>矩阵a 减 矩阵b。同理也可以进行相加、相乘、相除。</p>
<p>注意的是平方运算： ** 表示平方。</p>
<p>也可以进行sin,cos,tan。</p>
<p><img src="/../resources/image-20220319232540910.png" alt="image-20220319232540910"></p>
<p>矩阵乘法运算：</p>
<p>矩阵运算：c_dot &#x3D; <strong>np.dot(a,b)</strong> </p>
<p>另一种形式：c_dot_2 &#x3D; <strong>a.dot(b)</strong></p>
<p><img src="/../resources/image-20220319233117350.png" alt="image-20220319233117350"></p>
<p>随机生成0-1之间数字，求和，找到最小值最大值：</p>
<p><img src="/../resources/image-20220319233420494.png" alt="image-20220319233420494"></p>
<p>axis&#x3D;1每一行中求和，寻找最大值最小值。axis&#x3D;0每一列中求和，寻找最大值最小值。</p>
<p><img src="/../resources/image-20220319233704066.png" alt="image-20220319233704066"></p>
<p>求矩阵中最大值，最小值索引：<br><img src="/../resources/image-20220320121338504.png" alt="image-20220320121338504"></p>
<p>求平均值：</p>
<p>注意：<strong>axis&#x3D;0列，axis&#x3D;1行</strong></p>
<p><img src="/../resources/image-20220320121404262.png" alt="image-20220320121404262"></p>
<p>中位数：</p>
<p><img src="/../resources/image-20220320121454781.png" alt="image-20220320121454781"></p>
<p>逐步累加：</p>
<p><img src="/../resources/image-20220320121520699.png" alt="image-20220320121520699"></p>
<p>后一项与前一项作差：</p>
<p><img src="/../resources/image-20220320121542889.png" alt="image-20220320121542889"></p>
<p>非0行索引：</p>
<p><img src="/../resources/image-20220320121703735.png" alt="image-20220320121703735"></p>
<p>矩阵转置：</p>
<p><img src="/../resources/image-20220320121646268.png" alt="image-20220320121635225"></p>
<p>flat: flat返回的是一个迭代器，可以用for访问数组每一个元素。</p>
<p><img src="/../resources/image-20220320122821612.png" alt="image-20220320122821612"></p>
<p>合并:</p>
<p>vertical stack上下合并</p>
<p>horizontal stack左右合并</p>
<p><img src="/../resources/image-20220320125048314.png" alt="image-20220320125048314"></p>
<p>向量的转置：<br><img src="/../resources/image-20220320125320194.png" alt="image-20220320125320194"></p>
<p>分割：</p>
<p><img src="/../resources/image-20220320130647220.png" alt="image-20220320130647220"></p>
<p>deep copy：</p>
<h3 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h3><p><strong>Pandas</strong> 是 python 的核心数据分析支持库，提供了快速、灵活、明确的数据结构，旨在简单、直观地处理关系型、标记型数据。Pandas 的目标是成为 Python 数据分析实践与实战的必备高级工具，其长远目标是成为<strong>最强大、最灵活、可以支持任何语言的开源数据分析工具</strong>。经过多年不懈的努力，Pandas 离这个目标已经越来越近了。</p>
<p>Pandas 的主要数据结构是 <strong>Series（一维数据）</strong>与 <strong>DataFrame （二维数据）</strong>，这两种数据结构足以处理金融、统计、社会科学、工程等领域里的大多数典型用例。对于 R 用户，DataFrame 提供了比 R 语言 data.frame 更丰富的功能。Pandas 基于 NumPy 开发，可以与其它第三方科学计算支持库完美集成。</p>
<p>Pandas还具有很多优点：官方文档中都有介绍。<a href="https://www.pypandas.cn/docs/getting_started/overview.html#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">Pandas 概览 | Pandas 中文 (pypandas.cn)</a></p>
<h4 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h4><p>Series对象是一维数组结构，与NumPy中的一维数组ndarray类似，二者与Python基本的数据 结构list也很相近，其区别是list中的元素可以是不同的数据类型，而一维数组ndarray和 Series中则只允许存储同一数据类型的数据。</p>
<p><strong>pandas.Series(data&#x3D;None,index&#x3D;None,dtype&#x3D;None, name&#x3D;None)</strong></p>
<p>用一维ndarray数组创建Series对象：</p>
<p><img src="/../resources/image-20220411220740985.png" alt="image-20220411220740985"></p>
<p>用标量值创建Series对象：</p>
<p><img src="/../resources/image-20220411220827773.png" alt="image-20220411220827773"></p>
<p>通过列表创建Series：</p>
<p><img src="/../resources/image-20220411220851709.png" alt="image-20220411220851709"></p>
<p>通过指定索引方式创建Series:</p>
<p><img src="/../resources/image-20220411220943084.png" alt="image-20220411220943084"></p>
<p>用值列表生成 Series 时，Pandas 默认自动生成整数索引：</p>
<p><img src="/../resources/image-20220320153129409.png" alt="image-20220320153129409"></p>
<p><strong>Series对象的属性：</strong></p>
<p>（1）shape属性获取Series对象的形状。 </p>
<p>（2）dtype属性获取Series对象的数据数组中的数据 的数据类型。 </p>
<p>（3）values属性获取Series对象的数据数组 </p>
<p>（4）index属性获取Series对象的数据数组的索引 </p>
<p>（5）Series对象本身及索引的name属性</p>
<p><img src="/../resources/image-20220411221905083.png" alt="image-20220411221905083"></p>
<p><strong>通过索引和切片查看Series对象的数据</strong></p>
<p><img src="/../resources/image-20220411221943365.png" alt="image-20220411221943365"></p>
<p>用含日期时间索引与标签的 Numpy 数组生成 DataFrame：</p>
<p><img src="/../resources/image-20220320153715145.png" alt="image-20220320153715145"></p>
<p>用 Series字典对象生成DataFrame:</p>
<p><img src="/../resources/image-20220320154218356.png" alt="image-20220320154218356"></p>
<p>查看 DataFrame 头部和尾部数据：</p>
<p><img src="/../resources/image-20220320154424221.png" alt="image-20220320154424221"></p>
<p>显示索引与列名：<br><img src="/../resources/image-20220320154553779.png" alt="image-20220320154553779"></p>
<h4 id="DataFrame对象："><a href="#DataFrame对象：" class="headerlink" title="DataFrame对象："></a><strong>DataFrame对象</strong>：</h4><p>DataFrame是一个表格型的数据结构，既有行索引（保存在index） 又有列索引（保存在columns），是Series对象从一维到多维的扩展。 DataFrame对象每列相同位置处的元素共用一个行索引，每行相同位置处的元素共用一个列索引。DataFrame对象各列的数据类型可以不相同。</p>
<p><img src="/../resources/image-20220411222437885.png" alt="image-20220411222437885"></p>
<p><strong>创建DataFrame对象</strong></p>
<p>创建DataFrame对象最常用的方法是使用 pandas 的 DataFrame() 构造函数，其语法格式如下：</p>
<p>Pd.DataFrame(data&#x3D;None, index&#x3D;None, columns&#x3D;None, dtype&#x3D;None)</p>
<p>返回值：DataFrame对象</p>
<p>参数说明：</p>
<p>data：创建DataFrame对象的数据，其类型可以是字典、嵌套列表、 元组列表、numpy的ndarray对象、其它DataFrame对象。</p>
<p>index：行索引，创建DataFrame对象的数据时，如果没有提供索引， 默认赋值为arange(n)。 </p>
<p>columns：列索引，没有提供索引时，默认赋值为arange(n)。 </p>
<p>dtype：用来指定元素的数据类型，如果为空，自动推断类型。</p>
<ul>
<li>可将一个字典对象传递给DataFrame()函数来生成一个 DataFrame对象，字典的键作为DataFrame对象的列索引，字典的值作为列索引对应的列值，pandas也会自动为其添加一列从0开始的数值作为行索引。</li>
</ul>
<p><img src="/../resources/image-20220411222800911.png" alt="image-20220411222800911"></p>
<ul>
<li>可以只选择字典对象的一部分数据来创建DataFrame对象，只需在DataFrame构造函数中，用columns选项指定需要的列即可，新建的DataFrame对象各列顺序与指定的列顺序一致</li>
</ul>
<p><img src="/../resources/image-20220411222851739.png" alt="image-20220411222851739"></p>
<ul>
<li>创建DataFrame对象时，如果没有用index数组明确指定行索引，pandas也会自动为其添加一列从0开始的数值作为行索引。如果想用自己定义的行索引，则要把定义的索引放到一个数组中，赋值给index选项。</li>
</ul>
<p><img src="/../resources/image-20220411222949524.png" alt="image-20220411222949524"></p>
<ul>
<li>创建DataFrame对象时，可以同时指定行索引和列索引， 这时候就需要传递三个参数给DataFrame()构造函数，三个参数的顺序是：数据、index选项和columns选项。将存放行索引的数组赋给index选项，将存放列索引的数组赋给columns选项。</li>
</ul>
<p><img src="/../resources/image-20220411223015188.png" alt="image-20220411223015188"></p>
<ul>
<li>以字典的字典或Series的字典的结构创建DataFrame对象， pandas会将外边的键解释成列名称，将里面的键解释成行索引。</li>
</ul>
<p><img src="/../resources/image-20220411223043380.png" alt="image-20220411223043380"></p>
<ul>
<li>用键值为列表的字典构建DataFrame，其中每个列表（list）代 表的是一个列，字典的键则是列索引。这里要注意的是每个列表中 的元素数量应该相同，否则会报错。</li>
</ul>
<p><img src="/../resources/image-20220411223121140.png" alt="image-20220411223121140"></p>
<ul>
<li>以字典的列表构建DataFrame，其中每个字典代表的是每条记录（DataFrame中的一行），字典中各个键的键值对应的是这条记录的相关属性。</li>
</ul>
<p><img src="/../resources/image-20220411223143868.png" alt="image-20220411223143868"></p>
<ul>
<li>以numpy对象构建DataFrame。</li>
</ul>
<p><img src="/../resources/image-20220411223209421.png" alt="image-20220411223209421"></p>
<p><strong>查看DataFrame的常用属性：</strong></p>
<p><img src="/../resources/image-20220411223242765.png" alt="image-20220411223242765"></p>
<p>每个索引都有一些方法和属性，它们可用于设置逻辑并回答 有关该索引所包含的数据的常见问题。</p>
<p><img src="/../resources/image-20220412142324301.png" alt="image-20220412142324301"></p>
<h4 id="DataFrame数据的编辑"><a href="#DataFrame数据的编辑" class="headerlink" title="DataFrame数据的编辑"></a>DataFrame数据的编辑</h4><p><strong>增加数据</strong></p>
<p>增加一行直接通过 append 方法传入字典结构数据即可。</p>
<p><img src="/../resources/image-20220413225447233.png" alt="image-20220413225447233"></p>
<p><img src="/../resources/image-20220413225500870.png" alt="image-20220413225500870"></p>
<p>增加列时，只需为要增加的列赋值即可创建一个新的列</p>
<p><img src="/../resources/image-20220413225532747.png" alt="image-20220413225532747"></p>
<p><strong>删除数据</strong></p>
<p>删除数据直接用 drop 方法，通过 axis 参数确定是删除的行还是列。默认数据删除不修改原数据，需要在原数据删除行列需要设置参数 inplace &#x3D; True。</p>
<p>删除数据：</p>
<p><img src="/../resources/image-20220413225845769.png" alt="image-20220413225845769"></p>
<p>删除数据的列</p>
<p><img src="/../resources/image-20220413225927644.png" alt="image-20220413225927644"></p>
<p><strong>修改数据</strong></p>
<p>修改一个数据时直接对选择的数据赋值即可。</p>
<p>需要注意的是，数据修改是直接对 DataFrame 数据修改，操作无法撤销，因此更改数据时要做好数据备份。</p>
<p><img src="/../resources/image-20220413225957096.png" alt="image-20220413225957096"></p>
<p>可以用 DataFrame对象的 name 属性为 DataFrame对象的列索引 columns 和行索引 index 指定别的名称，以便于识别。</p>
<p><img src="/../resources/image-20220413230031750.png" alt="image-20220413230031750"></p>
<p>为 DataFrame对象添加新的列，指定新列的名称，以及为新列赋值。</p>
<p><img src="/../resources/image-20220413230051488.png" alt="image-20220413230051488"></p>
<h4 id="DataFrame数据的查询"><a href="#DataFrame数据的查询" class="headerlink" title="DataFrame数据的查询"></a>DataFrame数据的查询</h4><ul>
<li>选取列</li>
</ul>
<p><img src="/../resources/image-20220413230127764.png" alt="image-20220413230127764"></p>
<ul>
<li>选取行</li>
</ul>
<p>通过切片方式可以选取一行或多行数据</p>
<p><img src="/../resources/image-20220413230155819.png" alt="image-20220413230155819"></p>
<ul>
<li>查看DataFrame对象中的一个元素</li>
</ul>
<p><img src="/../resources/image-20220413230339884.png" alt="image-20220413230339884"></p>
<ul>
<li>布尔选择</li>
</ul>
<p><img src="/../resources/image-20220413230401065.png" alt="image-20220413230401065"></p>
<p>通过 DataFrame 对象的方法 isin() 判断一组元素是否属于 DataFrame对象</p>
<p><img src="/../resources/image-20220413230528138.png" alt="image-20220413230528138"></p>
<h4 id="数据运算与排序"><a href="#数据运算与排序" class="headerlink" title="数据运算与排序"></a>数据运算与排序</h4><p>DataFrame对象的数据运算与排序方法如表所示，表中的 df 表示一个DataFrame对象。</p>
<p><img src="/../resources/image-20220413230628355.png" alt="image-20220413230628355"></p>
<p><img src="/../resources/image-20220413230659106.png" alt="image-20220413230659106"></p>
<h4 id="DataFrame数据的筛选"><a href="#DataFrame数据的筛选" class="headerlink" title="DataFrame数据的筛选"></a>DataFrame数据的筛选</h4><p>可以通过指定条件筛选 DataFrame 对象的元素。</p>
<p><img src="/../resources/image-20220413230912611.png" alt="image-20220413230912611"></p>
<p>常用的数据筛选方法：</p>
<p><img src="/../resources/image-20220413231036462.png" alt="image-20220413231036462"></p>
<p>head（） #默认获取前5行 </p>
<p>head（n）#获取前n行 </p>
<p>tail（）#默认获取后5行 </p>
<p>head（n）#获取后n行 </p>
<p>sample（n）#随机抽取n行显示</p>
<p><strong>选取行和列</strong></p>
<p><strong>DataFrame.loc    (行索引名称或条件，列索引名称)</strong></p>
<p><strong>DataFrame.iloc    （行索引位置，列索引位置）</strong></p>
<p><img src="/../resources/image-20220413233025459.png" alt="image-20220413233025459"></p>
<p><img src="/../resources/image-20220413233057864.png" alt="image-20220413233057864"></p>
<p><img src="/../resources/image-20220413233113685.png" alt="image-20220413233113685"></p>
<h4 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h4><p>Pandas的数据对象在进行算术运算时，如果有相同索引则进行算术运算，如果没有，则会自动进行数据对齐，但会引入缺失值。</p>
<p><img src="/../resources/image-20220414090051363.png" alt="image-20220414090051363"></p>
<p>DataFrame类型的数据相加：</p>
<p><img src="/../resources/image-20220414090426890.png" alt="image-20220414090426890"></p>
<h4 id="函数应用和映射"><a href="#函数应用和映射" class="headerlink" title="函数应用和映射"></a>函数应用和映射</h4><p>已定义好的函数可以通过以下三种方法应用到数据： </p>
<ol>
<li><strong>map函数：</strong>将函数套用到Series的每个元素中； </li>
<li><strong>apply函数</strong>，将函数套用到DataFrame的行或列上，行与列通过axis参数设置； </li>
<li><strong>applymap函数</strong>，将函数套用到DataFrame的每个元素上。</li>
</ol>
<p><img src="/../resources/image-20220414094405392.png" alt="image-20220414094405392"></p>
<p><strong>df.apply(func,axis&#x3D;0)</strong></p>
<p>作用：将func函数应用到DataFrame对象df的行或列所构成的一维数组上。 </p>
<p>func：应用到行或列上的函数。 </p>
<p>axis：axis&#x3D;0，对每一列应用func函数；axis&#x3D;1，对每 一行应用函数。</p>
<p><img src="/../resources/image-20220414105400861.png" alt="image-20220414105400861"></p>
<p>apply函数的使用方法：</p>
<p><img src="/../resources/image-20220414105420613.png" alt="image-20220414105420613"></p>
<p><img src="/../resources/image-20220414105439048.png" alt="image-20220414105439048"></p>
<p><strong>df.sort_values(by, axis&#x3D;0, ascending&#x3D;True)</strong></p>
<p>作用：按指定的列或行进行值排序。 </p>
<p>参数说明： by：指定某些行或列作为排序的依据。 </p>
<p>axis：axis&#x3D;0，对行进行排序；axis&#x3D;1，对列进行排序。</p>
<p><img src="/../resources/image-20220414105537114.png" alt="image-20220414105537114"></p>
<p>sort_index方法：对索引进行排序，默认为升序，降序排序时加参数 ascending&#x3D;False。</p>
<p><img src="/../resources/image-20220414105609080.png" alt="image-20220414105609080"></p>
<p>对于DataFrame数据排序，通过指定轴方向，使用sort_index 函数对行或列索引进行排序。如果要进行列排序，则通过 sort_values函数把列名传给by参数即可。</p>
<p><img src="/../resources/image-20220414105628383.png" alt="image-20220414105628383"></p>
<p><strong>df.max(axis&#x3D;0)</strong></p>
<p>作用：axis&#x3D;0表示返回df列的最大值，axis&#x3D;1表示返回df行的最大值。</p>
<p><img src="/../resources/image-20220414111002930.png" alt="image-20220414111002930"></p>
<p>在DataFrame中，可以通过<strong>sum方法</strong>对每列进行求和汇总，与 Excel中的sum函数类似。如果设置axis &#x3D; 1指定轴方向，可以实现按行汇总。</p>
<p><img src="/../resources/image-20220414111040330.png" alt="image-20220414111040330"></p>
<p>数据描述与统计：<strong>describe()</strong> 方法可以对每个数值型列进行描述性统计，形成统计报告。</p>
<p><img src="/../resources/image-20220414111115951.png" alt="image-20220414111115951"></p>
<p>pandas中常用的描述性统计量表：</p>
<p><img src="/../resources/image-20220414111141347.png" alt="image-20220414111141347"></p>
<p><strong>唯一值和值计数：</strong></p>
<p> 通过Series对象的**unique()<strong>方法可以获取不重复的数据，而通过 Series对象的</strong>values_counts()**方法可以统计每个值出现的次数。</p>
<p><img src="/../resources/image-20220414114545463.png" alt="image-20220414114545463"></p>
<p><img src="/../resources/image-20220414114602335.png" alt="image-20220414114602335"></p>
<h4 id="数据分组与聚合"><a href="#数据分组与聚合" class="headerlink" title="数据分组与聚合"></a>数据分组与聚合</h4><h5 id="groupby方法聚合"><a href="#groupby方法聚合" class="headerlink" title="groupby方法聚合"></a>groupby方法聚合</h5><p>在pandas中，分组运算主要通过 <strong>groupby</strong> 函数来完成，聚合操作主要通过 <strong>agg</strong> 函数来完成。</p>
<p>分组的基本过程是，首先数据集按照分组键（key） 的方式分成小的数据片（split），然后对每一个数据片进行操作，最后将结果再组合起来形成新的数据集 （combine）。</p>
<p>df.groupby(by&#x3D;None, axis&#x3D;0, level&#x3D;None, as_index&#x3D;True, sort&#x3D;True, group_keys&#x3D;True, squeeze&#x3D;False)</p>
<p>作用：通过指定列索引或行索引，对df的数据元素进行分组。</p>
<p><img src="/../resources/image-20220414114723308.png" alt="image-20220414114723308"></p>
<p><img src="/../resources/image-20220414115821763.png" alt="image-20220414115821763"></p>
<p><strong>按列名分组：</strong></p>
<p>DataFrame数据的列索引名可以作为分组键，但需要注意的是用于 分组的对象必须是DataFrame数据本身，否则搜索不到索引名称会报错。</p>
<p><img src="/../resources/image-20220415102735056.png" alt="image-20220415102735056"></p>
<p><strong>按列分组：</strong></p>
<p><img src="/../resources/image-20220415102816084.png" alt="image-20220415102816084"></p>
<p><strong>按列表或元组分组：</strong></p>
<p>分组键还可以是长度和DataFrame行数相同的列表或元组，相当于将列表或元组看做DataFrame的一列，然后将其分组。</p>
<p><img src="/../resources/image-20220415103014610.png" alt="image-20220415103014610"></p>
<p><strong>按字典分组：</strong></p>
<p>如果原始的DataFrame中的分组信息很难确定或不存在，可以通过字典结构，定义分组信息。</p>
<p><img src="/../resources/image-20220415103054320.png" alt="image-20220415103054320"></p>
<p><strong>按函数分组：</strong></p>
<p>函数作为分组键的原理类似于字典，通过映射关系进行分组，但是函数更加灵活。</p>
<p><img src="/../resources/image-20220415103213758.png" alt="image-20220415103213758"></p>
<p><strong>按分组统计：</strong></p>
<p>在 df.groupby() 所生成的分组上应用 size()、sum()、 count()、mean() 等统计函数，能分别统计分组数量、 不同列的分组和、不同列的分组数量、分组不同列的平均值。</p>
<p><img src="/../resources/image-20220415103507049.png" alt="image-20220415103507049"></p>
<p><strong>常用的聚合运算：</strong></p>
<p><img src="/../resources/image-20220415103630891.png" alt="image-20220415103630891"></p>
<h5 id="使用agg方法聚合运算"><a href="#使用agg方法聚合运算" class="headerlink" title="使用agg方法聚合运算"></a>使用agg方法聚合运算</h5><p>agg、aggregate方法都支持对每个分组应用某个函数， 包括Python内置函数或自定义函数。同时，这两个方法也能够直接对DataFrame进行函数应用操作。</p>
<p>agg和aggregate函数对DataFrame 对象操作的功能基本相同，因此只需掌握一个即可。</p>
<p>agg函数的语法格式如下： <strong>DataFrame.agg(func, axis&#x3D;0)</strong> </p>
<p>作用：通过func在指定的轴上进行聚合操作。 </p>
<p>func：用来指定聚合操作的方式，其数据形式有函数、字符串、 字典以及字符串或函数所构成的列表。 </p>
<p>axis：axis&#x3D;0表示在列上操作，axis&#x3D;1表示在行上操作。</p>
<ul>
<li>在DataFrame对象的行或列上执行聚合操作</li>
</ul>
<p><img src="/../resources/image-20220415104100456.png" alt="image-20220415104100456"></p>
<p>在 df.groupby() 所生成的分组上应用 agg() 对于分组的某一列或者多个列，应用agg(func)可以对分 组后的数据应用 func 函数 。 例如 ： 用 group[‘data1’].agg(‘key1’)对分组后的’data1’列求均值。也可以推广到同时作用于多个列和使用多个函数。</p>
<p><img src="/../resources/image-20220415104120965.png" alt="image-20220415104120965"></p>
<ul>
<li>在 df.groupby() 所生成的分组上应用agg()</li>
</ul>
<p><img src="/../resources/image-20220415104329703.png" alt="image-20220415104329703"></p>
<p><img src="/../resources/image-20220415104349989.png" alt="image-20220415104349989"></p>
<h3 id="分组运算"><a href="#分组运算" class="headerlink" title="分组运算"></a>分组运算</h3><ol>
<li><p>transform方法通过transform方法可以将运算分布到每一行。 </p>
</li>
<li><p>使用apply方法聚合数据 </p>
<p>apply方法类似于agg方法，能够将函数应用于每一列。</p>
</li>
</ol>
<p>应用agg()函数执行聚合操作。</p>
<p>项目背景：王老师是某教育培训机构的数学老师。现在他想研究一下他的学生数学期末考试成绩和什么因素有关。于是王老师先提取了一小部分学生的数据，保存在 DataFrame 对象中， 王老师想要查看一下不同班级的学生数学平均分情况。就需要用到分组聚合操作。</p>
<p>分组聚合操作的定义：分组聚合操作指的是按照某项规则对数据进行分组， 接着对分完组的数据执行总结性统计的操作（比如求和、求均值）。它可以帮助我们从庞杂的数据中提炼出我们想要的数据样式。 下图展现的就是利用分组聚合操作计算不同班级学生的均分的过程。</p>
<p><img src="/../resources/image-20220415104948268.png" alt="image-20220415104948268"></p>
<ul>
<li>分组聚合操作根据其分组方式的不同可以分为单层分组聚合操作以及多层分组聚合操作。</li>
<li>单层分组聚合操作</li>
</ul>
<p>单层分组聚合操作指的是针对某一个组进行聚合操作。王老师的案例就是单层分组聚合操作，因为他只需要针对班级这一列进行分组。</p>
<p><img src="/../resources/image-20220415105617431.png" alt="image-20220415105617431"></p>
<ul>
<li>单层分组聚合操作的代码：df.groupby(by)[‘列索引’].mean()。这行代码可以拆分成两部分来看待，如下图所示。</li>
</ul>
<p><img src="/../resources/image-20220415105730628.png" alt="image-20220415105730628"></p>
<ul>
<li>首先来了解一下<strong>单层分组操作</strong>：df.groupby(by)。 参数 by 代表了要对哪一列数据进行分组操作。 这里要注意，单层分组操作只能根据一列数据进行分组。 如果要对班级进行分组，就可以将列索引’班级’传给参数 by。</li>
</ul>
<p><img src="/../resources/image-20220415110507960.png" alt="image-20220415110507960"></p>
<p>代码效果如下图所示：</p>
<p><img src="/../resources/image-20220415110603067.png" alt="image-20220415110603067"></p>
<p><strong>聚合操作</strong>：</p>
<p>在分完组之后，就可以对某一列数据进行聚合操作了。 [‘列索引’].mean() 中的 ‘列索引’ 指的是需要对哪一列数据进行聚合操作。如果想要对成绩这一列数据进行聚合操作，就可以将’ 成绩’传给’列索引’ 。</p>
<p>mean() 指的是求平均值。整体效果如下图所示：</p>
<p><img src="/../resources/image-20220415110818296.png" alt="image-20220415110818296"></p>
<p><strong>常用的聚合操作方法见如下表格：</strong></p>
<p><img src="/../resources/image-20220415110846491.png" alt="image-20220415110846491"></p>
<p><strong>单层数据分组与聚合：</strong></p>
<ul>
<li><p>聚合操作</p>
<p>帮助王老师求出不同性别学生的数学成绩中位数。</p>
<p><img src="/../resources/image-20220415111340026.png" alt="image-20220415111340026"></p>
</li>
</ul>
<p>从运行结果中可以发现，分组聚合操作返回的是一个 Series 对象。</p>
<p>只不过这个 Series 对象和之前讲过的有些不一样，它的索引会多一个名字。</p>
<p>这个名字对应的是分组操作中的列索引。由于刚才是对性别这一列进行分组，所以名字就是性别。</p>
<p><img src="/../resources/image-20220415111423974.png" alt="image-20220415111423974"></p>
<p><strong>多层分组与聚合：</strong></p>
<ul>
<li>王老师还想对这组数据有进一步的研究，他想知道如何获取不同班级下不同性别的学生的平均分，这个时候就需要用到多层分组聚合操作的知识了。</li>
<li>下图展现的就是利用多层分组聚合操作计算不同班级下不同性别的学生均分的过程。</li>
</ul>
<p><img src="/../resources/image-20220415111508449.png" alt="image-20220415111508449"></p>
<p><img src="/../resources/image-20220415113349416.png" alt="image-20220415113349416"></p>
<p>多层分组聚合和单层分组聚合相比，代码是相同的，都是 df.groupby(by)[‘列索引’].mean()。</p>
<p>从代码的运行结果来看，多层分组聚合操作返回的也是一个 Series 对象。</p>
<p>唯一的不同点在于索引的层数上。</p>
<p>单层分组聚合操作的索引只有一层，而多层分组聚合操作的索引至少有两层。</p>
<p><img src="/../resources/image-20220415113359908.png" alt="image-20220415113359908"></p>
<ul>
<li><p>层数的不同体现在参数 by 的赋值方式上。</p>
</li>
<li><p>在单层分组聚合操作的时候，只需要将一个列索引传给参数 by 就可以了。</p>
</li>
<li><p>而多层分组聚合操作需要传多个列索引给参数 by。</p>
</li>
<li><p>需要注意的是，这些列索引在传进参数 by 之前，需要先被放 进一个“容器”里，这个容器可以是列表。</p>
</li>
</ul>
<p><img src="/../resources/image-20220415113445220.png" alt="image-20220415113445220"></p>
<p>代码运行结果中索引的效果如下图所示：</p>
<p>仔细观察一下索引出现的次序。最左侧是班级，分为1班和2班。在 1班和2班这两个类别下，又继续分为男和女这两个类别，也就是性别这列数据所对应的取值集合。</p>
<p><img src="/../resources/image-20220415113514624.png" alt="image-20220415113514624"></p>
<p>分组的顺序和列表中的参数是对应的（从左往右依次拆分）。</p>
<p><img src="/../resources/image-20220415113529796.png" alt="image-20220415113529796"></p>
<ul>
<li>如果现在想要先对性别分组，再对班级分组，那该如何向 by 传参呢？</li>
</ul>
<p><img src="/../resources/image-20220415113813099.png" alt="image-20220415113813099"></p>
<p>假设现在王老师又想对数据有进一步的研究，他想知道尖子生是不是更容易出现在戴眼镜的学生群体中。于是王老师想要在原先分组的基础上，再对’眼镜’这一列进行拆分。</p>
<p><img src="/../resources/image-20220415113832627.png" alt="image-20220415113832627"></p>
<ul>
<li><p>虽然通过多层分组聚合的方法，可以求出不同组别下的学生考试成绩的情况，但是返回的结果看起来却有些冗杂。</p>
</li>
<li><p>所有的组别信息都扎堆出现在了一个 Series 对象的索引中，有没有办法能 够让这些信息看起来更直观一些呢？</p>
</li>
<li><p><img src="/../resources/image-20220415113845806.png" alt="image-20220415113845806"></p>
</li>
</ul>
<p><strong>s.unstack()</strong> 函数就是解决这问题的常见方法。它可以将一个多层分组聚合后的 Series 对象转变成 DataFrame 对象。</p>
<p>s.unstack() 这个方法是针对多层分组聚合后的 Series 对象来使用的。作用就是将其索引的最后一列转变成 DataFrame 对象的列索引，而剩下的索引 则转变成 DataFrame 对象的行索引。</p>
<p><img src="/../resources/image-20220415113926770.png" alt="image-20220415113926770"></p>
<p><img src="/../resources/image-20220415114434120.png" alt="image-20220415114434120"></p>
<p><strong>练习：</strong></p>
<ul>
<li><p>要求是获取如下图所示的表格（提示：聚合操作 的方法是求平均值）。</p>
</li>
<li><p>首先可以从表格中发现，列索引是’性别’ ，所以在给参数 by 赋值的时候， 应该将’性别’放在列表的末尾。其次，从 DataFrame 对象的行索引中可以 发现， ‘班级’在左， ‘眼镜’在右，所以最后传给参数 by 的列表应该是：[‘班 级’, ‘眼镜’, ‘性别’]。</p>
</li>
</ul>
<p><img src="/../resources/image-20220415114525822.png" alt="image-20220415114525822"></p>
<p><img src="/../resources/image-20220415114635216.png" alt="image-20220415114635216"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>numpy&amp;pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>python</title>
    <url>/2022/03/14/python/</url>
    <content><![CDATA[<h3 id="Python简介"><a href="#Python简介" class="headerlink" title="Python简介"></a>Python简介</h3><p>python 这一伟大语言诞生于1989年圣诞节期间，创始人是荷兰的Guido van Rossum。(python有两个主要的大版本: python2 和 python3。本文基于 python3 开发)<span id="more"></span></p>
<p>由于课程要求，利用 <strong>Anaconda</strong> 包管理器安装和管理 python 软件，选用了 <strong>jupyter notebook</strong> 编辑器。</p>
<p>python官网：<a href="https://www.python.org/">Welcome to Python.org</a></p>
<p>数据科学计算平台 Anaconda：Anaconda是一个集成的Python数据科学环境，Anaconda除了有Python外，还安装了180多个用于数据分析的第三方库，而且可 以使用conda命令安装第三方库和创建多个环境。相对于只安装 Python而言，避免了安装第三方库的麻烦。Anaconda的优点是已经内置了Jupyter notebook交互式计算环境、 Spyder集成开发环境，以及NumPy、pandas、Matplotlib、SciPy等各 类主要数据分析模块。Anaconda还是一个开源的包、环境管理器，可以在同一个机器上安装不同版本的软件包及其依赖，并能够在不同的环境之间切换。使用 Anaconda可以方便地进行包的管理（包的安装、卸载、更新），对于需要的各种Python的第三方包，可以直接在Anaconda中进行下载。Anaconda官网： <a href="https://www.anaconda.com/">Anaconda | The World’s Most Popular Data Science Platform</a></p>
<p><strong>常用类库：</strong></p>
<p><strong>Numpy：</strong>NumPy软件包是Python生态系统中数据分析、机器学习和科 学计算的主力军。它极大地简化了向量和矩阵的操作处理。除了能对数值数据进行切片（slice）和切块（dice）外， 使用NumPy还能为处理和调试上述库中的高级实例带来极大 便利。一般被很多大型金融公司使用，以及核心的科学计算组织 如Lawrence Livermore、NASA用其处理一些本来使用C++、 Fortran或Matlab等所做的任务。</p>
<p><strong>SciPy：</strong> SciPy（<a href="http://scipy.org)是基于numpy开发的高级模块,/">http://scipy.org）是基于NumPy开发的高级模块，</a> 依赖于NumPy，提供了许多数学算法和函数的实现，可便 捷快速地解决科学计算中的一些标准问题，例如数值积分 和微分方程求解、最优化、甚至包括信号处理等。作为标准科学计算程序库， SciPy它是Python科学计算程序 的核心包，包含了科学计算中常见问题的各个功能模块， 不同子模块适用于不同的应用。</p>
<p><strong>Pandas：</strong>Pandas提供了大量快速便捷处理数据的函数和方法。它是使Python成为强大而高效的数据分析环境的重要因素之一。 Pandas中主要的数据结构有Series、DataFrame和Panel。其中Series是一维数组，与NumPy中的一维array以及Python基本的数据结构List类似；DataFrame是二维的表格型数据结 构，可以将DataFrame理解为Series的容器； Panel是三维的 数组，可看作为DataFrame的容器。</p>
<p><strong>Matplotlib：</strong>Matplotlib是Python 的绘图库，是用于生成出版质量 级别图形的桌面绘图包，让用户很轻松地将数据图形化，同时还提供多样化的输出格式。</p>
<p><strong>Seaborn：</strong>Seaborn在Matplotlib基础上提供了一个绘制统计图形的高级接口，为数据的可视化分析工作提供了极大的 方便，使得绘图更加容易。用Matplotlib最大的困难是其默认的各种参数，而 Seaborn则完全避免了这一问题。一般来说，Seaborn 能满足数据分析90%的绘图需求。</p>
<p><strong>Scikit-learn：</strong>Scikit-learn是专门面向机器学习的Python开源框架， 它实现了各种成熟的算法，容易安装和使用。 Scikit-learn的基本功能有分类、回归、聚类、数据 降维、模型选择和数据预处理六大部分。</p>
<p>python库的一些常用命令:</p>
<p><strong>import 模块名 [as 别名]</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#导入random随机函数模块中的所有对象并设置别名</span></span><br><span class="line"><span class="keyword">import</span> random <span class="keyword">as</span> rd</span><br><span class="line"><span class="comment">#通过别名访问模块中的对象</span></span><br><span class="line"><span class="comment">#返回[1,10]之间的一个随机整数</span></span><br><span class="line">rd.randint(<span class="number">1</span>,<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p><strong>from 模块名 import 对象名 [as 别名]</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#导入random模块中的randint,使用别名rt</span></span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint <span class="keyword">as</span> rt</span><br><span class="line"><span class="comment">#通过别名使用randint函数</span></span><br><span class="line">rt(<span class="number">1</span>,<span class="number">10</span>)</span><br></pre></td></tr></table></figure>



<h3 id="语法常识"><a href="#语法常识" class="headerlink" title="语法常识"></a>语法常识</h3><p><strong>命名规则：</strong>驼峰规则</p>
<p><strong>代码缩进：</strong>Tab和空格来进行缩进，注意不要混用。( Python中的缩进代表程序块的作用域，如果采用了错误的代码缩进，会导致程序抛出异常) </p>
<p><strong>代码注释：</strong>Python的单行注释语句用#开始，从#开始一直到末尾的部分是注释部分。如果要进行多行的注释可以使用三个单引号（’’’） 或者双引号（”””）将注释内容包围。单引号和双引号在使用上没有本质的差别。</p>
<p><strong>中文编码：</strong>Python中使用<strong>函数ord(x)<strong>查看x字符的编码，编码占2 个字节，因此一般再使用</strong>hex函数</strong>把编码转为十六进制显示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">ord</span>(<span class="string">&quot;A&quot;</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">ord</span>(<span class="string">&quot;我&quot;</span>)))</span><br></pre></td></tr></table></figure>

<p><strong>关键字：</strong>关键字是Python语言本身使用的标识符，被Python语言保留，每个关键字都有其特殊的意义 ，因而不能用作标识符，否则容易产生编译错误。如False、True 、None 、and、or、not、as ………….</p>
<p>检查是否是Python中的关键字（保留字符），用 <strong>keyword.iskeyword (word)</strong> </p>
<p><strong>_ ：</strong>单独的下划线（_）用于表示上一次运算的结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In[]:<span class="number">2</span>*<span class="number">3</span></span><br><span class="line">Out[]:<span class="number">6</span></span><br><span class="line">In[]:_*<span class="number">10</span></span><br><span class="line">Out[]:<span class="number">60</span></span><br></pre></td></tr></table></figure>

<p><strong>内置函数：</strong></p>
<p>类型转换函数：chr(97) ord(‘a’) str(3.15) int(3.3) </p>
<p>数学运算函数：abs(x) max(3,2,5,1) pow(x,y)</p>
<p><strong>变量赋值：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x=<span class="number">0</span>;y=<span class="number">0</span>;z=<span class="number">0</span> <span class="comment">#多个语句间用分号分隔</span></span><br><span class="line">a, b = <span class="number">1</span>, <span class="number">2</span> <span class="comment">#采用多变量同时赋值</span></span><br><span class="line">c=d=<span class="number">3</span>		<span class="comment">#采用链式赋值</span></span><br><span class="line"><span class="built_in">print</span>(x,y,z,a,b,c,d)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>type()函数：</strong>一般形式：type(变量名)，其作用是查询变量的数字类型。</p>
<p><strong>id()函数：</strong>是获取变 量的内存地址。</p>
<p><strong>isinstance()函数：</strong>判断一个数值是否是某种数字类型。 </p>
<p><strong>Python中有六个标准的数据类型：</strong></p>
<ul>
<li>number（数字）</li>
<li>string（字符串） </li>
<li>list（列表）</li>
</ul>
<p>列表是Python里面的容器之一，由方括号和方括号括起来的数据构成。里面的数据可以是整数、浮点数、字符串， 也可以是另一个列表或者其它的数据结构。列表里面的每 一项叫作列表的一个元素，每个元素之间使用英文逗号隔开，</p>
<p>例如</p>
<p>list_1 &#x3D; [1, 2, 3, 4, 5]                     #列表里面有5个元素，全部是数字 </p>
<p>list_2 &#x3D; [‘abc’, ‘x’, ‘’, ‘kkk’]             #列表里面有4个元素，全部是字符串</p>
<p>list_3 &#x3D; []                                         #空列表 </p>
<p>list_4 &#x3D; [123, ‘xyz’, 3.14, [1, 2, ‘yy’]] #由多种元素组合起来的列表</p>
<ul>
<li>tuple（元组）</li>
</ul>
<p>元组是Python里面的容器之一，由小括号和小括号括起来 的数据构成。它的外型和列表非常像，只不过列表使用的 是方括号，元组使用的是小括号。“元组”中的“元”和 “二元一次方程”中的“元”是同一个意思，“组”就是组合的意思。</p>
<p>tuple_1 &#x3D; (1, 2, 3, 4, 5)         #元组里面有5个元素，全部为数字 </p>
<p>tuple_2 &#x3D; (‘abc’, ‘x’, ‘’, ‘kkk’) #元组里面有4个元素，全部是字符串 </p>
<p>tuple_3 &#x3D; ()                             #空元组 </p>
<p>tuple_4 &#x3D; (123, ‘xyz’, [1, ‘t’, ‘z’], (‘o’, ‘pp’)) #由多种元素组合起来的元组</p>
<ul>
<li>dictionary（字典）</li>
<li>set（集合）</li>
</ul>
<p>不可变数据类型有：Number、String、Tuple； 可变数据类型有：List、Dictionary、Set。</p>
<p><strong>元组和列表的区别：</strong></p>
<p>列表: L&#x3D;[1,2,5,7]  </p>
<p>元组: T&#x3D;(1,2,5,7)</p>
<p>列表生成以后还可以往里面继续添加数据，也可以从里面删除数据；但是元组一旦生成就不能修改。如果它里面只 有整数、浮点数、字符串、另一个元组，就既不能添加数据，也不能删除数据，还不能修改里面数据的值。但是如 果元组里面包含了一个列表，那么这个元组里面的列表依旧可以变化。</p>
<p>TT&#x3D;([a,b,c],12,“Hello”) </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">example_list=[<span class="string">&#x27;我&#x27;</span>,<span class="string">&#x27;是&#x27;</span>,<span class="string">&#x27;列&#x27;</span>,<span class="string">&#x27;表&#x27;</span>]</span><br><span class="line">example_tuple=[<span class="string">&#x27;我&#x27;</span>,<span class="string">&#x27;是&#x27;</span>,<span class="string">&#x27;元&#x27;</span>,<span class="string">&#x27;组&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>((example_list[<span class="number">1</span>]))</span><br><span class="line"><span class="built_in">print</span>((example_tuple[<span class="number">2</span>]))</span><br><span class="line"><span class="built_in">print</span>((example_list[-<span class="number">2</span>]))</span><br><span class="line"><span class="built_in">print</span>((example_tuple[-<span class="number">3</span>]))</span><br></pre></td></tr></table></figure>

<p><strong>字典：</strong></p>
<p>字典就是使用大括号括起来的键（Key）值（Value） 对（Key-Value对）。每个键值对之间使用英文逗号分隔， 每个Key与Value之间使用英文冒号分隔。</p>
<p>Key可以使用中文、英文或者数字，但是不能重复。Value 可以是任意字符串、数字、列表、元组或者另一个字典， Value可以重复。</p>
<p>可以通过Key来从字典中读取对应的Value，有3种主要的格式：  </p>
<p>变量名[key]  </p>
<p>变量名.get(key)  </p>
<p>变量名.get(key, ‘在找不到key的情况下使用这个值’) </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1=&#123;<span class="number">1</span>:<span class="string">&quot;good&quot;</span>,<span class="number">2</span>:<span class="string">&quot;bad&quot;</span>,<span class="number">3</span>:<span class="string">&quot;not good&quot;</span>&#125;</span><br><span class="line">value1=dict1.get(<span class="number">1</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(value1)</span><br><span class="line"></span><br><span class="line">good</span><br></pre></td></tr></table></figure>



<p><strong>集合：</strong></p>
<p>集合是使用大括号括起来的各种数据，可以看作没有 Value的字典。<strong>集合里面的元素不能重复。</strong>集合也是无序的。集合最大的应用之一就是去重。例如，<strong>把一个带有重复元素的列表先转换为集合，再转换回列表，那么重复元素就只会保留一个</strong>。把列表转换为集合需要使用set()函数， 把集合转换为列表使用list()函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">duplicated_list = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">unique_list = <span class="built_in">list</span>(<span class="built_in">set</span>(duplicated_list))</span><br><span class="line"><span class="built_in">print</span>(unique_list)</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;s&#x27;</span>]</span><br></pre></td></tr></table></figure>



<h3 id="运算符与表达式"><a href="#运算符与表达式" class="headerlink" title="运算符与表达式"></a>运算符与表达式</h3><p>算术运算符（ +、–、*、&#x2F;、**、&#x2F;&#x2F;、％ ）</p>
<p>关系运算符（ &gt;、&lt;、&gt;&#x3D;、&lt;&#x3D;、&#x3D; &#x3D;、!&#x3D; ）。  </p>
<p>逻辑运算符（and、or、not ）。  </p>
<p>位运算符（ &lt;&lt;、&gt;&gt;、~、|、^、&amp; ）。  </p>
<p>赋值运算符（ &#x3D;、复合赋值运算符 ）。 </p>
<p>成员运算符（ in、not in ）。  </p>
<p>同一运算符（ is、is not ）。  </p>
<p>下标运算符（ [ ] ）。  </p>
<p>其他（ 如函数调用运算符（））。 </p>
<p><strong>隐式类型转换：</strong></p>
<p>当有一个操作数的类型是复数时，其它数据都自动转换成复数类型。  </p>
<p>当有一个操作数的类型是小数时，其它数据都自动转换成小数类型。  </p>
<p>不支持数字和字符之间的隐式转换。  </p>
<p>数值的除法（&#x2F;）总是返回一个浮点数，要获取整数使用 &#x2F;&#x2F;操作符。  </p>
<p>混合计算时，Python会把整型转换成为浮点数。 </p>
<p>** 乘方运算</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In[]:<span class="number">4</span>*<span class="number">3</span>**<span class="number">2</span></span><br><span class="line">Out[]:<span class="number">36</span></span><br><span class="line"></span><br><span class="line">In[]:<span class="string">&quot;a&quot;</span>*<span class="number">10</span></span><br><span class="line">Out[]:<span class="string">&#x27;aaaaaaaaaa&#x27;</span></span><br><span class="line">    </span><br><span class="line">In[]:<span class="literal">True</span> <span class="keyword">and</span> <span class="number">0</span></span><br><span class="line">Out[]:<span class="number">0</span></span><br><span class="line">    </span><br><span class="line">In[]:<span class="literal">False</span> <span class="keyword">and</span> <span class="number">12</span></span><br><span class="line">Out[]:<span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">In[]:<span class="literal">True</span> <span class="keyword">or</span> <span class="number">0</span></span><br><span class="line">Out[]:<span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In[]:<span class="literal">False</span> <span class="keyword">or</span> <span class="number">12</span></span><br><span class="line">Out[]:<span class="number">12</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">In[]:x=y=<span class="number">2.5</span></span><br><span class="line">	z=<span class="number">2.5</span></span><br><span class="line">	x <span class="keyword">is</span> <span class="keyword">not</span> z</span><br><span class="line">Out[]:<span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">In[]:<span class="string">&#x27;a&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;abcd&#x27;</span></span><br><span class="line">Out[]: <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">In[]:<span class="string">&#x27;ac&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;abcd&#x27;</span></span><br><span class="line">Out[]:<span class="literal">False</span> </span><br><span class="line">    </span><br><span class="line">In[]:<span class="string">&#x27;a&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;b,c,d&#x27;</span></span><br><span class="line">Out[]:<span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">In[]:<span class="number">3</span> <span class="keyword">not</span> <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">Out[]:<span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p><strong>链式关系表达式:</strong></p>
<p>相当于多个表达式之间逻 辑与的关系。</p>
<p> 1 &lt; 2 &lt; 3 #等价于1 &lt; 2 and 2 &lt; 3  </p>
<p>2 &gt;&#x3D; 1 &gt; 10 #等价于2 &gt;&#x3D; 1 and 1 &gt; 10 </p>
<p><strong>Python中的函数分为内置函数和模块函数。</strong> </p>
<p><strong>内置函数:</strong></p>
<ul>
<li>内置函数（BIF，built-in functions）是Python内置对 象类型之一，不需要导入任何模块即可使用一类函数。 </li>
<li>执行dir(<strong>builtins</strong>)可以列出所有的内置函数;</li>
<li>使用help(函数名)可以查看某个函数的用法;  abs(x):返回数字x的绝对值或复数x的模;  bin(x)、oct(x)、hex(x):把整数x转换为二进制、八进 制、十六进制的表示形式。  bytes(x)：把指定对象x转换为字节串表示形式。 </li>
<li>float(x)：把整数或字符串x转换为浮点数；</li>
<li>int(x[, d])：返回实数（float）、分数（Fraction）或 高精度实数（Decimal）x的整数部分，或把d进制的字符 串x转换为十进制并返回，d默认为十进制；</li>
<li>chr(x)：返回Unicode编码为x的字符；</li>
<li>ord(x)：返回1个字符x的Unicode编码；</li>
<li>isinstance(obj, type)：测试对象obj是否属于指定类型 type；</li>
<li>type(obj)：返回对象obj的类型；</li>
<li>max(x)、 min(x)：返回可迭代对象x中的最大值、最小值；</li>
<li>len(obj)：返回对象obj包含的元素个数；</li>
<li>reversed(seq):返回seq中所有元素逆序后的迭代器对象;</li>
<li>sorted(iterable, key&#x3D;None, reverse&#x3D;False):返回排序后的列表，其中iterable表示要排序的序列或迭代对象， key用来指定排序规则或依据，reverse用来指定升序或降序，默认为升序。该函数不改变iterable内任何元素的顺序；</li>
<li>sum(x, start&#x3D;0)：返回序列x中所有元素之和；</li>
<li>exit()：退出当前解释器环境；</li>
</ul>
<p><strong>模块函数:</strong></p>
<ul>
<li><p>math模块 </p>
<p>math.pi 圆周率pi </p>
<p>math.e 自然常数e </p>
<p>math.tau 数学常数τ </p>
<p>math.inf 正无穷大 </p>
<p>math.nan 非浮点数标记，NaN(Not a  Number)</p>
</li>
<li><p>random模块</p>
<p>random.random() 返回[0.0,1.0]区间内的一个随机小数 random.random() 返回 0.9523521796999529</p>
<p>random.uniform(a,b) 返回[a,b]区间内的一个随机小数 random.uniform(1,3) 返回 2.3403540401554146</p>
<p>random.randint(a,b) 返回[a,b]区间内的一个随机整数 random.randint(1,3) 返回2</p>
<p>random.randrange([ start],end,[step]) 返回[start,end)区间内的一个整数， start和step默认都是1 random.randrange(1,10)返回 5</p>
<p>random.choice() 随机返回给定序列中的一个元素 random.choice([‘a’,’b’,’c’]) 返回’c‘</p>
<p>random.shuffle(x,[ra ndom]) 将可变序列的所有元素随机排列 random.shuffle([1,2,3,4]) 返回[1, 4, 3, 2]</p>
</li>
</ul>
<h3 id="输入输出与字符串"><a href="#输入输出与字符串" class="headerlink" title="输入输出与字符串"></a>输入输出与字符串</h3><p>input(“提示字符串”)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="built_in">input</span>(<span class="string">&quot;请输入:&quot;</span>)</span><br><span class="line"><span class="built_in">type</span>(x)</span><br></pre></td></tr></table></figure>

<p>input() 函数的返回结果都是字符串，实际使用时需要将其转换为相应的类型再进行处理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入:&quot;</span>))</span><br><span class="line"><span class="built_in">type</span>(x)</span><br></pre></td></tr></table></figure>

<p>input() 结合 <strong>eval()</strong> 可同时接受多个数据输入， 多个输入之间的间隔符必须是逗号。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a,b,c = <span class="built_in">eval</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入a,b,c三个数：&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(a,b,c,sep=<span class="string">&quot;,&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>实现多值输入，也可以使用 <strong>split()</strong> 方法进行输 入值的分割，不同的值之间以空格分隔。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x,y = <span class="built_in">input</span>(<span class="string">&#x27;请输入2个值:&#x27;</span>).split()</span><br><span class="line"><span class="built_in">print</span>(x,y,sep=<span class="string">&#x27;,&#x27;</span>)</span><br></pre></td></tr></table></figure>



<p>print()函数的格式如下： </p>
<p>print([objects, sep&#x3D;’ ‘ &#x2F; end&#x3D;’\n’ &#x2F; file&#x3D;sys.stdout &#x2F; flush&#x3D;False) </p>
<p>objects是输出的对象，多个对象之间用英文逗号分割； sep是对象之间插入的分隔符，默认是空格； end是添加在输出文本最后的一个字符，默认是换行符； file指定输出内容发送到的文件，默认是显示器； flush指定输出的内容是否立即写文件。</p>
<p>字符串格式化%输出：</p>
<p>“%格式控制符”%实际参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;名字: %s,年龄: %d&#x27;</span> %(<span class="string">&#x27;张三&#x27;</span>,<span class="number">20</span>))</span><br></pre></td></tr></table></figure>



<p>字符串的 format 方法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;:计算机&#123;&#125;的CPU占用率为&#123;&#125;%.&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;2022-03-15&#x27;</span>,<span class="string">&#x27;python&#x27;</span>,<span class="number">10</span>))</span><br></pre></td></tr></table></figure>



<p>使用位置（序号）索引：<br>花括号内部可以写上待输出的目标字符串的索引，也可以省略。如果省略，则按format后面的括号里的待输出的目标字符串顺序依次替换。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;1&#125;&#123;0&#125;&#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;言&#x27;</span>,<span class="string">&#x27;文&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>使用“{序号：格式说明符}” 形式的格式说明符：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;0:.2f&#125;,&#123;1&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">3.1415926</span>,<span class="number">100</span>))</span><br></pre></td></tr></table></figure>

<p> 使用关键字索引：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello,&#123;boy&#125; and &#123;girl&#125;!&quot;</span>.<span class="built_in">format</span>(boy=<span class="string">&quot;John&quot;</span>,girl=<span class="string">&quot;Mary&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;a&#125;&#123;b&#125;&quot;</span>.<span class="built_in">format</span>(b=<span class="string">&quot;3&quot;</span>,a=<span class="string">&quot;Python&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>使用属性索引：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = <span class="number">3</span>-<span class="number">5j</span></span><br><span class="line"><span class="built_in">print</span>((<span class="string">&#x27;复数&#123;0&#125;的实部为&#123;0.real&#125;,虚部为&#123;0.imag&#125;。&#x27;</span>.<span class="built_in">format</span>(C)))</span><br></pre></td></tr></table></figure>

<p>使用下标索引：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">coord = (<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;X:&#123;0[0]&#125;; Y:&#123;0[1]&#125;;Z:&#123;0[2]&#125;&#x27;</span>.<span class="built_in">format</span>(coord))</span><br></pre></td></tr></table></figure>



<p><strong>字符串访问方式：</strong></p>
<p>左闭右开原则</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;Python大数据基础与实战&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">0</span>],<span class="built_in">str</span>[<span class="number">5</span>],<span class="built_in">str</span>[-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">2</span>:<span class="number">6</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[:<span class="number">6</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">6</span>:])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[:])</span><br></pre></td></tr></table></figure>

<p><strong>字符串的分片：</strong></p>
<p><strong>str[i:j:k]：</strong>i是索引起始位置，j是索引结束位置但<strong>不包括位置上的字符</strong>，索引编号每次增加的步长为k。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1=<span class="string">&quot;Python&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str1[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(str1[<span class="number">2</span>:<span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(str1[<span class="number">0</span>:-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(str1[<span class="number">1</span>:<span class="number">5</span>:<span class="number">2</span>])</span><br></pre></td></tr></table></figure>

<p><strong>字符串查找</strong></p>
<ul>
<li><strong>find() 和 rfind()</strong> 函数分别用来查找一个字符串在另一个字符串指定范围（默认是整个字符串）中<strong>首次</strong>和最后一次出现的位置，如果不存在则返回-1；</li>
<li><strong>index() 和 rindex()</strong> 方法用来返回一个字符串在另一个字符串指定范围中<strong>首次</strong>和<strong>最后一次</strong>出现的位置，如果不存在则抛出异常；</li>
<li><strong>count()<strong>方法用来返回一个字符串在当前字符串中</strong>出现的次数</strong>。</li>
</ul>
<p><strong>字符串分割</strong></p>
<ul>
<li>**split()、rsplit()**方法分别用来以指定字符为分隔符，把当前字符串从左往右、从右往左分隔成多个字符串，并返回包含分隔结果的列表。</li>
<li>对于 <strong>split() 和 rsplit()</strong> 方法，如果不指定分隔符，则字符串中的任何空白符号（空格、换行符、制表符等）都将被认为是分隔符， 把连续多个空白字符看作一个分隔符。</li>
<li>对于split() 和rsplit() 方法，如果不指定分隔符，则字符串中的任何空白符号（空格、换行符、制表符等）都将被认为是分隔符， 把连续多个空白字符看作一个分隔符。</li>
</ul>
<p><strong>字符串的连接</strong></p>
<p><strong>join()</strong> 方法用来将列表中的多个字符串进行连接，并且在相邻两个字符串之间插入指定字符。示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test = [<span class="string">&quot;I&quot;</span>,<span class="string">&quot;love&quot;</span>,<span class="string">&quot;Python&quot;</span>]</span><br><span class="line">s = <span class="string">&quot;&quot;</span>.join(test)	<span class="comment">#指定插入字符为空格</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure>

<p><strong>注意：使用“+”运算符也可以连接字符串，但是效率 较低，应优先使用join()方法。</strong></p>
<p><strong>字符串的大小写转换</strong></p>
<p>lower() 返回小写字符串，<strong>upper()</strong> 返回<strong>大写</strong>字符串， <strong>capitalize()</strong> 将<strong>字符串****首字符大写</strong>、<strong>title()</strong> 将字符串中每个<strong>单词首字符大写</strong>、<strong>swapcase()</strong> 完成<strong>大小写互换</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;i am a teacher&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.lower())</span><br><span class="line"><span class="built_in">print</span>(s.upper())</span><br><span class="line"><span class="built_in">print</span>(s.capitalize())</span><br><span class="line"><span class="built_in">print</span>(s.title())</span><br><span class="line"><span class="built_in">print</span>(s.swapcase())</span><br></pre></td></tr></table></figure>



<p> <strong>字符串替换</strong></p>
<p>replace() 方法把字符串中的 old（旧字符串）替换成 new(新字符串)，如果指定第三个参数max，则替换不超过 max次。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;this is string example..wow!!!this is really string&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.replace(<span class="string">&quot;is&quot;</span>,<span class="string">&quot;was&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.replace(<span class="string">&quot;is&quot;</span>,<span class="string">&quot;was&quot;</span>,<span class="number">3</span>))</span><br></pre></td></tr></table></figure>



<p><strong>字符串删除</strong></p>
<p><strong>strip()</strong> 删除字符串<strong>两端指定的字符</strong>，<strong>rstrip() 删除</strong>字符串<strong>右端</strong>指定字符，<strong>lstrip()</strong> 删除字符串<strong>左端</strong>指定字符。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot; he is a student\t\t&quot;</span></span><br><span class="line"><span class="comment">#删除s左右两端的的空白字符</span></span><br><span class="line"><span class="built_in">print</span>(s.strip())</span><br><span class="line"><span class="built_in">print</span>(s.rstrip(<span class="string">&quot;\t&quot;</span>))</span><br><span class="line"><span class="string">&#x27;aabbccddeeeffg&#x27;</span>.strip(<span class="string">&#x27;gaef&#x27;</span>)</span><br></pre></td></tr></table></figure>



<p><strong>字符串测试</strong></p>
<p>isalnum()、isalpha()、isdigit()、isdecimal()、isnumeric()、 isspace()、isupper()、islower()，分别测试字符串是否为数字或字母、是否为字母、是否为数字字符、是否为空白字符、是否为大写字母以及是否为小写字母。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;1234abcd&#x27;</span>.isalnum())</span><br><span class="line"><span class="comment">#全部为英文字母时返回True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;1234abcd&#x27;</span>.isalpha())</span><br><span class="line"><span class="comment">#全部为数字时返回True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;1234abcd&#x27;</span>.isdigit())</span><br></pre></td></tr></table></figure>



<p><strong>eval()</strong></p>
<p>内置函数eval()尝试把任意字符串转化为Python表达式并求值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;10 * 2 / 5&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">4.0</span></span><br></pre></td></tr></table></figure>



<p><strong>startswith()、endswith()</strong></p>
<p>这两个方法用来判断字符串是否以指定字符串开始 或者结束。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;test.py&quot;</span>.endswith((<span class="string">&quot;.py&quot;</span>,<span class="string">&quot;.cpp&quot;</span>,<span class="string">&quot;.java&quot;</span>))) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;test.py&quot;</span>.startswith(<span class="string">&quot;test&quot;</span>,<span class="number">0</span>))			  <span class="comment"># True	</span></span><br></pre></td></tr></table></figure>



<p><strong>center()、ljust()、rjust()</strong></p>
<p>返回指定宽度的新字符串，原字符串居中、左对齐或右对齐出现在新字符串中，如果指定的宽度大于字符串长度，则使用指定的字符（默认为空格）填充。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;let&#x27;s begin&quot;</span>.center(<span class="number">20</span>,<span class="string">&quot;+&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;let&#x27;s begin&quot;</span>.ljust(<span class="number">20</span>,<span class="string">&quot;-&quot;</span>))</span><br></pre></td></tr></table></figure>

<p> ++++let’s begin+++++</p>
<p>let’s begin———</p>
<p><strong>字符串对象常用的方法</strong></p>
<ul>
<li><p><strong>字母大小写转换</strong></p>
<ul>
<li><p>s.upper():全部转换为大写字母。</p>
</li>
<li><p>s.lower():全部转换为小写字母。</p>
</li>
<li><p>s.swapcase():字母大小写互换。</p>
</li>
<li><p>s.capitalize():句子首字母大写，其余小写。</p>
</li>
<li><p>s.title():单词首字母大写。</p>
<p>其中，s是一个字符串对象</p>
</li>
</ul>
</li>
<li><p><strong>字符串搜索</strong></p>
<ul>
<li>s.find(substr,[start,[end]])：返回s中出现substr的第1个字符的编号，如果s中没有substr则返回-1。start和end作用就相当于在s[start:end]中搜索。</li>
<li>s.index(substr,[start,[end]])：与find()相同，只是在s中没有substr时，会返回一个运行错误。</li>
<li>s.rfind(substr,[start,[end]])：<strong>返回s中最后出现的substr的第1个字符的编号</strong>，如果s中没有substr则返回-1，也就是说<strong>从右边算起的第1次出现的substr的首字符编号。</strong></li>
<li>s.rindex(substr,[start,[end]])：与rfind()相同，只是在s中没有substr时，会返回一个运行时错误。</li>
<li>s.count(substr,[start,[end]])：计算substr在s中出现的次数。</li>
<li>s.startswith(prefix,[start,[end]])：是否<strong>以prefix开头</strong>，若是返回True，否则返回False。</li>
<li>s.endswith(suffix,[start[end]])：<strong>以suffix结尾</strong>，若是返回 True，否则返回False。</li>
</ul>
</li>
<li><p><strong>字符串替换</strong></p>
<ul>
<li>s.replace(oldstr,newstr,[count])：把s中的oldster替换为 newstr，count为替换次数。这是替换的通用形式，还有一些函数进行特殊字符的替换。</li>
<li>s.strip([chars])：把s中前后chars中有的字符全部去掉，可以理解为把s前后chars替换为None。默认去掉前后空格。</li>
<li>s.lstrip([chars])：把s左边chars中有的字符全部去掉。默认去掉左边空格。</li>
<li>s.rstrip([chars])：把s右边chars中有的字符全部去掉。默认去掉右边空格。</li>
<li>s.expandtabs([tabsize])：把s中的tab字符替换为空格，每个tab替换为tabsize个空格，默认是8个。</li>
</ul>
</li>
<li><p><strong>字符串的拆分与组合</strong></p>
<ul>
<li>s.split([sep,[maxsplit]])：以sep为分隔符，把<strong>字符串s拆分成一个列表</strong>。默认的分隔符为空格。<strong>maxsplit表示拆分的次数</strong>，默认取-1，表示无限制拆分。</li>
<li>s.rsplit([sep,[maxsplit]])：从右侧把字符串s拆分成一个列表。</li>
<li>s.splitlines([keepends])：把s按行拆分为一个列表。 keepends是一个逻辑值，如果为True，则每行拆分后会保留行分隔符。</li>
<li><strong>s.join(seq)：</strong>把seq代表的序列组合成字符串，用s将序列各元素连接起来。字符串中的字符是不能修改的，如果要修改，通常的方法是，用 list()函数把字符串s变为以单个字符为成员的列表(使用语句s&#x3D;list(s))，再使用给列表成员赋值的方式改变值(如s[3]&#x3D;’a’)，最后再使用语句 “s&#x3D;””.join(s)”还原成字符串。</li>
</ul>
</li>
<li><p>字符串类型测试</p>
<p>​    字符串类型测试函数返回的都是逻辑值。</p>
<ul>
<li>s.isalnum()：是否全是字母和数字，并至少有一个字符。</li>
<li>s.isalpha()：是否全是字母，并至少有一个字符。</li>
<li>s.isdigit()：是否全是数字，并至少有一个字符。</li>
<li>s.isspace()：是否全是空格，并至少有一个空格。</li>
<li>s.islower()：s中的字母是否全是小写。</li>
<li>s.isupper()：s中的字母是否全是大写。</li>
<li>s.istitle()：s是否为首字母大写。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫</title>
    <url>/2022/03/26/python%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<h3 id="python爬虫工作原理"><a href="#python爬虫工作原理" class="headerlink" title="python爬虫工作原理"></a>python爬虫工作原理</h3><p><strong>获取数据：</strong></p>
<p>爬虫程序会根据我们提供的网址，向服务器发起请求，然后返回数据。</p>
<p><strong>解析数据：</strong></p>
<p>爬虫程序会把服务器返回的数据解析成我们能读懂的格式。</p>
<p><strong>提取数据：</strong></p>
<p>爬虫程序再从中提取出我们需要的数据。</p>
<p><strong>储存数据:</strong><br>爬虫程序把这些有用的数据保存起来,便于你以后的使用和分析。</p>
<span id="more"></span>

<h4 id="requests库"><a href="#requests库" class="headerlink" title="requests库"></a>requests库</h4><p>requests库可以帮我们下载网页源代码、文本、图片，甚至是音频。</p>
<p><strong>requests.get()</strong></p>
<p>requests.get 是在调用 requests 库中的 get() 方法，它向服务器发送了一个请求，括号里的参数是你需要的数据所在的网址，然后得到了服务器的响应。服务器返回的结果是个 Response 对象。</p>
<p>response对象常用的四个属性：</p>
<p><img src="/../resources/image-20220410100554836.png" alt="image-20220410100554836"></p>
<p><strong>response.status_code属性：</strong></p>
<p><img src="/../resources/image-20220410100621487.png" alt="image-20220410100621487"></p>
<p><strong>response.content属性：</strong></p>
<p>该属性能把Response对象的内容以二进制数据的形式返回，适用于图片、音频、视频的下载。</p>
<p><strong>response.text属性：</strong></p>
<p>该属性可以把Response对象的内容以字符串的形式返回， 适用于文字、网页源代码的下载。</p>
<p><strong>response.encoding属性：</strong></p>
<p>该属性能帮我们定义Response对象的编码。 遇上输出的文本有乱码问题，才考虑用res.encoding。首先，目标数据本身是什么编码是未知的。用requests.get() 发 送请求后，会取得一个Response对象，其中，requests库会对数据的编码类型做出自己的判断。但是这个判断有可能准确，也可能不准确。 如果它判断准确的话，打印出来的response.text的内容就是正常的、没有乱码的，就无需用res.encoding；如果判断不准确，就会出现一堆乱码，那我们就可以去查看目标数据的编码，然后再用res.encoding把编码定义成和目标数据一 致的类型即可。</p>
<h4 id="robots协议"><a href="#robots协议" class="headerlink" title="robots协议"></a>robots协议</h4><p>查看robots协议，在网站的域名后加上 &#x2F;robots.txt</p>
<p><img src="/../resources/image-20220410101501845.png" alt="image-20220410101501845"></p>
<h4 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h4><p>HTML文档包含了HTML标签（TAG）和元素，通过它们来描述网页。Web浏览器的作用是将HTML源文件转化成 网页形式，并显示出它们。浏览器本身并不会显示出HTML 标签，而是使用它们来解释页面的内容。</p>
<p><img src="/../resources/image-20220410101613520.png" alt="image-20220410101613520"></p>
<p>HTML常见标签：</p>
<p><img src="/../resources/image-20220410101647072.png" alt="image-20220410101647072"></p>
<h4 id="解析数据"><a href="#解析数据" class="headerlink" title="解析数据"></a>解析数据</h4><p>我们平时使用浏览器上网，浏览器会把服务器返 回来的HTML源代码翻译为我们能看懂的样子，之后我们才能在网页上做各种操作。 而在爬虫中，也要使用能读懂html的工具，才能提取到想要的数据。</p>
<p><strong>【提取数据】</strong>是指把我们需要的数据从众多数据中挑选出来。</p>
<p><img src="/../resources/image-20220410102609214.png" alt="image-20220410102609214"></p>
<p>在括号中，要输入两个参数，第0个参数是要被解析的文本，注意了，它必须是字符串。 括号中的第1个参数用来标识解析器，我们要用的是一个 Python内置库：html.parser。（它不是唯一的解析器，但是比较简单的）</p>
<p>以该网站为例（url： <a href="https://localprod.pandateacher.com/python%02manuscript/crawler-html/spider-men5.0.html%EF%BC%89%E5%81%87%E8%AE%BE%E6%88%91%E4%BB%AC%E6%83%B3%E7%88%AC%E5%8F%96%E7%BD%91%E9%A1%B5%E4%B8%AD%E7%9A%84%E4%B9%A6%E7%B1%8D%E7%B1%BB%E5%9E%8B%E3%80%81%E4%B9%A6%E5%90%8D%E3%80%81%E9%93%BE%E6%8E%A5%E3%80%81%E5%92%8C%E4%B9%A6%E7%B1%8D%E4%BB%8B%E7%BB%8D%E3%80%82%E6%A0%B9%E6%8D%AE%E4%B9%8B">https://localprod.pandateacher.com/pythonmanuscript/crawler-html/spider-men5.0.html）假设我们想爬取网页中的书籍类型、书名、链接、和书籍介绍。根据之</a> 前所学的 requests.get()，我们可以先获取到一个Response对象，并确认自己获取成功：</p>
<p><img src="/../resources/image-20220410110621682.png" alt="image-20220410110621682"></p>
<p>接着用BeautifulSoup解析数据，请特别留意第2行和第6 行新增的代码。第2行是引入BeautifulSoup库。第6行中的第 0个参数，必须是字符串类型；括号中的第1个参数是解析器。 这就是解析数据的用法。</p>
<p><img src="/../resources/image-20220410110641745.png" alt="image-20220410110641745"></p>
<p>接下来，我们来打印看看soup的数据类型，和soup本身 （第7行开始为新增代码）。</p>
<p> import requests </p>
<p>from bs4 import BeautifulSoup </p>
<p>res &#x3D;  requests.get(‘<a href="https://localprod.pandateacher.com/python-manuscript/crawler-html/spider-men5.0.html&#39;">https://localprod.pandateacher.com/python-manuscript/crawler-html/spider-men5.0.html&#39;</a>)  </p>
<p>soup &#x3D; BeautifulSoup( res.text,’html.parser’) </p>
<p>print(type(soup)) #查看soup的类型 </p>
<p>print(soup) # 打印soup</p>
<p>代码运行结果：</p>
<p><img src="/../resources/image-20220410110850553.png" alt="image-20220410110850553"></p>
<ul>
<li><p>soup的数据类型是， 说明soup是一个BeautifulSoup对象。打印的soup， 它是所请求网页的完整HTML源代码。我们所要提取的书名、链接、书籍内容这些数据都在这里面。</p>
</li>
<li><p>打印soup出来的源代码和我们之前使用 response.text 打印出来的源代码是完全一样的。</p>
</li>
<li><p>虽然 response.text 和 soup 打印出的内容一样，但它们属于不同的类： &lt;class ‘str’&gt;与&lt;class ‘bs4.BeautifulSoup’&gt;。前者是字符串，后者是已经被解析过的 BeautifulSoup 对象。之所以打印出来的是一样的文本，是因为 BeautifulSoup 对象在直 接打印它的时候会调用该对象内的 str 方法，所以直接打印 bs 对象显示字符串是str的返回结果。</p>
</li>
<li><p>之后还会用 BeautifulSoup 库来提取数据，如果这不是一 个 BeautifulSoup 对象，就没法调用相关的属性和方法的，所以，用 BeautifulSoup 解析数据是非常有用的，并不是重复劳动。</p>
</li>
<li><p><img src="/../resources/image-20220410111622337.png" alt="image-20220410111622337"></p>
</li>
</ul>
<p>仍然使用BeautifulSoup来提取数据。</p>
<p><img src="/../resources/image-20220410111721377.png" alt="image-20220410111721377"></p>
<p>find() 与 find_all()</p>
<p><img src="/../resources/image-20220410112341145.png" alt="image-20220410112341145"></p>
<p>Tag类对象的常用属性和方法</p>
<p><img src="/../resources/image-20220410112633026.png" alt="image-20220410112633026"></p>
<h4 id="定制请求头"><a href="#定制请求头" class="headerlink" title="定制请求头"></a>定制请求头</h4><p>最好将自己的爬虫伪装成真实的浏览器——因为在这种情况下，服务器很可能拒绝爬虫访问。甚至有的网站，一开始就不允许爬虫访问。 如，知乎、猫眼电影等。</p>
<p>每一个 request 请求，都会有一个Requests Headers，把它称作请求头。 它里面会有一些关于该请求的基本信息，比如：这个请求是从什么设备 什么浏览器上发出？这个请求是从哪个页面跳转而来？ user-agent会记录你电脑的信息和浏览器版本（如图，就是windows10的64位操作系统， 使用谷歌浏览器），它最大的应用是帮助我们应对“反爬虫”技术。</p>
<p><img src="/../resources/image-20220410113019785.png" alt="image-20220410113019785"></p>
<p>基于【豆瓣官网】【下厨房】等网站突然IP反爬的情况， 程序开始需要加上headers里的 user-agent，以后面的实操例 子下厨房为例，user-agent在这里。</p>
<p><img src="/../resources/image-20220410113100826.png" alt="image-20220410113100826"></p>
<p>给爬虫代码加上请求头后是这样的 <strong>headers&#x3D;{‘User-Agent’: ‘Mozilla&#x2F;5.0 (Windows NT 10.0;  Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko)  Chrome&#x2F;86.0.4240.193 Safari&#x2F;537.36’}</strong> 这个请求头是万能的，可以直接保存下来，后面加请求头都可以直接使用。 注意！！！提取数据那一行的第二个参数也要加上请求头！！！</p>
<p><img src="/../resources/image-20220410113214914.png" alt="image-20220410113214914"></p>
<p>从最开始用requests库获取数据，到用BeautifulSoup库来解析数据，再继续用BeautifulSoup库提取数据，不断经历的是操作对象的类型转换</p>
<p><img src="/../resources/image-20220410113315426.png" alt="image-20220410113315426"></p>
<p>例子：</p>
<p><img src="/../resources/image-20220410160211171.png" alt="image-20220410160211171"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python序列结构</title>
    <url>/2022/03/25/python%E5%BA%8F%E5%88%97%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h3 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h3><p>序列（sequence）是一种用来存放多个值的数据类型，序列中对象类型可以相同也可以不同。</p>
<p>序列中的每个元素可以通过索引来进行访问 （集合类型除外）。</p>
<p>序列按照其中的元素是否可变分为<strong>可变序列</strong>和<strong>不可变序列</strong>，按照元素是否有序分为有序序列和无序序列。<span id="more"></span></p>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>列表是Python内置的有序、可变序列，列表的所有元素放 在一对中括号“[]”中，并使用逗号分隔开。</p>
<p>在Python中，一个列表中的数据类型可以各不相同，可以同时为整数、实数、字符串等基本类型，甚至是列表、元组、字典、集合以及其他自定义类型的对象。</p>
<p>例如：</p>
<p>[‘Google’, ‘Baidu’, 1997, 2008] </p>
<p> [1, 2, 3, 4, 5 ] </p>
<p> [“a”, “b”, “c”, “d”] </p>
<p> [123, [“das”, “aaa”], 234]</p>
<p>列表是Python中最具灵活性的有序集合对象类型。<strong>和字符串不同</strong>的是，列表具有可变长度、异构以及任意嵌套列表的特点。</p>
<h4 id="列表的创建"><a href="#列表的创建" class="headerlink" title="列表的创建"></a>列表的创建</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst1 = [<span class="string">&quot;cat&quot;</span>,<span class="string">&quot;dog&quot;</span>,<span class="string">&quot;tiger&quot;</span>,<span class="string">&quot;1024&quot;</span>]</span><br><span class="line">lst2 = [<span class="number">31</span>,<span class="number">32</span>,<span class="number">101.45</span>,<span class="string">&quot;door&quot;</span>]</span><br><span class="line">lst3 = [<span class="number">1</span>,<span class="number">2</span>,[<span class="string">&#x27;hello&#x27;</span>,<span class="number">5</span>]]</span><br><span class="line"><span class="built_in">print</span>(lst1,lst2)</span><br><span class="line"><span class="built_in">print</span>(lst3)</span><br></pre></td></tr></table></figure>

<p><img src="/../resources/image-20220325124452772-16481835007181.png"></p>
<p>也可以使用list()函数将元组、range对象、字符串或其他类型的可迭代对象类型的数据转换为列表。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = <span class="built_in">list</span>(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">list2 = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(list1)</span><br><span class="line"><span class="built_in">print</span>(list2)</span><br></pre></td></tr></table></figure>

<p><img src="/../resources/image-20220325124606993.png" alt="image-20220325124606993"></p>
<h4 id="列表元素的访问与计数"><a href="#列表元素的访问与计数" class="headerlink" title="列表元素的访问与计数"></a>列表元素的访问与计数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="string">&quot;abcd&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(a))</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">6</span>][<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<p><img src="/../resources/image-20220325124943481.png" alt="image-20220325124943481"></p>
<p>使用列表对象的index()方法获取指定元素首次出现的下标，若列表对象中不存在指定元素，则抛出异常。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">aList=[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5.5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">17</span>]</span><br><span class="line"><span class="built_in">print</span>(aList.index(<span class="number">7</span>))</span><br><span class="line"><span class="built_in">print</span>(aList.index(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<p><img src="/../resources/image-20220325125357558.png" alt="image-20220325125357558"></p>
<h4 id="改变列表元素值"><a href="#改变列表元素值" class="headerlink" title="改变列表元素值"></a>改变列表元素值</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过修改下标修改列表里的值</span></span><br><span class="line">x = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">x[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表元素分段改变</span></span><br><span class="line">name = <span class="built_in">list</span>(<span class="string">&#x27;Perl&#x27;</span>)</span><br><span class="line">name[<span class="number">1</span>:] = <span class="built_in">list</span>(<span class="string">&#x27;ython&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(name)</span><br></pre></td></tr></table></figure>

<p><img src="/../resources/image-20220325130038347.png" alt="image-20220325130038347"></p>
<p><img src="/../resources/image-20220325130249929.png" alt="image-20220325130249929"></p>
<h4 id="列表元素添加"><a href="#列表元素添加" class="headerlink" title="列表元素添加"></a>列表元素添加</h4><p><strong>append()方法</strong>：通过append()方法在当前列表尾部追加元素，是原地修改列表，速度较快。 </p>
<p><strong>extend()方法</strong>：使用列表对象的extend()方法可以将另一个迭代对象的所有元素添加至该列表对象尾部。通过extend()方法来增加列表元素也不改变其内存首地址，属于原地操作。</p>
<p><strong>insert()方法：</strong>使用列表对象的insert(index,x)方法可以将元素添 加至列表的指定位置。</p>
<p><strong>注意：</strong></p>
<p>采用 + 和 * 的方式在形式上简单容易理解， 但严格意义上并不是真的为列表添加元素，而是有可能会被处理为<strong>创建一个新的列表</strong>，并将原列表中的元素和新元素依次复制到新列表的内存空间。</p>
<p>由于涉及大量元素的复制，该操作速度较慢，对于列表元素较多和进行大量数据操作过程中从性能的考 虑不建议使用该方法。</p>
<h4 id="列表元素删除"><a href="#列表元素删除" class="headerlink" title="列表元素删除"></a>列表元素删除</h4><p>使用 <strong>del</strong> 命令删除列表中指定位置的元素。如同一般的变量，del命令也可以删除整个列表变量。</p>
<p>使用列表的 <strong>pop</strong> 方法删除并返回指定位置（默认为最后一个）上的元素。若指定的索引超出列表的范围，会抛出异常。</p>
<p>使用列表的 <strong>remove()</strong> 方法删除<strong>首次</strong>出现的元素。 若没有此元素，会抛出异常。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = [<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;n&#x27;</span>]</span><br><span class="line"><span class="keyword">del</span> name[<span class="number">1</span>]</span><br><span class="line">name[<span class="number">1</span>:<span class="number">4</span>] = []</span><br><span class="line"><span class="built_in">print</span>(name)</span><br></pre></td></tr></table></figure>

<p><img src="/../resources/image-20220325131211578.png" alt="image-20220325131211578"></p>
<h4 id="列表元素的排序和反转"><a href="#列表元素的排序和反转" class="headerlink" title="列表元素的排序和反转"></a>列表元素的排序和反转</h4><p>列表结构具有对象自身提供的<strong>sort()方法</strong>进行原地排序，即这种排序是永久性排序，将会按照顺序改变列表中元素的次序。</p>
<p>若要按与字母顺序相反的顺序排列列表元素，只需向sort()方法传递参数 reverse&#x3D;True。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">cars = [<span class="string">&#x27;bmw&#x27;</span>,<span class="string">&#x27;audi&#x27;</span>,<span class="string">&#x27;toyota&#x27;</span>,<span class="string">&#x27;subaru&#x27;</span>]</span><br><span class="line">cars.sort()</span><br><span class="line"><span class="built_in">print</span>(cars)</span><br><span class="line">cars.sort(reverse = <span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(cars)</span><br></pre></td></tr></table></figure>

<p><img src="/../resources/image-20220325131409835.png" alt="image-20220325131409835"></p>
<p>要保留列表元素原来的排列顺序，同时以特定的顺序呈现它，可使用内置函数**sorted()**。</p>
<p>sorted(iterable, key &#x3D; None, reverse &#x3D; False)     返回系列的排序列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cars = [<span class="string">&#x27;bmw&#x27;</span>,<span class="string">&#x27;audi&#x27;</span>,<span class="string">&#x27;toyota&#x27;</span>,<span class="string">&#x27;subaru&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(cars))</span><br><span class="line"><span class="built_in">print</span>(cars)</span><br><span class="line">s3 = <span class="string">&#x27;abAC&#x27;</span></span><br><span class="line"><span class="built_in">sorted</span>(s3, key = <span class="built_in">str</span>.lower)</span><br></pre></td></tr></table></figure>

<p><img src="/../resources/image-20220325155941681.png" alt="image-20220325155941681"></p>
<p>sorted() 排序后会生成新列表，原列表不会改变。</p>
<p>reverse() 方法用于将列表所有元素逆序或翻转。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">15</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">10</span>,<span class="number">19</span>,<span class="number">13</span>,<span class="number">18</span>,<span class="number">11</span>,<span class="number">17</span>,<span class="number">12</span>,<span class="number">9</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))</span><br><span class="line">b = <span class="built_in">sorted</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(b))</span><br><span class="line">a.sort(key=<span class="built_in">str</span>) <span class="comment"># 原地排序，指定排序依据根据字符串大小</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))</span><br><span class="line">a.reverse()		<span class="comment"># 反转列表，原地操作</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))</span><br></pre></td></tr></table></figure>

<p><img src="/../resources/image-20220325161052956.png" alt="image-20220325161052956"></p>
<h4 id="列表切片"><a href="#列表切片" class="headerlink" title="列表切片"></a>列表切片</h4><p>使用语法 **“list_name[start : end : step]” **来返回列表list_name 的一个片段。start表示切片开始位置，默认为0；end表示切片截止（但不包含）位置，默认为列表长度；step表示切片的步长，默认为1。</p>
<p>当start为0时可以省略，当end为列表长度时可以省略，当 step为1时可以省略，省略步长时还可以同时省略最后一 个冒号。</p>
<p>当step为负整数时，表示反向切片，这时start位置应该在 end位置的右侧，否则会返回空列表，start默认为-1，end 默认为列表第1个元素前面的位置。-1表示列表最后一个元素的位置，其它以此类推。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line"><span class="built_in">print</span>(numbers[::])		<span class="comment">#返回包含原列表中所有元素的新列表</span></span><br><span class="line"><span class="built_in">print</span>(numbers[::<span class="number">2</span>])		<span class="comment">#从第1个元素开始，隔1个取1个元素	</span></span><br><span class="line"><span class="built_in">print</span>(numbers[::-<span class="number">1</span>])	<span class="comment">#反向切片</span></span><br><span class="line"><span class="built_in">print</span>(numbers[<span class="number">1</span>:<span class="number">3</span>])		<span class="comment">#指定切片开始位置和结束位置，默认步长为1</span></span><br><span class="line"><span class="built_in">print</span>(numbers[<span class="number">1</span>::<span class="number">2</span>])	<span class="comment">#指定切片开始位置和步长，省略结束位置</span></span><br></pre></td></tr></table></figure>



<p><img src="/../resources/image-20220325171227747.png" alt="image-20220325171227747"></p>
<p>使用切片获取列表的部分元素，可以返回列表中部分元素组成的新列表。切片操作不会因为下标越界而抛出异常，而是简单地在列表尾部截断或者返回一个空列表，代码具有更强的健壮性。</p>
<p>使用切片为列表增加&#x2F;删除元素，可以使用切片操作在列表任意位置插入新元素，但 是并不影响列表对象的内存地址，属于原地操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">num[<span class="built_in">len</span>(num):] = [<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line"><span class="built_in">print</span>(num)</span><br><span class="line">num[:<span class="number">0</span>] = [-<span class="number">2</span>,-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(num)</span><br><span class="line">aList = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line">aList[:<span class="number">3</span>] = []</span><br><span class="line"><span class="built_in">print</span>(aList)</span><br></pre></td></tr></table></figure>

<p><img src="/../resources/image-20220325172545950.png" alt="image-20220325172545950"></p>
<p><strong>shuffle() 函数</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">lsit1=[<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">12</span>]</span><br><span class="line">random.shuffle(list1)</span><br><span class="line">list1</span><br></pre></td></tr></table></figure>

<p><img src="/../resources/image-20220325173802069.png" alt="image-20220325173802069"></p>
<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>列表的功能虽然很强大，但负担也很重，在很大程度上影响了运行效率。有时候我们并不需要那么多功能，很希望能有个轻量级的列表，元组（tuple）正是这样一种类型。 </p>
<p>列表和元组都属于有序序列，都支持使用双向索引访问其中的元素。</p>
<p>元组属于<strong>不可变（immutable）序列</strong>，一旦被创建，元组内的元素不可以修改，也无法添加或删除元素，若要调整，只能重新建立元组。 </p>
<p>元组没有提供append()、extend()和insert()等方法，无法向元组中添加元素；同样，元组也没有 remove() 和 pop() 方法，也不支持对元组元素进行del操作，不能从元组中删除元素，而只能使用del命令删除整个元组。</p>
<p>虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表，可改变元组中可变对象的值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuple4 = (<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,[<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>])</span><br><span class="line">tuple4[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">&#x27;X&#x27;</span></span><br><span class="line">tuple4[<span class="number">2</span>][<span class="number">1</span>] = <span class="string">&#x27;Y&#x27;</span></span><br><span class="line">tuple4 [<span class="number">2</span>][<span class="number">2</span>:] = <span class="string">&#x27;Z&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(tuple4)</span><br></pre></td></tr></table></figure>

<p><img src="/../resources/image-20220327180107663.png" alt="image-20220327180107663"></p>
<p>元组也支持切片操作，但是只能通过切片来访问元组中的元素，而不允许使用切片来修改元组中元素的值， 也不支持使用切片操作来为元组增加或删除元素。</p>
<p>Python内部实现对元组做了大量优化，访问速度比列表更快。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = (<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>,[<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">b = <span class="built_in">tuple</span>(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line">color_tuple = <span class="string">&#x27;Red&#x27;</span>,<span class="string">&#x27;Green&#x27;</span>,<span class="string">&#x27;Blue&#x27;</span></span><br><span class="line">t2 = (<span class="number">4</span>)</span><br><span class="line">t3 = (<span class="number">4</span>,)</span><br><span class="line">t4 = <span class="built_in">tuple</span>(<span class="built_in">range</span>(<span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(color_tuple)</span><br><span class="line"><span class="built_in">print</span>(t2)</span><br><span class="line"><span class="built_in">print</span>(t3)</span><br><span class="line"><span class="built_in">print</span>(t4)</span><br></pre></td></tr></table></figure>

<p><img src="/../resources/image-20220327180249686.png" alt="image-20220327180249686"></p>
<p>元组的基本操作：</p>
<p>元组也是序列，因此一些用于列表的基本操作也可以用在元组上。</p>
<p>可以使用下标访问元组的元素，支持两个方法 count()  和 index()，提供 in 和 not in 运算符来判断元素是否在元组中，提供对元组进行切片等等。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">t1 = <span class="built_in">tuple</span>(<span class="built_in">range</span>(<span class="number">4</span>,<span class="number">7</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The second element in t is %d&quot;</span>%t[<span class="number">1</span>])</span><br><span class="line">ttt = t + tt		<span class="comment">#元组连接</span></span><br><span class="line"><span class="built_in">print</span>(ttt)</span><br><span class="line">tttt = ttt[<span class="number">2</span>:<span class="number">7</span>]		<span class="comment">#元组切片</span></span><br><span class="line"><span class="built_in">print</span>(tttt)</span><br><span class="line"><span class="built_in">print</span>(tttt.count(<span class="number">2</span>))	<span class="comment">#计算指定元素第1次出现的下标</span></span><br><span class="line"><span class="built_in">print</span>(tttt.iindex(<span class="number">5</span>))	<span class="comment">#计算指定元素第1次出现的下标</span></span><br><span class="line">t2 = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) * <span class="number">3</span>		<span class="comment">#元组可以数乘</span></span><br><span class="line"><span class="built_in">print</span>(t2)</span><br></pre></td></tr></table></figure>

<p>采用 list() 函数可以将元组转换为列表。</p>
<p>采用 tuple() 函数可以将列表转换为元组。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">tuple</span>([<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>])</span><br><span class="line">b = <span class="built_in">list</span>((<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup = <span class="built_in">tuple</span>(<span class="string">&#x27;bar&#x27;</span>)			<span class="comment">#创建元组</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;输出元组tup:&#x27;</span>,tup)	 <span class="comment">#输出元组</span></span><br><span class="line">nested_tup = (<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">8</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;输出元组tup:&#x27;</span>,nested_tup)	<span class="comment">#输出元素是元组的元组</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;元组的连接&#x27;</span>,tup+<span class="built_in">tuple</span>(<span class="string">&#x27;wwy&#x27;</span>))</span><br><span class="line">a,b,c = tup				<span class="comment">#元组的拆分</span></span><br><span class="line"><span class="built_in">print</span>(a,b,c)</span><br><span class="line"><span class="built_in">print</span>(tup.count(a))		<span class="comment">#统计某个数值在元组中出现的次数</span></span><br></pre></td></tr></table></figure>

<p><img src="/../resources/image-20220327181719434.png" alt="image-20220327181719434"></p>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>字典，也称映射，是一个由键&#x2F;值对组成的非排序可变集合体。键值对在字典中以下面的方式标记：</p>
<p>dict &#x3D; {key1 : value1, key2 : value2 }</p>
<p>在同一个字典中，“键(key)”必须是唯一的，但“值 (value)”是可以重复的。</p>
<p><strong>字典的创建：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d=&#123;<span class="string">&#x27;one&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;two&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;three&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line">dict1 = &#123;<span class="string">&#x27;Alice&#x27;</span>:<span class="string">&#x27;2341&#x27;</span>,<span class="string">&#x27;Beth&#x27;</span>:<span class="string">&#x27;9102&#x27;</span>,<span class="string">&#x27;Cecil&#x27;</span>:<span class="string">&#x27;3258&#x27;</span>&#125;</span><br><span class="line">dict1[<span class="string">&#x27;Jack&#x27;</span>]=<span class="string">&#x27;1234&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(dict1)</span><br><span class="line"><span class="built_in">type</span>(dict1)</span><br></pre></td></tr></table></figure>

<p><img src="/../resources/image-20220327183737491.png" alt="image-20220327183737491"></p>
<p>通过内置的dict()函数来创建:</p>
<p><img src="/python%E5%BA%8F%E5%88%97%E7%BB%93%E6%9E%9C/image-20220327184133693-16483777074891.png" alt="image-20220327184133693"></p>
<p>通过关键字创建字典：</p>
<p><img src="/../resources/image-20220327184335506.png" alt="image-20220327184335506"></p>
<p><strong>字典的基本操作：</strong></p>
<ul>
<li>字典元素的访问：<ul>
<li>使用“键”作为下标就可以访问对应的“值”，如果字典中不存在这个“键”会抛出异常。</li>
<li>还可以通过get()方法返回指定“键”对应的“值”， 并且允许指定该键不存在时返回特定的“值”。</li>
<li>使用keys()方法得到所有的“键”，使用values()方法得到所有的“值”，使用item()方法得到所有的 “键”和“值”。</li>
</ul>
</li>
</ul>
<p><img src="/../resources/image-20220327185718208.png" alt="image-20220327185718208"></p>
<ul>
<li>字典元素的添加：<ul>
<li>使用字典的update()方法来添加元素，还可以使 用“键”的方式来增加元素。</li>
</ul>
</li>
</ul>
<p><img src="/../resources/image-20220327190045390.png" alt="image-20220327190045390"></p>
<ul>
<li>字典元素的修改：<ul>
<li>有两种方法,可以通过“键”的方式来赋值，或者使用update()方法。</li>
</ul>
</li>
</ul>
<p><img src="/../resources/image-20220327190118814.png" alt="image-20220327190118814"></p>
<ul>
<li>字典元素的删除：<ul>
<li>删除字典元素可以使用del命令、使用字典对象的pop()和 popitem()方法等方式。</li>
<li>如果要删除字典所有元素使用clear()方法。</li>
</ul>
</li>
</ul>
<p><img src="/../resources/image-20220327190136518.png" alt="image-20220327190136518"></p>
<ul>
<li>通过zip()函数协助构造字典。65<ul>
<li>zip()函数的作用是将可迭代对象作为参数，将对象中对应的元素打包成多个元组，然后返回由这些元组组成的对象。</li>
</ul>
</li>
</ul>
<p><img src="/../resources/image-20220327190150153.png" alt="image-20220327190150153"></p>
<p>字典的常用方法：</p>
<p><img src="/python%E5%BA%8F%E5%88%97%E7%BB%93%E6%9E%9C/image-20220327190224347-16483789615692.png" alt="image-20220327190224347"></p>
<p><strong>对字典的转换：</strong></p>
<p>可以使用函数 tuple() 和 list() 将字典转换为元组和列表，但要注意的是，这里的转换后和之前的元素顺序是不同的，因为字典类似于散列，列表类似于链表，元组类似于列表只是元素无法改变，所以， 要把散列转换为链表而顺序不变是不可行的。</p>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>集合（set）属于Python无序可变序列，使用一 对大括号“{}”作为定界符，元素之间使用逗号分隔，同一个集合内的每个元素都是唯一的，元素之间不允许重复。 </p>
<p>集合中只能包含数字、字符串、元组等不可变类型（或者说可哈希）的数据，而不能包含列表、 字典、集合等可变类型的数据。</p>
<p><strong>集合的创建：</strong></p>
<p><img src="/../resources/image-20220327190645807.png" alt="image-20220327190645807"></p>
<p><strong>集合元素的增加：</strong>、</p>
<p>使用集合对象的 add() 方法可以增加新元素，如果该元素 已存在则忽略该操作，不会抛出异常；update() 方法用于 合并另外一个集合中的元素到当前集合中，并自动去除重复元素。</p>
<p><img src="/../resources/image-20220327190711245.png" alt="image-20220327190711245"></p>
<p> <strong>集合元素的删除：</strong></p>
<ul>
<li>pop() 方法用于<strong>随机删除</strong>并返回集合中的一个元素，如果集合为空则抛出异常。</li>
<li>remove() 方法用于删除集合中的元素，如果指定元素不存在则抛出异常。</li>
<li>discard() 用于从集合中删除一个特定元素，如果元素不在集合中则忽略该操作。</li>
<li>clear()方法清空集合删除所有元素。</li>
</ul>
<p><img src="/../resources/image-20220327191019587.png" alt="image-20220327191019587"></p>
<p><img src="/../resources/image-20220327191032610.png" alt="image-20220327191032610"></p>
<p><strong>集合运算：</strong> Python集合支持交集、并集、差集、对称 差集等运算，此外还包括集合大小的比较、 子集与父集的判断等。</p>
<p> <img src="/../resources/image-20220327192032281.png" alt="image-20220327192032281"></p>
<p><img src="/../resources/image-20220327192049746.png" alt="image-20220327192049746"></p>
<p><img src="/../resources/image-20220327192102639.png" alt="image-20220327192102639"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的一些问题</title>
    <url>/2022/05/27/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>最近在刷二叉树的相关题目，通过这篇博客记录相关知识点，梳理一些做题的思路。</p>
<span id="more"></span>

<h3 id="二叉树的前序遍历"><a href="#二叉树的前序遍历" class="headerlink" title="二叉树的前序遍历"></a>二叉树的前序遍历</h3><p>二叉树的前序遍历说白了就是 按照“<strong>根左右”</strong>的访问顺序来访问二叉树。首先访问二叉树的根节点，如果有左子树就访问它的左子树，依此类推，等所有左子树访问完毕再访问其右子树。</p>
<p><strong>递归</strong></p>
<p>二叉树的递归就是将每个节点的左子树、右子树看成一棵完整的树，那么对于子树的访问或者操作就是对于原树的访问或者操作的子问题。</p>
<p>时间复杂度：O(n)，其中n为二叉树的节点数，遍历二叉树所有节点。</p>
<p>空间复杂度：O(n)，最坏情况二叉树化为链表，递归栈深度为n。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> *   public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(List&lt;Integer&gt; list, TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(list,root.val);</span><br><span class="line">        preorder(list,root.left);</span><br><span class="line">        preorder(list,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] preorderTraversal(TreeNode root)&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        preorder(list,root);</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; list.size();i++)</span><br><span class="line">        	res[i] = list.get(i);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>栈</strong></p>
<p>根据 <strong>“根左右”</strong> 的顺序，首先遍历根节点，其次遍历左子树，再遍历右子树。在栈中，如何实现这种操作呢？首先，定义新的数组用来存放节点的值，再将根节点入栈。我们要考虑如何优先访问左子节点，根据栈的先进后出原则可以先将右子节点入栈，然后下一轮访问左子节点，这样每次从栈中弹出一个元素进行访问，实现二叉树的前序遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> *   public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] preorderTraversal (TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">       List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;TreeNode&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        s.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!s.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> s.pop();</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>)</span><br><span class="line">                s.push(node.right);</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>)</span><br><span class="line">                s.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; list.size();i++)</span><br><span class="line">            res[i] = list.get(i);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二叉树的后序遍历"><a href="#二叉树的后序遍历" class="headerlink" title="二叉树的后序遍历"></a>二叉树的后序遍历</h3><p><strong>递归</strong></p>
<p>二叉树的后序遍历说白了就是 ”左右根“，展开来说就是先访问左子树，然后再访问右子树，最后访问根节点。</p>
<p>时间复杂度：O(n)，其中n为二叉树的节点数，遍历二叉树所有节点。</p>
<p>空间复杂度：O(n)，最坏情况下二叉树转换为链表，递归栈深度为n</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> *   public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postorder</span><span class="params">(List&lt;Integer&gt; list,TreeNode root)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">        postorder(list,root.left);</span><br><span class="line">        postorder(list,root.right);</span><br><span class="line">        list.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] postorderTraversal (TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        postorder(list,root);</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; list.size();i++)&#123;</span><br><span class="line">            res[i] = list.get(i);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>栈：</strong></p>
<p>二叉树的前序和中序遍历都可以使用栈来替代递归，同样二叉树的后序遍历同样可以。</p>
<p>我们根据 ”左右中“ 的顺序，首先要找到每棵子树的最左端节点，如果它还有一个右节点，根据 “左右根” 的遍历原则，我们还要访问右子树。之后该如何访问根节点呢？</p>
<p>当从栈中弹出根节点，那么一定是左节点已经被访问过了，同时还要保证右节点也已经被访问过了。如果右子树为空，则无需访问，如果右子树不为空，优先进入右子树，此时再将根节点加入栈中。</p>
<p>当右节点被访问了，又回到了根，我们如何知道右节点被访问呢？用一个前序指针 pre 标记一下，当要回到上一个根节点时，检查一下，如果 pre 确实是它的右子节点，那刚刚已经访问过了，可以访问根节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> *   public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> *   public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] postorderTraversal (TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;TreeNode&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span> || !s.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            s.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> s.pop();</span><br><span class="line">        <span class="keyword">if</span>(node.right == <span class="literal">null</span> || node.right == pre)&#123;</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            pre = node;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            s.push(node);</span><br><span class="line">            root = node.right;</span><br><span class="line">         &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; list.size();i++)</span><br><span class="line">            res[i] = list.get(i);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)，其中n为二叉树的节点数，遍历二叉树所有节点。</p>
<p>空间复杂度：O(n)，辅助栈空间最大为链表所有节点数。</p>
<h3 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h3><p><strong>递归</strong></p>
<p>二叉树的中序遍历，就是根据 “左根右” 的顺序来访问二叉树的节点。我们优先访问它的左子树，等左子树全部节点都访问完毕，再访问根节点，最后访问右子树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> *   public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">       </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(List&lt;Integer&gt; list,TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(list,root.left);</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        inorder(list,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] inorderTraversal (TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">		List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        inorder(list,root);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; list.size();i++)</span><br><span class="line">            res[i] = list.get(i);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>栈</strong></p>
<p>二叉树的中序遍历与前序遍历相似，我们利用栈来代替递归。从根节点开始不断向左访问，第一个访问的叶子节点一定是最左面的节点。然后访问该节点的右子树，最后向上回到父问题。</p>
<p>时间复杂度：O(n)，其中n为二叉树的节点数，遍历二叉树所有节点。</p>
<p>空间复杂度：O(n)，辅助栈空间最大为链表所有节点数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> *   public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] inorderTraversal (TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;TreeNode&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span> || !s.isEmpty())&#123;</span><br><span class="line">			<span class="keyword">while</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">                s.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> s.pop();</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            root = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; list.size();i++)</span><br><span class="line">            res[i] = list.get(i);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h3><p><strong>递归：</strong></p>
<p>按行遍历的关键是每一行的深度对应了它输出在二维数组中的深度，即深度可以与二维数组的下标对应，那我们可以在递归的访问每个节点的时候记录深度：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root,<span class="type">int</span> depth)</span></span><br></pre></td></tr></table></figure>

<p>进入子节点时，深度加1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">traverse(root.left,depth + <span class="number">1</span>);</span><br><span class="line">traverse(root.right,depth + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>每个节点值放入二维数组相应行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">res[depth - <span class="number">1</span>].push_back(root-&gt;val);</span><br></pre></td></tr></table></figure>

<ul>
<li>首先，判断二叉树是否为空，空树则没有遍历结果</li>
<li>递归进行层次遍历输出，每次递归记录当前二叉树的深度，每当遍历到一个节点，如果为空直接返回</li>
<li>如果遍历的节点不为空，输出二维数组中一维数组的个数（即代表了输出的行数）小于深度，说明这个节点应该是新的一层，我们在二维数组中增加一个一维数组，然后再加入二叉树元素。</li>
<li>如果不是第三种情况说明这个深度我们已经有了数组，直接根据深度作为下标取出数组，将元素加在最后就可以了。</li>
<li>处理完这个节点，再依次递归进入左右节点，同时深度增加。因为我们进入递归的时候是先左后右，那么遍历的时候也是先左后右，正好是层次遍历的顺序。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型ArrayList&lt;ArrayList&lt;&gt;&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root,<span class="type">int</span> depth)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res.size() &lt; depth)&#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; row = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">                res.add(row);</span><br><span class="line">                row.add(root.val);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; row = res.get(depth - <span class="number">1</span>);</span><br><span class="line">                row.add(root.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        traverse(root.left,depth + <span class="number">1</span>);</span><br><span class="line">        traverse(root.right,depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span> <span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        traverse(root, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>队列</strong></p>
<ul>
<li>首先判断二叉树是否为空，空树没有遍历结果。</li>
<li>建立辅助队列，根节点首先进入队列。不管层次怎么访问，根节点一定是第一个，那它肯定排在队伍的最前面。</li>
<li>每次进入一层，统计队列中元素的个数。因为每当访问完一层，下一层作为这一层的子节点，一定都加入队列，而再下一层还没有加入，因此此时队列中的元素个数就是这一层的元素个数。</li>
<li>每次遍历这一层这么多的节点数，将其依次从队列中弹出，然后加入这一行的一维数组中，如果它们有子节点，依次加入队列排队等待访问。</li>
<li>访问完这一层的元素后，将这个一维数组加入二维数组中，再访问下一层。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型ArrayList&lt;ArrayList&lt;&gt;&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span> <span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;TreeNode&gt;();</span><br><span class="line">        q.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">			ArrayList&lt;Integer&gt; row = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> q.size();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                row.add(cur.val);</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="literal">null</span>)</span><br><span class="line">                    q.add(cur.left);</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="literal">null</span>)</span><br><span class="line">                    q.add(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(row);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的问题（二）</title>
    <url>/2022/06/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>整理完二叉树的前序、中序、后序、层次遍历之后，进一步学习，记录一下其他有关二叉树的知识。<span id="more"></span></p>
<h3 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h3><p><strong>递归：</strong></p>
<p>二叉树的深度是指树的根节点到任一叶子节点路径上节点的数量，因此从根节点每次向下一层深度都会加1。所以二叉树的深度等于根节点这个1层加上左子树和右子树深度的最大值。同时，我们可以将每一个子树都看成一个根节点，继续用上述方法求深度，将问题划分为子问题，利用递归解决。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span> <span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left),maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)，其中n为二叉树的节点数，遍历整棵二叉树。</p>
<p>空间复杂度：O(n)，最坏情况下，二叉树化为链表，递归栈深度最大为n。</p>
<p><strong>层次遍历（队列）</strong></p>
<p>根据层次遍历来统计二叉树最大深度，有的层可能会有很多节点，有的层只有一个节点，无论有多少个节点，它们都是一层。所以采取层次遍历，只需统计层数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span> <span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    	Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> q.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> q.poll()</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)</span><br><span class="line">                    q.offer(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)</span><br><span class="line">                    q.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">             res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h3><p><strong>递归前序遍历：</strong></p>
<p>如果想将两棵二叉树合并起来，那么一定要遍历两颗二叉树，那我们可以考虑同步遍历两棵二叉树，这样就可以将每次遍历的值相加在一起。</p>
<ul>
<li>首先判断t1与t2是否为空，若为则用另一个代替，若都为空，返回的值也是空。</li>
<li>然后依据前序遍历的特点，优先访问根节点，将两个根点的值相加创建到新树中。</li>
<li>s两棵树再依次同步进入左子树和右子树。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span> <span class="params">(TreeNode t1, TreeNode t2)</span> &#123;</span><br><span class="line">        <span class="comment">//若只有一个节点返回另一个，两个都为null自然返回null</span></span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">null</span>) </span><br><span class="line">            <span class="keyword">return</span> t2;</span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> t1;</span><br><span class="line">        <span class="comment">//根左右的方式递归</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(t1.val + t2.val);</span><br><span class="line">        head.left = mergeTrees(t1.left, t2.left);</span><br><span class="line">        head.right = mergeTrees(t1.right, t2.right);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(min(n,m))，m和n分别为两棵树的节点树，当一个树访问完时，自然就连接上另一个树的节点，故只访问了小树的节点数。</li>
<li>空间复杂度：O(min(n,m))，递归栈深度也同时间，只访问了小树的节点数。</li>
</ul>
<p><strong>队列：</strong></p>
<p>使用队列辅助两个二叉树分别同时层次遍历。</p>
<ul>
<li>首先判断t1与t2是否为空，若为则用另一个代替，若都为空，返回的值也是空。</li>
<li>使用三个辅助队列，第一个队列q用于暂存合并后的二叉树的层次遍历节点，第二个队列q1用于暂存t1的层次遍历节点，第三个队列q2用于暂存t2的层次遍历节点。</li>
<li>两棵树同步层次遍历，先将根节点加入队列中，同时根节点优先合并。</li>
<li>每次从队列分别弹出一个元素，判断分别二者的左右子节点是否存在，若是都存在，则相加合并，若是只存在一个则连接该存在的节点，若是都不存在则连接null。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span> <span class="params">(TreeNode t1, TreeNode t2)</span> &#123;</span><br><span class="line">        <span class="comment">//若只有一个节点返回另一个，两个都为null自然返回null</span></span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> t2;</span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> t1;</span><br><span class="line">        <span class="comment">//合并根节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(t1.val + t2.val); </span><br><span class="line">        <span class="comment">//连接后的树的层次遍历节点</span></span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;(); </span><br><span class="line">        <span class="comment">//分别存两棵树的层次遍历节点</span></span><br><span class="line">        Queue&lt;TreeNode&gt; q1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;(); </span><br><span class="line">        Queue&lt;TreeNode&gt; q2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        q.offer(head);</span><br><span class="line">        q1.offer(t1);  </span><br><span class="line">        q2.offer(t2);</span><br><span class="line">        <span class="keyword">while</span> (!q1.isEmpty() &amp;&amp; !q2.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node1</span> <span class="operator">=</span> q1.poll(); </span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node2</span> <span class="operator">=</span> q2.poll();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">left1</span> <span class="operator">=</span> node1.left;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">left2</span> <span class="operator">=</span> node2.left;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">right1</span> <span class="operator">=</span> node1.right;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">right2</span> <span class="operator">=</span> node2.right;</span><br><span class="line">            <span class="keyword">if</span>(left1 != <span class="literal">null</span> || left2 != <span class="literal">null</span>)&#123; </span><br><span class="line">                <span class="comment">//两个左节点都存在</span></span><br><span class="line">                <span class="keyword">if</span>(left1 != <span class="literal">null</span> &amp;&amp; left2 != <span class="literal">null</span>)&#123; </span><br><span class="line">                    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(left1.val + left2.val);</span><br><span class="line">                    node.left = left; </span><br><span class="line">                    <span class="comment">//新节点入队列</span></span><br><span class="line">                    q.offer(left);  </span><br><span class="line">                    q1.offer(left1);</span><br><span class="line">                    q2.offer(left2);</span><br><span class="line">                <span class="comment">//只连接一个节点</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left1 != <span class="literal">null</span>) </span><br><span class="line">                    node.left = left1;</span><br><span class="line">                 <span class="keyword">else</span></span><br><span class="line">                    node.left = left2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(right1 != <span class="literal">null</span> || right2 != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//两个右节点都存在</span></span><br><span class="line">                <span class="keyword">if</span>(right1 != <span class="literal">null</span> &amp;&amp; right2 != <span class="literal">null</span>) &#123; </span><br><span class="line">                    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(right1.val + right2.val);</span><br><span class="line">                    node.right = right;</span><br><span class="line">                    <span class="comment">//新节点入队列</span></span><br><span class="line">                    q.offer(right); </span><br><span class="line">                    q1.offer(right1);</span><br><span class="line">                    q2.offer(right2);</span><br><span class="line">                <span class="comment">//只连接一个节点</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(right1 != <span class="literal">null</span>)  </span><br><span class="line">                    node.right = right1;</span><br><span class="line">                 <span class="keyword">else</span> </span><br><span class="line">                    node.right = right2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h3><p><strong>递归：</strong></p>
<p>检查从根节点到叶子节点有没有一条等于目标值的路径，肯定需要从根节点遍历到叶子，可以在根节点每次往下一层的时候，用sum减去节点值，最后检查是否完整等于0。遍历的方法可以选取二叉树常用的递归前序遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span> <span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="comment">//空节点找不到路径</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//叶子节点，且路径和为sum</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; sum - root.val == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//递归进入子节点</span></span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>栈、dfs</strong></p>
<p>遍历过程除了使用递归也可以使用栈辅助，进行dfs（深度优先搜索）遍历，检查往下的路径中是否有等于sum的路径和。</p>
<p>注意，这里仅是dfs，而不是前序遍历，左右节点的顺序没有关系，因为每次往下都是单独添加某个节点的值相加然后继续往下，因此左右节点谁先遍历不管用。</p>
<ul>
<li>首先检查空节点，空树没有路径。</li>
<li>使用两个栈同步遍历，一个栈记录节点，辅助深度优先搜索，另一个栈跟随记录到该节点为止的路径和。根节点及根节点值先进栈。</li>
<li>遍历的时候每次弹出两个栈中的内容，判断是否是叶子节点且路径和是否等于目标值。</li>
<li>没有到叶子节点就将左右子节点（如果有）加入栈中，并跟随加入路径和。</li>
<li>如果遍历结束也没有找到路径和，则该二叉树中没有。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span> <span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="comment">//空节点找不到路径</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//栈辅助深度优先遍历</span></span><br><span class="line">        Stack&lt;TreeNode&gt; s1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;TreeNode&gt;(); </span><br><span class="line">        <span class="comment">//跟随s1记录到相应节点为止的路径和</span></span><br><span class="line">        Stack&lt;Integer&gt; s2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;(); </span><br><span class="line">        s1.push(root);</span><br><span class="line">        s2.push(root.val);</span><br><span class="line">        <span class="keyword">while</span>(!s1.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//弹出相应节点</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> s1.pop(); </span><br><span class="line">            <span class="comment">//弹出到该点为止的当前路径和</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">cur_sum</span> <span class="operator">=</span> s2.pop(); </span><br><span class="line">            <span class="comment">//叶子节点且当前路径和等于sum</span></span><br><span class="line">            <span class="keyword">if</span>(temp.left == <span class="literal">null</span> &amp;&amp; temp.right == <span class="literal">null</span> &amp;&amp; cur_sum == sum)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//左节点及路径和入栈</span></span><br><span class="line">            <span class="keyword">if</span>(temp.left != <span class="literal">null</span>)&#123; </span><br><span class="line">                s1.push(temp.left);</span><br><span class="line">                s2.push(cur_sum + temp.left.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//右节点及路径和入栈</span></span><br><span class="line">            <span class="keyword">if</span>(temp.right != <span class="literal">null</span>)&#123; </span><br><span class="line">                s1.push(temp.right);</span><br><span class="line">                s2.push(cur_sum + temp.right.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，其中n为二叉树所有节点，遍历二叉树所有节点。</li>
<li>空间复杂度：O(n)，最坏情况二叉树化为链表，递归栈空间最大为n。</li>
</ul>
<h3 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h3><p><strong>递归：</strong></p>
<p>将二叉树镜像，意味着每个左右子树都会交换位置，如果我们从上到下对遍历到的节点交换位置，但是它们后面的节点无法跟着他们一起被交换，因此我们可以考虑自底向上对每两个相对位置的节点交换位置，这样往上各个子树也会被交换位置。</p>
<p>自底向上的遍历方式，我们可以采用<strong>后序递归</strong>的方法。</p>
<ul>
<li>时间复杂度：O(n)，其中n为二叉树的节点数，访问二叉树所有节点各一次。</li>
<li>空间复杂度：O(n)，最坏情况下，二叉树退化为链表，递归栈最大值为n。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">Mirror</span> <span class="params">(TreeNode pRoot)</span> &#123;</span><br><span class="line">        <span class="comment">//空树返回</span></span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//先递归子树</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> Mirror(pRoot.left);  </span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> Mirror(pRoot.right);</span><br><span class="line">        <span class="comment">//交换</span></span><br><span class="line">        pRoot.left = right; </span><br><span class="line">        pRoot.right = left;</span><br><span class="line">        <span class="keyword">return</span> pRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>栈：</strong></p>
<p>栈的访问是一种自顶向下的访问，因此我们需要在左右子节点入栈后直接交换，然后再访问后续栈中内容。</p>
<ul>
<li>优先检查空树的情况。</li>
<li>使用栈辅助遍历二叉树，根节点先进栈。</li>
<li>遍历过程中每次弹出栈中一个元素，然后该节点左右节点分别入栈。</li>
<li>同时我们交换入栈两个子节点的值，因为子节点已经入栈了再交换，就不怕后续没有交换。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">Mirror</span> <span class="params">(TreeNode pRoot)</span> &#123;</span><br><span class="line">        <span class="comment">//空树</span></span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">null</span>)  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//辅助栈</span></span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;TreeNode&gt;(); </span><br><span class="line">        <span class="comment">//根节点先进栈</span></span><br><span class="line">        s.push(pRoot); </span><br><span class="line">        <span class="keyword">while</span> (!s.isEmpty())&#123; </span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> s.pop();</span><br><span class="line">            <span class="comment">//左右节点入栈</span></span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>) </span><br><span class="line">                s.push(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>) </span><br><span class="line">                s.push(node.right);</span><br><span class="line">            <span class="comment">//交换左右</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> node.left; </span><br><span class="line">            node.left = node.right;</span><br><span class="line">            node.right = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h3>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>合并k个已排序的链表</title>
    <url>/2022/05/22/%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%B7%B2%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>今天刷题遇到了<strong>合并K个已排序的链表</strong>这道题，记录，复习一下相关知识点。<span id="more"></span></p>
<p>题目描述为：</p>
<img src="/2022/05/22/%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%B7%B2%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/image-20220522131948214.png" alt="image-20220522131948214" style="zoom:80%;">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例</span><br><span class="line">输入：[&#123;1,2,3&#125;,&#123;4,5,6,7&#125;]</span><br><span class="line">返回值：&#123;1,2,3,4,5,6,7&#125;</span><br><span class="line"></span><br><span class="line">输入：[&#123;1,2&#125;,&#123;1,4,5&#125;,&#123;6&#125;]</span><br><span class="line">返回值：&#123;1,1,2,4,5,6&#125;</span><br></pre></td></tr></table></figure>



<p><strong>思路：</strong></p>
<ol>
<li><p>用朴素方式，遍历合并。</p>
<p>使用【合并两个有序链表】中的方法，合并前两个链表，将下一个链表与当前结果合并，遍历列表中的每个链表，一直循环下去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ArrayList&lt;ListNode&gt; lists)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> lists.size();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> lists.get(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> lists.get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">            node = mergeTwoList(lists.get(i),node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoList</span><span class="params">(ListNode node1,ListNode node2)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> node;</span><br><span class="line">        <span class="keyword">while</span>(node1!=<span class="literal">null</span> &amp;&amp; node2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node1.val &lt; node2.val)&#123;</span><br><span class="line">                tmp.next = node1;</span><br><span class="line">                node1 = node1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tmp.next = node2;</span><br><span class="line">                node2 = node2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.next = node1!=<span class="literal">null</span>?node1:node2;</span><br><span class="line">        <span class="keyword">return</span> node.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法时间复杂度为O(k²n)，提交结果显示运行超时，通过率90.91%。</p>
<img src="/2022/05/22/%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%B7%B2%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/image-20220522124304088.png" alt="image-20220522124304088" style="zoom: 80%;">
</li>
<li><p>分治算法。</p>
<ul>
<li><p>将待排序元素分成大小大致相同的两个子序列</p>
</li>
<li><p>对两个子序列进行合并排序</p>
</li>
<li><p>将排好序的有序子序列进行合并，得到最终的有序序列。</p>
<img src="/2022/05/22/%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%B7%B2%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2hlbmdxaXVtaW5n,size_18,color_FFFFFF,t_70,g_se,x_16.png" alt="img" style="zoom:80%;">

<p>参考：<a href="https://blog.csdn.net/chengqiuming/article/details/123146537?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1-123146537-blog-118992123.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1-123146537-blog-118992123.pc_relevant_default&utm_relevant_index=1"> 分治算法的经典案例——合并排序_chengqiuming的博客-CSDN博客_合并排序</a></p>
<p>首先将待排序序列分成大小大致相同的两个子序列，然后再把子序列继续分成大小大致相同的两个子序列，一直递归下去，直到分解成只剩一个元素；然后执行合并操作。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ArrayList&lt;ListNode&gt; lists)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> merge(lists,<span class="number">0</span>,lists.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">merge</span><span class="params">(ArrayList&lt;ListNode&gt; lists,<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r)</span><br><span class="line">            <span class="keyword">return</span> lists.get(l);</span><br><span class="line">        <span class="keyword">if</span>(l &gt; r)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r-l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> mergeTwoList(merge(lists,l,mid),merge(lists,mid+<span class="number">1</span>,r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//合并两个有序链表</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoList</span><span class="params">(ListNode node1,ListNode node2)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> node;</span><br><span class="line">        <span class="keyword">while</span>(node1!=<span class="literal">null</span> &amp;&amp; node2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node1.val &lt;= node2.val)&#123;</span><br><span class="line">                tmp.next = node1;</span><br><span class="line">                node1 = node1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tmp.next = node2;</span><br><span class="line">                node2 = node2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.next = node1!=<span class="literal">null</span>?node1:node2;</span><br><span class="line">        <span class="keyword">return</span> node.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度：</strong>第一轮合并了 k&#x2F;2 组链表，每一组的时间代价是O(2n)；第二轮合并了 4&#x2F;k 组链表，每一组的时间代价是O(4n)………………时间复杂度为O(kn x log K)</p>
<p>空间复杂度：递归会使用到O(log k)空间代价的栈空间。</p>
</li>
<li><p>优先队列，小根堆。</p>
</li>
</ol>
<p>​        首先，了解<strong>优先级队列</strong>的概念(PriorityQueue)。</p>
<p>​        <strong>队列</strong>是一种先进先出（FIFO）的数据结构，一些情况下，操作的数据会有优先级，一般出队列时，要求优先级高的元素先进性操作，这种情况使用队列就        行不通了。在这种情况下，数据结构提供两个最基本的操作，一个是返回最高优先级对象，一个是添加新对象，这种数据结构就是优先级队列(PriorityQueue)</p>
<p>​        PriorityQueue的底层是<strong>堆</strong>，堆的底层是数组。</p>
<p>​        Java集合框架中提供了<strong>PriorityQueue</strong>和<strong>PriorityBlockingQueue</strong>两种类型的优先级队列，PriorityQueue是<strong>线程不安全</strong>的，PriorityBlockingQueue是<strong>线程安全</strong>的，这里主要使用PriorityQueue。</p>
<ul>
<li>导入PriorityQueue所在的包</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue</span><br></pre></td></tr></table></figure>

<ol>
<li>PriorityQueue中放置的元素必须要能够比较大小 （只有实现了 Comparable 和 Comparator 接口的类才能比较大小），不能插入无法比较大小的对象，否则会抛出 ClassCastException 异常</li>
<li>不能插入 null 对象，否则会抛出 NullPointerException 异常</li>
<li>没有容量限制，可以插入任意多个元素，其内部可以自动扩容</li>
<li>插入和删除元素的时间复杂度均为 O(log2N)</li>
<li>PriorityQueue底层使用了堆数据结构</li>
</ol>
<p>这道题使用优先队列构建一个小顶堆，每次堆顶为值最小的节点，按顺序取出，然后将下一个节点放回去，重复此过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ArrayList&lt;ListNode&gt; lists)</span> &#123;</span><br><span class="line">        <span class="comment">//小根堆</span></span><br><span class="line">        Queue&lt;ListNode&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((v1,v2) -&gt; v1.val - v2.val);</span><br><span class="line">        <span class="comment">//将全部的节点放进去</span></span><br><span class="line">        <span class="keyword">for</span>(ListNode node:lists)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">                pq.offer(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//队首为值最小的节点</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">minNode</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">            tail.next = minNode;</span><br><span class="line">            tail = minNode;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(minNode.next != <span class="literal">null</span>)&#123;</span><br><span class="line">                pq.offer(minNode.next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法、数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串的一些问题</title>
    <url>/2022/06/23/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>最近刷题发现字符串的一类题是自己的弱项，这里记录巩固复习</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>异或运算</title>
    <url>/2022/06/15/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>今天遇到这样一个题目，<a href="https://leetcode.cn/problems/single-number/">136. 只出现一次的数字 - 力扣（LeetCode）</a></p>
<p>起初看题目想到用哈希表实现，使用哈希表存储每个数字和该数字出现的次数。遍历数组即可得到每个数字出现的次数，并更新哈希表，最后遍历哈希表，得到只出现一次的数字。但是时间复杂度以及空间复杂度都是 O(n)，貌似不符合题目的要求。查看答案，标准的解法是异或运算(压根没想到)。。。。。<span id="more"></span></p>
<p>首先，我们要了解什么是<strong>异或运算</strong>。</p>
<p>按位操作符的字面意思很好理解，即对值的二进制格式进行处理的操作符。而异或的作用为：假设有值甲、乙，当甲乙值相等时，异或操作后结果为不等（False，0），反之，为相等（True，1）。所以按位异或操作符的释义便显而易见了：对某值的每个位上的值（0或1）进行异或操作。</p>
<img src="/2022/06/15/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/Users\Congyingxu\AppData\Roaming\Typora\typora-user-images\image-20220615145352777.png" alt="image-20220615145352777" style="zoom:67%;">

<p><strong>异或运算有以下三个性质。</strong></p>
<ol>
<li>任何数和 00 做异或运算，结果仍然是原来的数。<em>a</em>⊕0&#x3D;<em>a</em>。</li>
<li>任何数和其自身做异或运算，结果是 0。<em>a</em>⊕<em>a</em>&#x3D;0。</li>
<li>异或运算满足交换律和结合律。<em>a</em>⊕<em>b</em>⊕<em>a</em>&#x3D;<em>b</em>⊕<em>a</em>⊕<em>a</em>&#x3D;<em>b</em>⊕(<em>a</em>⊕<em>a</em>)&#x3D;<em>b</em>⊕0&#x3D;<em>b</em>。</li>
</ol>
<p>最后附上官方解题代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">single</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            single ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>知识图谱</title>
    <url>/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/</url>
    <content><![CDATA[<h3 id="知识图谱"><a href="#知识图谱" class="headerlink" title="知识图谱"></a>知识图谱</h3><h4 id="知识图谱和人工智能"><a href="#知识图谱和人工智能" class="headerlink" title="知识图谱和人工智能"></a>知识图谱和人工智能</h4><p>​        谈到知识图谱大部人可能很陌生，但说到人工智能，大家早已耳熟能详。目前，很多行业应用人工智能，让机器代替人进行简单重复性的工作。我们可以把人工智能分为两个层次，一个是感知层次，也就是听觉、视觉、嗅觉、味觉等等，目前人工智能在听觉和视觉方面做的比较好，语音识别，图像识别等，研究的学者越来越多，技术逐渐落地。人工智能的第二个层次，也就是认知层次，能够认识这个客观世界。而认知世界是通过大量的知识积累实现的，我们见到狗和猫，见过几次就能分辨出狗和猫，但如何让机器来分辨？这种认知能力是知识的运用，当我们见到狗，就会在潜意识中总结狗的特征，长耳朵，瘦脸，汪汪叫。猫的特征，短耳朵，圆脸，喵喵叫。这些知识会存储在人类的大脑中，作为经验知识，再次碰到类似的动物，人们马上就从记忆中想起该动物的特征，对号入座，马上判断出动物的类型。机器要想具有认知能力，也需要建立一个知识库，然后运用知识库来做一些事，这个知识库就是我们要说的知识图谱。从这个角度说，知识图谱是人工职能的一个重要分支，也是机器具有认知能力的基石，在人工智能领域具有非常重要的地位。</p>
<img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/Users\Congyingxu\AppData\Roaming\Typora\typora-user-images\image-20220811121725316.png" alt="image-20220811121725316" style="zoom:67%;">

<h4 id="知识图谱的由来"><a href="#知识图谱的由来" class="headerlink" title="知识图谱的由来"></a>知识图谱的由来</h4><p>​        知识图谱（Knowledge Graph）是 Google 在2012年对其搜索引擎中使用的知识库的称谓。</p>
<p><img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/Users\Congyingxu\AppData\Roaming\Typora\typora-user-images\image-20220811123027705.png" alt="image-20220811123027705" style="zoom:67%;">众所周知，Google是做搜索引擎的，知识图谱出现之前，我们使用google、百度进行搜索的时候，搜索的结果是一堆网页，我们会根据搜索结果的网页题目再点击链接，才能看到具体内容，2012年google提出Google Knowldge Graph之后，利用知识图谱技术改善了搜索引擎核心，表现出来的效果就是我们现在使用搜索引擎进行搜索的时候，搜索结果会以一定的组织结构呈现，比如我们搜索比尔盖茨，结果如图所示</p>
<img src="https://img2018.cnblogs.com/blog/935893/201812/935893-20181229144559553-575365779.png" alt="img" style="zoom:67%;">

<p>这样的搜索结果，与知识图谱出现之前的结果有什么区别呢，辛格尔博士对知识图谱的介绍很简短，things，not string，抓住了知识图谱的核心，也点出了知识图谱加入之后搜索发生的变化，以前的搜索，都是将要搜索的内容看作字符串，结果是和字符串进行匹配，将匹配程度高的排在前面，后面按照匹配度依次显示。利用知识图谱之后，将搜索的内容不再看作字符串，而是看作客观世界的事物，也就是一个个的个体。搜索比尔盖茨的时候，搜索引擎不是搜索“比尔盖茨”这个字符串，而是搜索比尔盖茨这个人，围绕比尔盖茨这个人，展示与他相关的人和事，左侧百科会把比尔盖茨的主要情况列举出来，右侧显示比尔盖茨的微软产品和与他类似的人，主要是一些IT行业的创始人。一个搜索结果页面就把和比尔盖茨的基本情况和他的主要关系都列出来了，搜索的人很容易找到自己感兴趣的结果。</p>
<h4 id="知识图谱是什么"><a href="#知识图谱是什么" class="headerlink" title="知识图谱是什么"></a>知识图谱是什么</h4><p>​        知识图谱本质上是一种语义网络，用图的形式描述客观事物，这里的图指的是数据结构中的图，也就是由节点和边组成的，这也是知识图谱（Knowledge Graph）的真实含义。</p>
<p><img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/Blog\source\resources\image-20220811122912945.png" alt="image-20220811122912945"></p>
<p>​        知识图谱中的节点表示概念和实体，概念是抽象出来的事物，实体是具体的事物；边表示事物的关系和属性，事物的内部特征用属性来表示，外部联系用关系来表示。</p>
<img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/Users\Congyingxu\AppData\Roaming\Typora\typora-user-images\image-20220811122645526.png" alt="image-20220811122645526" style="zoom:67%;">

<h4 id="知识图谱如何组织数据"><a href="#知识图谱如何组织数据" class="headerlink" title="知识图谱如何组织数据"></a>知识图谱如何组织数据</h4><p>知识图谱是由实体和实体的关系组成，通过图的形式表现出来，那么实体和实体关系的这些数据在知识图谱中怎么组织呢，这就涉及到三元组的概念，在知识图谱中，节点-边-节点可以看作一条记录，第一个节点看作主语，边看作谓语，第二个节点看作宾语，主谓宾构成一条记录。知识图谱由这样的一条条三元组构成，围绕着一个主语，可以有很多的关系呈现，随着知识的不断积累，最终会形成一个庞大的知识图谱，知识图谱建设完成后，会包含海量的数据，内涵丰富的知识。</p>
<img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/Users\Congyingxu\AppData\Roaming\Typora\typora-user-images\image-20220811123405135.png" alt="image-20220811123405135" style="zoom:67%;">

<h4 id="知识图谱的应用场景"><a href="#知识图谱的应用场景" class="headerlink" title="知识图谱的应用场景"></a>知识图谱的应用场景</h4><ol>
<li><p>辅助搜索</p>
<img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/Users\Congyingxu\AppData\Roaming\Typora\typora-user-images\image-20220811123649860.png" alt="image-20220811123649860" style="zoom:67%;">
</li>
<li><p>辅助问答</p>
<img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/Users\Congyingxu\AppData\Roaming\Typora\typora-user-images\image-20220811123933101.png" alt="image-20220811123933101" style="zoom:67%;">

<img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/Users\Congyingxu\AppData\Roaming\Typora\typora-user-images\image-20220811124015557.png" alt="image-20220811124015557" style="zoom:67%;">
</li>
<li><p>辅助数据集成</p>
<img src="/2022/08/11/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/Users\Congyingxu\AppData\Roaming\Typora\typora-user-images\image-20220811124037375.png" alt="image-20220811124037375" style="zoom:67%;">
</li>
<li><p>辅助决策</p>
</li>
</ol>
<p>​        知识图谱是一个具有本体特征的语义网络，可以看成是按照本体模式组织数据的知识库，以知识图谱为基础进行搜索，可以根据查询的内容进行语义搜索，查找需要找的本体或者本体的信息，这种语义搜索功能在google、百度、阿里巴巴等数据量大的公司里得到应用。智能问答，和语义搜索类似，对于提问内容，计算机首先要分析提问问题的语义，然后再将语义转换为查询语句，到知识图谱中查找，将最贴近的答案提供给提问者。推荐系统首先要采集用户的需求，分析用户的以往数据，提取共同特征，然后根据一定的规则，对用户提供推荐的产品。比如淘宝中记录用户经常购买的商品，经常浏览的商品，提取这些商品的共同特征，然后给这个用户打上标签，然后就给用户推荐具有类似特征的商品。</p>
]]></content>
      <categories>
        <category>知识图谱</category>
      </categories>
      <tags>
        <tag>知识图谱</tag>
      </tags>
  </entry>
</search>
